
Atmega2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001bc  00800200  00004a58  00004aec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004a58  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001370  008003bc  008003bc  00004ca8  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004ca8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004d04  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006b8  00000000  00000000  00004d44  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000af24  00000000  00000000  000053fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002461  00000000  00000000  00010320  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006865  00000000  00000000  00012781  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000019cc  00000000  00000000  00018fe8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002229  00000000  00000000  0001a9b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a963  00000000  00000000  0001cbdd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000be0  00000000  00000000  00027540  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f3 c1       	rjmp	.+998    	; 0x3e8 <__ctors_end>
       2:	00 00       	nop
       4:	11 c2       	rjmp	.+1058   	; 0x428 <__bad_interrupt>
       6:	00 00       	nop
       8:	0f c2       	rjmp	.+1054   	; 0x428 <__bad_interrupt>
       a:	00 00       	nop
       c:	0d c2       	rjmp	.+1050   	; 0x428 <__bad_interrupt>
       e:	00 00       	nop
      10:	0b c2       	rjmp	.+1046   	; 0x428 <__bad_interrupt>
      12:	00 00       	nop
      14:	09 c2       	rjmp	.+1042   	; 0x428 <__bad_interrupt>
      16:	00 00       	nop
      18:	07 c2       	rjmp	.+1038   	; 0x428 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	05 c2       	rjmp	.+1034   	; 0x428 <__bad_interrupt>
      1e:	00 00       	nop
      20:	03 c2       	rjmp	.+1030   	; 0x428 <__bad_interrupt>
      22:	00 00       	nop
      24:	01 c2       	rjmp	.+1026   	; 0x428 <__bad_interrupt>
      26:	00 00       	nop
      28:	ff c1       	rjmp	.+1022   	; 0x428 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	fd c1       	rjmp	.+1018   	; 0x428 <__bad_interrupt>
      2e:	00 00       	nop
      30:	fb c1       	rjmp	.+1014   	; 0x428 <__bad_interrupt>
      32:	00 00       	nop
      34:	f9 c1       	rjmp	.+1010   	; 0x428 <__bad_interrupt>
      36:	00 00       	nop
      38:	f7 c1       	rjmp	.+1006   	; 0x428 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	f5 c1       	rjmp	.+1002   	; 0x428 <__bad_interrupt>
      3e:	00 00       	nop
      40:	f3 c1       	rjmp	.+998    	; 0x428 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 8f 0e 	jmp	0x1d1e	; 0x1d1e <__vector_17>
      48:	ef c1       	rjmp	.+990    	; 0x428 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ed c1       	rjmp	.+986    	; 0x428 <__bad_interrupt>
      4e:	00 00       	nop
      50:	eb c1       	rjmp	.+982    	; 0x428 <__bad_interrupt>
      52:	00 00       	nop
      54:	15 c7       	rjmp	.+3626   	; 0xe80 <__vector_21>
      56:	00 00       	nop
      58:	e7 c1       	rjmp	.+974    	; 0x428 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	e5 c1       	rjmp	.+970    	; 0x428 <__bad_interrupt>
      5e:	00 00       	nop
      60:	e3 c1       	rjmp	.+966    	; 0x428 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 74 1e 	jmp	0x3ce8	; 0x3ce8 <__vector_25>
      68:	0c 94 d3 1e 	jmp	0x3da6	; 0x3da6 <__vector_26>
      6c:	dd c1       	rjmp	.+954    	; 0x428 <__bad_interrupt>
      6e:	00 00       	nop
      70:	db c1       	rjmp	.+950    	; 0x428 <__bad_interrupt>
      72:	00 00       	nop
      74:	d9 c1       	rjmp	.+946    	; 0x428 <__bad_interrupt>
      76:	00 00       	nop
      78:	d7 c1       	rjmp	.+942    	; 0x428 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	d5 c1       	rjmp	.+938    	; 0x428 <__bad_interrupt>
      7e:	00 00       	nop
      80:	d3 c1       	rjmp	.+934    	; 0x428 <__bad_interrupt>
      82:	00 00       	nop
      84:	d1 c1       	rjmp	.+930    	; 0x428 <__bad_interrupt>
      86:	00 00       	nop
      88:	cf c1       	rjmp	.+926    	; 0x428 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	cd c1       	rjmp	.+922    	; 0x428 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 1c 1f 	jmp	0x3e38	; 0x3e38 <__vector_36>
      94:	0c 94 7b 1f 	jmp	0x3ef6	; 0x3ef6 <__vector_37>
      98:	c7 c1       	rjmp	.+910    	; 0x428 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	c5 c1       	rjmp	.+906    	; 0x428 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	c3 c1       	rjmp	.+902    	; 0x428 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c1 c1       	rjmp	.+898    	; 0x428 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	bf c1       	rjmp	.+894    	; 0x428 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	bd c1       	rjmp	.+890    	; 0x428 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	bb c1       	rjmp	.+886    	; 0x428 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	b9 c1       	rjmp	.+882    	; 0x428 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	b7 c1       	rjmp	.+878    	; 0x428 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	b5 c1       	rjmp	.+874    	; 0x428 <__bad_interrupt>
      be:	00 00       	nop
      c0:	b3 c1       	rjmp	.+870    	; 0x428 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b1 c1       	rjmp	.+866    	; 0x428 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	af c1       	rjmp	.+862    	; 0x428 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 c4 1f 	jmp	0x3f88	; 0x3f88 <__vector_51>
      d0:	0c 94 23 20 	jmp	0x4046	; 0x4046 <__vector_52>
      d4:	a9 c1       	rjmp	.+850    	; 0x428 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 6c 20 	jmp	0x40d8	; 0x40d8 <__vector_54>
      dc:	0c 94 cb 20 	jmp	0x4196	; 0x4196 <__vector_55>
      e0:	a3 c1       	rjmp	.+838    	; 0x428 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	1f 1c       	adc	r1, r15
      e6:	1f 1c       	adc	r1, r15
      e8:	26 1c       	adc	r2, r6
      ea:	26 1c       	adc	r2, r6
      ec:	2d 1c       	adc	r2, r13
      ee:	2d 1c       	adc	r2, r13
      f0:	34 1c       	adc	r3, r4
      f2:	34 1c       	adc	r3, r4
      f4:	aa 1c       	adc	r10, r10
      f6:	da 1c       	adc	r13, r10
      f8:	13 1d       	adc	r17, r3
      fa:	43 1d       	adc	r20, r3
      fc:	7c 1d       	adc	r23, r12
      fe:	ac 1d       	adc	r26, r12
     100:	e9 1d       	adc	r30, r9
     102:	19 1e       	adc	r1, r25

00000104 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     104:	0f 2e       	mov	r0, r31
     106:	f8 e0       	ldi	r31, 0x08	; 8
     108:	af 2e       	mov	r10, r31
     10a:	f6 e1       	ldi	r31, 0x16	; 22
     10c:	bf 2e       	mov	r11, r31
     10e:	f0 2d       	mov	r31, r0
     110:	01 e1       	ldi	r16, 0x11	; 17
     112:	16 e1       	ldi	r17, 0x16	; 22
     114:	88 24       	eor	r8, r8
     116:	8a 94       	dec	r8
     118:	98 2c       	mov	r9, r8
     11a:	33 24       	eor	r3, r3
     11c:	33 94       	inc	r3
     11e:	43 2c       	mov	r4, r3
     120:	73 2c       	mov	r7, r3
     122:	52 c1       	rjmp	.+676    	; 0x3c8 <prvIdleTask+0x2c4>
     124:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
     128:	8f 5f       	subi	r24, 0xFF	; 255
     12a:	80 93 f2 15 	sts	0x15F2, r24	; 0x8015f2 <uxSchedulerSuspended>
     12e:	d5 01       	movw	r26, r10
     130:	6c 90       	ld	r6, X
     132:	0f b6       	in	r0, 0x3f	; 63
     134:	f8 94       	cli
     136:	0f 92       	push	r0
     138:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
     13c:	81 50       	subi	r24, 0x01	; 1
     13e:	80 93 f2 15 	sts	0x15F2, r24	; 0x8015f2 <uxSchedulerSuspended>
     142:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
     146:	81 11       	cpse	r24, r1
     148:	1a c1       	rjmp	.+564    	; 0x37e <prvIdleTask+0x27a>
     14a:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <uxCurrentNumberOfTasks>
     14e:	81 11       	cpse	r24, r1
     150:	33 c0       	rjmp	.+102    	; 0x1b8 <prvIdleTask+0xb4>
     152:	15 c1       	rjmp	.+554    	; 0x37e <prvIdleTask+0x27a>
     154:	d8 01       	movw	r26, r16
     156:	15 96       	adiw	r26, 0x05	; 5
     158:	ed 91       	ld	r30, X+
     15a:	fc 91       	ld	r31, X
     15c:	16 97       	sbiw	r26, 0x06	; 6
     15e:	c6 81       	ldd	r28, Z+6	; 0x06
     160:	d7 81       	ldd	r29, Z+7	; 0x07
     162:	ce 01       	movw	r24, r28
     164:	0c 96       	adiw	r24, 0x0c	; 12
     166:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
     16a:	7e 01       	movw	r14, r28
     16c:	b2 e0       	ldi	r27, 0x02	; 2
     16e:	eb 0e       	add	r14, r27
     170:	f1 1c       	adc	r15, r1
     172:	c7 01       	movw	r24, r14
     174:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
     178:	8e 89       	ldd	r24, Y+22	; 0x16
     17a:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
     17e:	98 17       	cp	r25, r24
     180:	10 f4       	brcc	.+4      	; 0x186 <prvIdleTask+0x82>
     182:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	9c 01       	movw	r18, r24
     18a:	22 0f       	add	r18, r18
     18c:	33 1f       	adc	r19, r19
     18e:	22 0f       	add	r18, r18
     190:	33 1f       	adc	r19, r19
     192:	22 0f       	add	r18, r18
     194:	33 1f       	adc	r19, r19
     196:	82 0f       	add	r24, r18
     198:	93 1f       	adc	r25, r19
     19a:	b7 01       	movw	r22, r14
     19c:	80 5d       	subi	r24, 0xD0	; 208
     19e:	99 4e       	sbci	r25, 0xE9	; 233
     1a0:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
     1a4:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
     1a8:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
     1ac:	9e 89       	ldd	r25, Y+22	; 0x16
     1ae:	86 89       	ldd	r24, Z+22	; 0x16
     1b0:	98 17       	cp	r25, r24
     1b2:	10 f0       	brcs	.+4      	; 0x1b8 <prvIdleTask+0xb4>
     1b4:	40 92 f7 15 	sts	0x15F7, r4	; 0x8015f7 <xYieldPending>
     1b8:	f8 01       	movw	r30, r16
     1ba:	80 81       	ld	r24, Z
     1bc:	81 11       	cpse	r24, r1
     1be:	ca cf       	rjmp	.-108    	; 0x154 <prvIdleTask+0x50>
     1c0:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
     1c4:	88 23       	and	r24, r24
     1c6:	09 f4       	brne	.+2      	; 0x1ca <prvIdleTask+0xc6>
     1c8:	d4 c0       	rjmp	.+424    	; 0x372 <prvIdleTask+0x26e>
     1ca:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
     1ce:	88 23       	and	r24, r24
     1d0:	09 f4       	brne	.+2      	; 0x1d4 <prvIdleTask+0xd0>
     1d2:	cf c0       	rjmp	.+414    	; 0x372 <prvIdleTask+0x26e>
     1d4:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
     1d8:	81 11       	cpse	r24, r1
     1da:	b1 c0       	rjmp	.+354    	; 0x33e <prvIdleTask+0x23a>
     1dc:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <xTickCount>
     1e0:	90 91 fc 15 	lds	r25, 0x15FC	; 0x8015fc <xTickCount+0x1>
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	90 93 fc 15 	sts	0x15FC, r25	; 0x8015fc <xTickCount+0x1>
     1ea:	80 93 fb 15 	sts	0x15FB, r24	; 0x8015fb <xTickCount>
     1ee:	c0 90 fb 15 	lds	r12, 0x15FB	; 0x8015fb <xTickCount>
     1f2:	d0 90 fc 15 	lds	r13, 0x15FC	; 0x8015fc <xTickCount+0x1>
     1f6:	c1 14       	cp	r12, r1
     1f8:	d1 04       	cpc	r13, r1
     1fa:	89 f5       	brne	.+98     	; 0x25e <prvIdleTask+0x15a>
     1fc:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <pxDelayedTaskList>
     200:	90 91 1d 16 	lds	r25, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
     204:	20 91 1a 16 	lds	r18, 0x161A	; 0x80161a <pxOverflowDelayedTaskList>
     208:	30 91 1b 16 	lds	r19, 0x161B	; 0x80161b <pxOverflowDelayedTaskList+0x1>
     20c:	30 93 1d 16 	sts	0x161D, r19	; 0x80161d <pxDelayedTaskList+0x1>
     210:	20 93 1c 16 	sts	0x161C, r18	; 0x80161c <pxDelayedTaskList>
     214:	90 93 1b 16 	sts	0x161B, r25	; 0x80161b <pxOverflowDelayedTaskList+0x1>
     218:	80 93 1a 16 	sts	0x161A, r24	; 0x80161a <pxOverflowDelayedTaskList>
     21c:	80 91 f6 15 	lds	r24, 0x15F6	; 0x8015f6 <xNumOfOverflows>
     220:	8f 5f       	subi	r24, 0xFF	; 255
     222:	80 93 f6 15 	sts	0x15F6, r24	; 0x8015f6 <xNumOfOverflows>
     226:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
     22a:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
     22e:	80 81       	ld	r24, Z
     230:	81 11       	cpse	r24, r1
     232:	05 c0       	rjmp	.+10     	; 0x23e <prvIdleTask+0x13a>
     234:	90 92 f4 15 	sts	0x15F4, r9	; 0x8015f4 <xNextTaskUnblockTime+0x1>
     238:	80 92 f3 15 	sts	0x15F3, r8	; 0x8015f3 <xNextTaskUnblockTime>
     23c:	10 c0       	rjmp	.+32     	; 0x25e <prvIdleTask+0x15a>
     23e:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
     242:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
     246:	05 80       	ldd	r0, Z+5	; 0x05
     248:	f6 81       	ldd	r31, Z+6	; 0x06
     24a:	e0 2d       	mov	r30, r0
     24c:	06 80       	ldd	r0, Z+6	; 0x06
     24e:	f7 81       	ldd	r31, Z+7	; 0x07
     250:	e0 2d       	mov	r30, r0
     252:	82 81       	ldd	r24, Z+2	; 0x02
     254:	93 81       	ldd	r25, Z+3	; 0x03
     256:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
     25a:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
     25e:	80 91 f3 15 	lds	r24, 0x15F3	; 0x8015f3 <xNextTaskUnblockTime>
     262:	90 91 f4 15 	lds	r25, 0x15F4	; 0x8015f4 <xNextTaskUnblockTime+0x1>
     266:	c8 16       	cp	r12, r24
     268:	d9 06       	cpc	r13, r25
     26a:	10 f4       	brcc	.+4      	; 0x270 <prvIdleTask+0x16c>
     26c:	25 2c       	mov	r2, r5
     26e:	50 c0       	rjmp	.+160    	; 0x310 <prvIdleTask+0x20c>
     270:	25 2c       	mov	r2, r5
     272:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
     276:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
     27a:	80 81       	ld	r24, Z
     27c:	81 11       	cpse	r24, r1
     27e:	05 c0       	rjmp	.+10     	; 0x28a <prvIdleTask+0x186>
     280:	90 92 f4 15 	sts	0x15F4, r9	; 0x8015f4 <xNextTaskUnblockTime+0x1>
     284:	80 92 f3 15 	sts	0x15F3, r8	; 0x8015f3 <xNextTaskUnblockTime>
     288:	43 c0       	rjmp	.+134    	; 0x310 <prvIdleTask+0x20c>
     28a:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
     28e:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
     292:	05 80       	ldd	r0, Z+5	; 0x05
     294:	f6 81       	ldd	r31, Z+6	; 0x06
     296:	e0 2d       	mov	r30, r0
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	8a 81       	ldd	r24, Y+2	; 0x02
     29e:	9b 81       	ldd	r25, Y+3	; 0x03
     2a0:	c8 16       	cp	r12, r24
     2a2:	d9 06       	cpc	r13, r25
     2a4:	28 f4       	brcc	.+10     	; 0x2b0 <prvIdleTask+0x1ac>
     2a6:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
     2aa:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
     2ae:	30 c0       	rjmp	.+96     	; 0x310 <prvIdleTask+0x20c>
     2b0:	7e 01       	movw	r14, r28
     2b2:	f2 e0       	ldi	r31, 0x02	; 2
     2b4:	ef 0e       	add	r14, r31
     2b6:	f1 1c       	adc	r15, r1
     2b8:	c7 01       	movw	r24, r14
     2ba:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
     2be:	8c 89       	ldd	r24, Y+20	; 0x14
     2c0:	9d 89       	ldd	r25, Y+21	; 0x15
     2c2:	89 2b       	or	r24, r25
     2c4:	21 f0       	breq	.+8      	; 0x2ce <prvIdleTask+0x1ca>
     2c6:	ce 01       	movw	r24, r28
     2c8:	0c 96       	adiw	r24, 0x0c	; 12
     2ca:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
     2ce:	8e 89       	ldd	r24, Y+22	; 0x16
     2d0:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
     2d4:	98 17       	cp	r25, r24
     2d6:	10 f4       	brcc	.+4      	; 0x2dc <prvIdleTask+0x1d8>
     2d8:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	9c 01       	movw	r18, r24
     2e0:	22 0f       	add	r18, r18
     2e2:	33 1f       	adc	r19, r19
     2e4:	22 0f       	add	r18, r18
     2e6:	33 1f       	adc	r19, r19
     2e8:	22 0f       	add	r18, r18
     2ea:	33 1f       	adc	r19, r19
     2ec:	82 0f       	add	r24, r18
     2ee:	93 1f       	adc	r25, r19
     2f0:	b7 01       	movw	r22, r14
     2f2:	80 5d       	subi	r24, 0xD0	; 208
     2f4:	99 4e       	sbci	r25, 0xE9	; 233
     2f6:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
     2fa:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
     2fe:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
     302:	9e 89       	ldd	r25, Y+22	; 0x16
     304:	86 89       	ldd	r24, Z+22	; 0x16
     306:	98 17       	cp	r25, r24
     308:	08 f4       	brcc	.+2      	; 0x30c <prvIdleTask+0x208>
     30a:	b3 cf       	rjmp	.-154    	; 0x272 <prvIdleTask+0x16e>
     30c:	27 2c       	mov	r2, r7
     30e:	b1 cf       	rjmp	.-158    	; 0x272 <prvIdleTask+0x16e>
     310:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
     314:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
     318:	86 89       	ldd	r24, Z+22	; 0x16
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	fc 01       	movw	r30, r24
     31e:	ee 0f       	add	r30, r30
     320:	ff 1f       	adc	r31, r31
     322:	ee 0f       	add	r30, r30
     324:	ff 1f       	adc	r31, r31
     326:	ee 0f       	add	r30, r30
     328:	ff 1f       	adc	r31, r31
     32a:	8e 0f       	add	r24, r30
     32c:	9f 1f       	adc	r25, r31
     32e:	fc 01       	movw	r30, r24
     330:	e0 5d       	subi	r30, 0xD0	; 208
     332:	f9 4e       	sbci	r31, 0xE9	; 233
     334:	80 81       	ld	r24, Z
     336:	82 30       	cpi	r24, 0x02	; 2
     338:	08 f0       	brcs	.+2      	; 0x33c <prvIdleTask+0x238>
     33a:	53 c0       	rjmp	.+166    	; 0x3e2 <prvIdleTask+0x2de>
     33c:	0a c0       	rjmp	.+20     	; 0x352 <prvIdleTask+0x24e>
     33e:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
     342:	8f 5f       	subi	r24, 0xFF	; 255
     344:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxPendedTicks>
     348:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
     34c:	88 23       	and	r24, r24
     34e:	41 f0       	breq	.+16     	; 0x360 <prvIdleTask+0x25c>
     350:	05 c0       	rjmp	.+10     	; 0x35c <prvIdleTask+0x258>
     352:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
     356:	81 11       	cpse	r24, r1
     358:	01 c0       	rjmp	.+2      	; 0x35c <prvIdleTask+0x258>
     35a:	21 10       	cpse	r2, r1
     35c:	70 92 f7 15 	sts	0x15F7, r7	; 0x8015f7 <xYieldPending>
     360:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
     364:	81 50       	subi	r24, 0x01	; 1
     366:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxPendedTicks>
     36a:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
     36e:	81 11       	cpse	r24, r1
     370:	31 cf       	rjmp	.-414    	; 0x1d4 <prvIdleTask+0xd0>
     372:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
     376:	81 30       	cpi	r24, 0x01	; 1
     378:	11 f4       	brne	.+4      	; 0x37e <prvIdleTask+0x27a>
     37a:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <vPortYield>
     37e:	0f 90       	pop	r0
     380:	0f be       	out	0x3f, r0	; 63
     382:	66 20       	and	r6, r6
     384:	11 f1       	breq	.+68     	; 0x3ca <prvIdleTask+0x2c6>
     386:	0f b6       	in	r0, 0x3f	; 63
     388:	f8 94       	cli
     38a:	0f 92       	push	r0
     38c:	d5 01       	movw	r26, r10
     38e:	15 96       	adiw	r26, 0x05	; 5
     390:	ed 91       	ld	r30, X+
     392:	fc 91       	ld	r31, X
     394:	16 97       	sbiw	r26, 0x06	; 6
     396:	c6 81       	ldd	r28, Z+6	; 0x06
     398:	d7 81       	ldd	r29, Z+7	; 0x07
     39a:	ce 01       	movw	r24, r28
     39c:	02 96       	adiw	r24, 0x02	; 2
     39e:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
     3a2:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <uxCurrentNumberOfTasks>
     3a6:	81 50       	subi	r24, 0x01	; 1
     3a8:	80 93 fd 15 	sts	0x15FD, r24	; 0x8015fd <uxCurrentNumberOfTasks>
     3ac:	80 91 07 16 	lds	r24, 0x1607	; 0x801607 <uxTasksDeleted>
     3b0:	81 50       	subi	r24, 0x01	; 1
     3b2:	80 93 07 16 	sts	0x1607, r24	; 0x801607 <uxTasksDeleted>
     3b6:	0f 90       	pop	r0
     3b8:	0f be       	out	0x3f, r0	; 63
     3ba:	8f 89       	ldd	r24, Y+23	; 0x17
     3bc:	98 8d       	ldd	r25, Y+24	; 0x18
     3be:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <vPortFree>
     3c2:	ce 01       	movw	r24, r28
     3c4:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <vPortFree>
     3c8:	51 2c       	mov	r5, r1
     3ca:	80 91 07 16 	lds	r24, 0x1607	; 0x801607 <uxTasksDeleted>
     3ce:	81 11       	cpse	r24, r1
     3d0:	a9 ce       	rjmp	.-686    	; 0x124 <prvIdleTask+0x20>
     3d2:	80 91 30 16 	lds	r24, 0x1630	; 0x801630 <pxReadyTasksLists>
     3d6:	82 30       	cpi	r24, 0x02	; 2
     3d8:	08 f4       	brcc	.+2      	; 0x3dc <prvIdleTask+0x2d8>
     3da:	a1 ce       	rjmp	.-702    	; 0x11e <prvIdleTask+0x1a>
     3dc:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <vPortYield>
     3e0:	9c ce       	rjmp	.-712    	; 0x11a <prvIdleTask+0x16>
     3e2:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
     3e6:	ba cf       	rjmp	.-140    	; 0x35c <prvIdleTask+0x258>

000003e8 <__ctors_end>:
     3e8:	11 24       	eor	r1, r1
     3ea:	1f be       	out	0x3f, r1	; 63
     3ec:	cf ef       	ldi	r28, 0xFF	; 255
     3ee:	d1 e2       	ldi	r29, 0x21	; 33
     3f0:	de bf       	out	0x3e, r29	; 62
     3f2:	cd bf       	out	0x3d, r28	; 61
     3f4:	00 e0       	ldi	r16, 0x00	; 0
     3f6:	0c bf       	out	0x3c, r16	; 60

000003f8 <__do_copy_data>:
     3f8:	13 e0       	ldi	r17, 0x03	; 3
     3fa:	a0 e0       	ldi	r26, 0x00	; 0
     3fc:	b2 e0       	ldi	r27, 0x02	; 2
     3fe:	e8 e5       	ldi	r30, 0x58	; 88
     400:	fa e4       	ldi	r31, 0x4A	; 74
     402:	00 e0       	ldi	r16, 0x00	; 0
     404:	0b bf       	out	0x3b, r16	; 59
     406:	02 c0       	rjmp	.+4      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     408:	07 90       	elpm	r0, Z+
     40a:	0d 92       	st	X+, r0
     40c:	ac 3b       	cpi	r26, 0xBC	; 188
     40e:	b1 07       	cpc	r27, r17
     410:	d9 f7       	brne	.-10     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>

00000412 <__do_clear_bss>:
     412:	27 e1       	ldi	r18, 0x17	; 23
     414:	ac eb       	ldi	r26, 0xBC	; 188
     416:	b3 e0       	ldi	r27, 0x03	; 3
     418:	01 c0       	rjmp	.+2      	; 0x41c <.do_clear_bss_start>

0000041a <.do_clear_bss_loop>:
     41a:	1d 92       	st	X+, r1

0000041c <.do_clear_bss_start>:
     41c:	ac 32       	cpi	r26, 0x2C	; 44
     41e:	b2 07       	cpc	r27, r18
     420:	e1 f7       	brne	.-8      	; 0x41a <.do_clear_bss_loop>
     422:	7a d5       	rcall	.+2804   	; 0xf18 <main>
     424:	0c 94 2a 25 	jmp	0x4a54	; 0x4a54 <_exit>

00000428 <__bad_interrupt>:
     428:	eb cd       	rjmp	.-1066   	; 0x0 <__vectors>

0000042a <system_tick>:
     42a:	8f 93       	push	r24
     42c:	8f b7       	in	r24, 0x3f	; 63
     42e:	8f 93       	push	r24
     430:	f8 94       	cli
     432:	80 91 28 17 	lds	r24, 0x1728	; 0x801728 <__system_time>
     436:	8f 5f       	subi	r24, 0xFF	; 255
     438:	80 93 28 17 	sts	0x1728, r24	; 0x801728 <__system_time>
     43c:	80 91 29 17 	lds	r24, 0x1729	; 0x801729 <__system_time+0x1>
     440:	8f 4f       	sbci	r24, 0xFF	; 255
     442:	80 93 29 17 	sts	0x1729, r24	; 0x801729 <__system_time+0x1>
     446:	80 91 2a 17 	lds	r24, 0x172A	; 0x80172a <__system_time+0x2>
     44a:	8f 4f       	sbci	r24, 0xFF	; 255
     44c:	80 93 2a 17 	sts	0x172A, r24	; 0x80172a <__system_time+0x2>
     450:	80 91 2b 17 	lds	r24, 0x172B	; 0x80172b <__system_time+0x3>
     454:	8f 4f       	sbci	r24, 0xFF	; 255
     456:	80 93 2b 17 	sts	0x172B, r24	; 0x80172b <__system_time+0x3>
     45a:	8f 91       	pop	r24
     45c:	8f bf       	out	0x3f, r24	; 63
     45e:	8f 91       	pop	r24
     460:	08 95       	ret

00000462 <vDoMeasurements>:
static void vDoMeasurements( void *pvParameters )
{
	( void ) pvParameters; // Just to stop compiler warnings.
	int value ;
	
	ints[IDD_MAX] = -600;
     462:	eb ed       	ldi	r30, 0xDB	; 219
     464:	f3 e0       	ldi	r31, 0x03	; 3
     466:	88 ea       	ldi	r24, 0xA8	; 168
     468:	9d ef       	ldi	r25, 0xFD	; 253
     46a:	91 87       	std	Z+9, r25	; 0x09
     46c:	80 87       	std	Z+8, r24	; 0x08
	ints[IDD_MINI] = 1300;
     46e:	84 e1       	ldi	r24, 0x14	; 20
     470:	95 e0       	ldi	r25, 0x05	; 5
     472:	97 83       	std	Z+7, r25	; 0x07
     474:	86 83       	std	Z+6, r24	; 0x06
	
	static unsigned char  numberOfSensors;
	numberOfSensors = GetSensorCount(); // samassa johtimessa lämpöantureiden määrä
     476:	0e 94 07 0c 	call	0x180e	; 0x180e <GetSensorCount>
     47a:	80 93 be 03 	sts	0x03BE, r24	; 0x8003be <numberOfSensors.3097>

	for( ;; )
	{
		if (numberOfSensors)
		{
			value  = (float)(GetTemperature(0)/1000);
     47e:	0f 2e       	mov	r0, r31
     480:	f8 ee       	ldi	r31, 0xE8	; 232
     482:	cf 2e       	mov	r12, r31
     484:	f3 e0       	ldi	r31, 0x03	; 3
     486:	df 2e       	mov	r13, r31
     488:	e1 2c       	mov	r14, r1
     48a:	f1 2c       	mov	r15, r1
     48c:	f0 2d       	mov	r31, r0
			//minimi
			if (ints[IDD_MINI] >= value)
     48e:	cb ed       	ldi	r28, 0xDB	; 219
     490:	d3 e0       	ldi	r29, 0x03	; 3
	static unsigned char  numberOfSensors;
	numberOfSensors = GetSensorCount(); // samassa johtimessa lämpöantureiden määrä

	for( ;; )
	{
		if (numberOfSensors)
     492:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <numberOfSensors.3097>
     496:	88 23       	and	r24, r24
     498:	91 f1       	breq	.+100    	; 0x4fe <vDoMeasurements+0x9c>
		{
			value  = (float)(GetTemperature(0)/1000);
     49a:	80 e0       	ldi	r24, 0x00	; 0
     49c:	90 e0       	ldi	r25, 0x00	; 0
     49e:	0e 94 09 0c 	call	0x1812	; 0x1812 <GetTemperature>
     4a2:	a7 01       	movw	r20, r14
     4a4:	96 01       	movw	r18, r12
     4a6:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <__divmodsi4>
     4aa:	ca 01       	movw	r24, r20
     4ac:	b9 01       	movw	r22, r18
     4ae:	0e 94 47 21 	call	0x428e	; 0x428e <__floatsisf>
     4b2:	0e 94 14 21 	call	0x4228	; 0x4228 <__fixsfsi>
     4b6:	ab 01       	movw	r20, r22
			//minimi
			if (ints[IDD_MINI] >= value)
     4b8:	2e 81       	ldd	r18, Y+6	; 0x06
     4ba:	3f 81       	ldd	r19, Y+7	; 0x07
     4bc:	26 17       	cp	r18, r22
     4be:	37 07       	cpc	r19, r23
     4c0:	14 f0       	brlt	.+4      	; 0x4c6 <vDoMeasurements+0x64>
			{
				ints[IDD_MINI] = value;
     4c2:	7f 83       	std	Y+7, r23	; 0x07
     4c4:	6e 83       	std	Y+6, r22	; 0x06
			}//maksimi
			if (ints[IDD_MAX] < value)
     4c6:	28 85       	ldd	r18, Y+8	; 0x08
     4c8:	39 85       	ldd	r19, Y+9	; 0x09
     4ca:	24 17       	cp	r18, r20
     4cc:	35 07       	cpc	r19, r21
     4ce:	14 f4       	brge	.+4      	; 0x4d4 <vDoMeasurements+0x72>
			{
				ints[IDD_MAX]= value;
     4d0:	79 87       	std	Y+9, r23	; 0x09
     4d2:	68 87       	std	Y+8, r22	; 0x08
			}
			//keskiarvo
			ints[IDD_AVE] = (ints[IDD_MAX] + ints[IDD_MINI])/2;
     4d4:	28 85       	ldd	r18, Y+8	; 0x08
     4d6:	39 85       	ldd	r19, Y+9	; 0x09
     4d8:	4e 81       	ldd	r20, Y+6	; 0x06
     4da:	5f 81       	ldd	r21, Y+7	; 0x07
     4dc:	24 0f       	add	r18, r20
     4de:	35 1f       	adc	r19, r21
     4e0:	33 23       	and	r19, r19
     4e2:	14 f4       	brge	.+4      	; 0x4e8 <vDoMeasurements+0x86>
     4e4:	2f 5f       	subi	r18, 0xFF	; 255
     4e6:	3f 4f       	sbci	r19, 0xFF	; 255
     4e8:	35 95       	asr	r19
     4ea:	27 95       	ror	r18
     4ec:	3d 83       	std	Y+5, r19	; 0x05
     4ee:	2c 83       	std	Y+4, r18	; 0x04
			
			taskENTER_CRITICAL(); //////////////////////////
     4f0:	0f b6       	in	r0, 0x3f	; 63
     4f2:	f8 94       	cli
     4f4:	0f 92       	push	r0
			ints[ IDD_TEMP ] = value ;					////
     4f6:	7b 83       	std	Y+3, r23	; 0x03
     4f8:	6a 83       	std	Y+2, r22	; 0x02
			taskEXIT_CRITICAL(); ///////////////////////////
     4fa:	0f 90       	pop	r0
     4fc:	0f be       	out	0x3f, r0	; 63
		}
		vTaskDelay(100);
     4fe:	84 e6       	ldi	r24, 0x64	; 100
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	}
     506:	c5 cf       	rjmp	.-118    	; 0x492 <vDoMeasurements+0x30>

00000508 <ReadKeyPadWithLCD>:
#ifndef FUNCTIONS_H_
#define FUNCTIONS_H_

//--------------------- Lcd-näytön näppäimiatöltä luku -----------------------------------
int  ReadKeyPadWithLCD(char *szPrompt, int nMax)
{
     508:	ef 92       	push	r14
     50a:	ff 92       	push	r15
     50c:	0f 93       	push	r16
     50e:	1f 93       	push	r17
     510:	cf 93       	push	r28
     512:	df 93       	push	r29
     514:	cd b7       	in	r28, 0x3d	; 61
     516:	de b7       	in	r29, 0x3e	; 62
     518:	2a 97       	sbiw	r28, 0x0a	; 10
     51a:	0f b6       	in	r0, 0x3f	; 63
     51c:	f8 94       	cli
     51e:	de bf       	out	0x3e, r29	; 62
     520:	0f be       	out	0x3f, r0	; 63
     522:	cd bf       	out	0x3d, r28	; 61
     524:	8c 01       	movw	r16, r24
     526:	7b 01       	movw	r14, r22
	char text[10]={0};
     528:	fe 01       	movw	r30, r28
     52a:	31 96       	adiw	r30, 0x01	; 1
     52c:	8a e0       	ldi	r24, 0x0A	; 10
     52e:	df 01       	movw	r26, r30
     530:	1d 92       	st	X+, r1
     532:	8a 95       	dec	r24
     534:	e9 f7       	brne	.-6      	; 0x530 <ReadKeyPadWithLCD+0x28>
	int nValue=0;
	int key;
	char *p = szPrompt;

	// näytetään kehote
	lcd_clrscr();
     536:	a8 d6       	rcall	.+3408   	; 0x1288 <lcd_clrscr>
	while(*p )
     538:	f8 01       	movw	r30, r16
     53a:	80 81       	ld	r24, Z
     53c:	88 23       	and	r24, r24
     53e:	71 f0       	breq	.+28     	; 0x55c <ReadKeyPadWithLCD+0x54>
     540:	0f 5f       	subi	r16, 0xFF	; 255
     542:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		if(*p == '\n')
     544:	8a 30       	cpi	r24, 0x0A	; 10
     546:	21 f4       	brne	.+8      	; 0x550 <ReadKeyPadWithLCD+0x48>
		lcd_gotoxy(0,1);
     548:	61 e0       	ldi	r22, 0x01	; 1
     54a:	80 e0       	ldi	r24, 0x00	; 0
     54c:	89 d6       	rcall	.+3346   	; 0x1260 <lcd_gotoxy>
		else
		lcd_putc(*p);
     54e:	01 c0       	rjmp	.+2      	; 0x552 <ReadKeyPadWithLCD+0x4a>
     550:	a4 d6       	rcall	.+3400   	; 0x129a <lcd_putc>
	int key;
	char *p = szPrompt;

	// näytetään kehote
	lcd_clrscr();
	while(*p )
     552:	d8 01       	movw	r26, r16
     554:	8d 91       	ld	r24, X+
     556:	8d 01       	movw	r16, r26
     558:	81 11       	cpse	r24, r1
#ifndef FUNCTIONS_H_
#define FUNCTIONS_H_

//--------------------- Lcd-näytön näppäimiatöltä luku -----------------------------------
int  ReadKeyPadWithLCD(char *szPrompt, int nMax)
{
     55a:	f4 cf       	rjmp	.-24     	; 0x544 <ReadKeyPadWithLCD+0x3c>
     55c:	00 e0       	ldi	r16, 0x00	; 0
		lcd_putc(*p);
		p++;
	}
	do
	{
		while( (key = GetKey()) == NO_KEY); // odotetaan painiketta
     55e:	10 e0       	ldi	r17, 0x00	; 0
     560:	ae d5       	rcall	.+2908   	; 0x10be <GetKey>
     562:	90 e0       	ldi	r25, 0x00	; 0
     564:	83 36       	cpi	r24, 0x63	; 99
     566:	91 05       	cpc	r25, r1
     568:	d9 f3       	breq	.-10     	; 0x560 <ReadKeyPadWithLCD+0x58>
		if (key == IDK_UP)
     56a:	82 30       	cpi	r24, 0x02	; 2
     56c:	91 05       	cpc	r25, r1
     56e:	51 f4       	brne	.+20     	; 0x584 <ReadKeyPadWithLCD+0x7c>
		{
			if(nValue < nMax)
     570:	0e 15       	cp	r16, r14
     572:	1f 05       	cpc	r17, r15
     574:	1c f4       	brge	.+6      	; 0x57c <ReadKeyPadWithLCD+0x74>
			nValue++;
     576:	0f 5f       	subi	r16, 0xFF	; 255
     578:	1f 4f       	sbci	r17, 0xFF	; 255
     57a:	14 c0       	rjmp	.+40     	; 0x5a4 <ReadKeyPadWithLCD+0x9c>
			//jos arvo on yli maksimin se nollautuu
			else if (nValue == nMax)
     57c:	e0 16       	cp	r14, r16
     57e:	f1 06       	cpc	r15, r17
     580:	89 f4       	brne	.+34     	; 0x5a4 <ReadKeyPadWithLCD+0x9c>
     582:	2d c0       	rjmp	.+90     	; 0x5de <ReadKeyPadWithLCD+0xd6>
			nValue = 0;
		}
		
		else if(key == IDK_DOWN)
     584:	83 30       	cpi	r24, 0x03	; 3
     586:	91 05       	cpc	r25, r1
     588:	31 f4       	brne	.+12     	; 0x596 <ReadKeyPadWithLCD+0x8e>
		{
			if(nValue)
     58a:	01 15       	cp	r16, r1
     58c:	11 05       	cpc	r17, r1
     58e:	49 f0       	breq	.+18     	; 0x5a2 <ReadKeyPadWithLCD+0x9a>
			nValue--;
     590:	01 50       	subi	r16, 0x01	; 1
     592:	11 09       	sbc	r17, r1
			// jos arvo on alle minimin se menee maksimiksi
			else if(!nValue)
			nValue = nMax;
		}
		else if(key == IDK_SELECT)
     594:	07 c0       	rjmp	.+14     	; 0x5a4 <ReadKeyPadWithLCD+0x9c>
     596:	05 97       	sbiw	r24, 0x05	; 5
		{
			while( (key = GetKey()) != NO_KEY); // odotetaan painiketta vapaaksi
     598:	29 f4       	brne	.+10     	; 0x5a4 <ReadKeyPadWithLCD+0x9c>
     59a:	91 d5       	rcall	.+2850   	; 0x10be <GetKey>
     59c:	83 36       	cpi	r24, 0x63	; 99
     59e:	e9 f7       	brne	.-6      	; 0x59a <ReadKeyPadWithLCD+0x92>
     5a0:	29 c0       	rjmp	.+82     	; 0x5f4 <ReadKeyPadWithLCD+0xec>
		{
			if(nValue)
			nValue--;
			// jos arvo on alle minimin se menee maksimiksi
			else if(!nValue)
			nValue = nMax;
     5a2:	87 01       	movw	r16, r14
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     5a4:	4a e0       	ldi	r20, 0x0A	; 10
     5a6:	be 01       	movw	r22, r28
     5a8:	6f 5f       	subi	r22, 0xFF	; 255
     5aa:	7f 4f       	sbci	r23, 0xFF	; 255
     5ac:	c8 01       	movw	r24, r16
     5ae:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
			return nValue;
		}
		// näytetään arvo
		itoa(nValue,text,10);
		//jos luku on alle 10 lisätään nolla
		if (nValue < 10)
     5b2:	0a 30       	cpi	r16, 0x0A	; 10
     5b4:	11 05       	cpc	r17, r1
		{
			lcd_gotoxy(10,1);
     5b6:	4c f4       	brge	.+18     	; 0x5ca <ReadKeyPadWithLCD+0xc2>
     5b8:	61 e0       	ldi	r22, 0x01	; 1
     5ba:	8a e0       	ldi	r24, 0x0A	; 10
			lcd_putc('0');
     5bc:	51 d6       	rcall	.+3234   	; 0x1260 <lcd_gotoxy>
     5be:	80 e3       	ldi	r24, 0x30	; 48
			lcd_gotoxy(11,1);
     5c0:	6c d6       	rcall	.+3288   	; 0x129a <lcd_putc>
     5c2:	61 e0       	ldi	r22, 0x01	; 1
     5c4:	8b e0       	ldi	r24, 0x0B	; 11
		}
		else 
		lcd_gotoxy(10,1);
     5c6:	4c d6       	rcall	.+3224   	; 0x1260 <lcd_gotoxy>
     5c8:	03 c0       	rjmp	.+6      	; 0x5d0 <ReadKeyPadWithLCD+0xc8>
     5ca:	61 e0       	ldi	r22, 0x01	; 1
     5cc:	8a e0       	ldi	r24, 0x0A	; 10
		lcd_puts(text);
     5ce:	48 d6       	rcall	.+3216   	; 0x1260 <lcd_gotoxy>
     5d0:	ce 01       	movw	r24, r28
     5d2:	01 96       	adiw	r24, 0x01	; 1
     5d4:	66 d6       	rcall	.+3276   	; 0x12a2 <lcd_puts>
		
		while( (key = GetKey()) != NO_KEY); // odotetaan painiketta vapaaksi
     5d6:	73 d5       	rcall	.+2790   	; 0x10be <GetKey>
     5d8:	83 36       	cpi	r24, 0x63	; 99
     5da:	e9 f7       	brne	.-6      	; 0x5d6 <ReadKeyPadWithLCD+0xce>
     5dc:	c1 cf       	rjmp	.-126    	; 0x560 <ReadKeyPadWithLCD+0x58>
     5de:	4a e0       	ldi	r20, 0x0A	; 10
     5e0:	be 01       	movw	r22, r28
     5e2:	6f 5f       	subi	r22, 0xFF	; 255
     5e4:	7f 4f       	sbci	r23, 0xFF	; 255
     5e6:	80 e0       	ldi	r24, 0x00	; 0
     5e8:	90 e0       	ldi	r25, 0x00	; 0
     5ea:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
     5ee:	00 e0       	ldi	r16, 0x00	; 0
		{
			if(nValue < nMax)
			nValue++;
			//jos arvo on yli maksimin se nollautuu
			else if (nValue == nMax)
			nValue = 0;
     5f0:	10 e0       	ldi	r17, 0x00	; 0
     5f2:	e2 cf       	rjmp	.-60     	; 0x5b8 <ReadKeyPadWithLCD+0xb0>
     5f4:	c8 01       	movw	r24, r16
		
		while( (key = GetKey()) != NO_KEY); // odotetaan painiketta vapaaksi
	}
	while(1);
	
}
     5f6:	2a 96       	adiw	r28, 0x0a	; 10
     5f8:	0f b6       	in	r0, 0x3f	; 63
     5fa:	f8 94       	cli
     5fc:	de bf       	out	0x3e, r29	; 62
     5fe:	0f be       	out	0x3f, r0	; 63
     600:	cd bf       	out	0x3d, r28	; 61
     602:	df 91       	pop	r29
     604:	cf 91       	pop	r28
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	ff 90       	pop	r15
     60c:	ef 90       	pop	r14
     60e:	08 95       	ret

00000610 <ShowTime>:
     610:	0f 93       	push	r16

//--------------------- Näytä aika-----------------------------------
void ShowTime(void)
{
     612:	1f 93       	push	r17
     614:	cf 93       	push	r28
     616:	df 93       	push	r29
     618:	cd b7       	in	r28, 0x3d	; 61
     61a:	de b7       	in	r29, 0x3e	; 62
     61c:	28 97       	sbiw	r28, 0x08	; 8
     61e:	0f b6       	in	r0, 0x3f	; 63
     620:	f8 94       	cli
     622:	de bf       	out	0x3e, r29	; 62
     624:	0f be       	out	0x3f, r0	; 63
     626:	cd bf       	out	0x3d, r28	; 61
	char  szVariable[8];  // tulosta arvo
	
	// Hours
	if( intsTime[IDD_HOUR] < 10)
     628:	80 91 cf 03 	lds	r24, 0x03CF	; 0x8003cf <intsTime>
     62c:	90 91 d0 03 	lds	r25, 0x03D0	; 0x8003d0 <intsTime+0x1>
     630:	0a 97       	sbiw	r24, 0x0a	; 10
     632:	14 f4       	brge	.+4      	; 0x638 <ShowTime+0x28>
	lcd_putc('0');
     634:	80 e3       	ldi	r24, 0x30	; 48
     636:	31 d6       	rcall	.+3170   	; 0x129a <lcd_putc>
	
	itoa(intsTime[IDD_HOUR],szVariable,10);
     638:	0f ec       	ldi	r16, 0xCF	; 207
     63a:	13 e0       	ldi	r17, 0x03	; 3
     63c:	4a e0       	ldi	r20, 0x0A	; 10
     63e:	be 01       	movw	r22, r28
     640:	6f 5f       	subi	r22, 0xFF	; 255
     642:	7f 4f       	sbci	r23, 0xFF	; 255
     644:	f8 01       	movw	r30, r16
     646:	80 81       	ld	r24, Z
     648:	91 81       	ldd	r25, Z+1	; 0x01
     64a:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	lcd_puts(szVariable);
     64e:	ce 01       	movw	r24, r28
     650:	01 96       	adiw	r24, 0x01	; 1
     652:	27 d6       	rcall	.+3150   	; 0x12a2 <lcd_puts>
	lcd_putc(':');
     654:	8a e3       	ldi	r24, 0x3A	; 58
     656:	21 d6       	rcall	.+3138   	; 0x129a <lcd_putc>
     658:	f8 01       	movw	r30, r16
	
	// Minutes
	if( intsTime[IDD_MIN] < 10)
     65a:	82 81       	ldd	r24, Z+2	; 0x02
     65c:	93 81       	ldd	r25, Z+3	; 0x03
     65e:	0a 97       	sbiw	r24, 0x0a	; 10
     660:	14 f4       	brge	.+4      	; 0x666 <ShowTime+0x56>
	lcd_putc('0');
     662:	80 e3       	ldi	r24, 0x30	; 48
     664:	1a d6       	rcall	.+3124   	; 0x129a <lcd_putc>
     666:	0f ec       	ldi	r16, 0xCF	; 207
	
	itoa(intsTime[IDD_MIN],szVariable,10);
     668:	13 e0       	ldi	r17, 0x03	; 3
     66a:	4a e0       	ldi	r20, 0x0A	; 10
     66c:	be 01       	movw	r22, r28
     66e:	6f 5f       	subi	r22, 0xFF	; 255
     670:	7f 4f       	sbci	r23, 0xFF	; 255
     672:	f8 01       	movw	r30, r16
     674:	82 81       	ldd	r24, Z+2	; 0x02
     676:	93 81       	ldd	r25, Z+3	; 0x03
     678:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	lcd_puts(szVariable);
     67c:	ce 01       	movw	r24, r28
     67e:	01 96       	adiw	r24, 0x01	; 1
     680:	10 d6       	rcall	.+3104   	; 0x12a2 <lcd_puts>
	lcd_putc(':');
     682:	8a e3       	ldi	r24, 0x3A	; 58
     684:	0a d6       	rcall	.+3092   	; 0x129a <lcd_putc>
     686:	f8 01       	movw	r30, r16
	
	// Seconds
	if( intsTime[IDD_SEC] < 10)
     688:	84 81       	ldd	r24, Z+4	; 0x04
     68a:	95 81       	ldd	r25, Z+5	; 0x05
     68c:	0a 97       	sbiw	r24, 0x0a	; 10
     68e:	14 f4       	brge	.+4      	; 0x694 <ShowTime+0x84>
	lcd_putc('0');
     690:	80 e3       	ldi	r24, 0x30	; 48
     692:	03 d6       	rcall	.+3078   	; 0x129a <lcd_putc>
     694:	4a e0       	ldi	r20, 0x0A	; 10
     696:	be 01       	movw	r22, r28
     698:	6f 5f       	subi	r22, 0xFF	; 255
     69a:	7f 4f       	sbci	r23, 0xFF	; 255
     69c:	80 91 d3 03 	lds	r24, 0x03D3	; 0x8003d3 <intsTime+0x4>
     6a0:	90 91 d4 03 	lds	r25, 0x03D4	; 0x8003d4 <intsTime+0x5>
     6a4:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	
	itoa(intsTime[IDD_SEC],szVariable,10);
	lcd_puts(szVariable);
     6a8:	ce 01       	movw	r24, r28
     6aa:	01 96       	adiw	r24, 0x01	; 1
     6ac:	fa d5       	rcall	.+3060   	; 0x12a2 <lcd_puts>
     6ae:	28 96       	adiw	r28, 0x08	; 8
}
     6b0:	0f b6       	in	r0, 0x3f	; 63
     6b2:	f8 94       	cli
     6b4:	de bf       	out	0x3e, r29	; 62
     6b6:	0f be       	out	0x3f, r0	; 63
     6b8:	cd bf       	out	0x3d, r28	; 61
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	08 95       	ret

000006c4 <ShowDate>:
     6c4:	0f 93       	push	r16
//--------------------- Näytä päivä-----------------------------------
void ShowDate(void)
{
     6c6:	1f 93       	push	r17
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	cd b7       	in	r28, 0x3d	; 61
     6ce:	de b7       	in	r29, 0x3e	; 62
     6d0:	28 97       	sbiw	r28, 0x08	; 8
     6d2:	0f b6       	in	r0, 0x3f	; 63
     6d4:	f8 94       	cli
     6d6:	de bf       	out	0x3e, r29	; 62
     6d8:	0f be       	out	0x3f, r0	; 63
     6da:	cd bf       	out	0x3d, r28	; 61
	char szVariable[8];		//tulosta arvo
	
	
	//Day
	itoa(intsTime[IDD_DAY],szVariable,10);
     6dc:	0f ec       	ldi	r16, 0xCF	; 207
     6de:	13 e0       	ldi	r17, 0x03	; 3
     6e0:	4a e0       	ldi	r20, 0x0A	; 10
     6e2:	be 01       	movw	r22, r28
     6e4:	6f 5f       	subi	r22, 0xFF	; 255
     6e6:	7f 4f       	sbci	r23, 0xFF	; 255
     6e8:	f8 01       	movw	r30, r16
     6ea:	86 81       	ldd	r24, Z+6	; 0x06
     6ec:	97 81       	ldd	r25, Z+7	; 0x07
     6ee:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	lcd_puts(szVariable);
     6f2:	ce 01       	movw	r24, r28
     6f4:	01 96       	adiw	r24, 0x01	; 1
     6f6:	d5 d5       	rcall	.+2986   	; 0x12a2 <lcd_puts>
	lcd_putc('.');
     6f8:	8e e2       	ldi	r24, 0x2E	; 46
     6fa:	cf d5       	rcall	.+2974   	; 0x129a <lcd_putc>
     6fc:	4a e0       	ldi	r20, 0x0A	; 10
     6fe:	be 01       	movw	r22, r28
     700:	6f 5f       	subi	r22, 0xFF	; 255
     702:	7f 4f       	sbci	r23, 0xFF	; 255
     704:	f8 01       	movw	r30, r16
     706:	80 85       	ldd	r24, Z+8	; 0x08
     708:	91 85       	ldd	r25, Z+9	; 0x09
     70a:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	
	//Month
	itoa(intsTime[IDD_MONTH],szVariable,10);
	lcd_puts(szVariable);
     70e:	ce 01       	movw	r24, r28
     710:	01 96       	adiw	r24, 0x01	; 1
	lcd_putc('.');
     712:	c7 d5       	rcall	.+2958   	; 0x12a2 <lcd_puts>
     714:	8e e2       	ldi	r24, 0x2E	; 46
     716:	c1 d5       	rcall	.+2946   	; 0x129a <lcd_putc>
     718:	4a e0       	ldi	r20, 0x0A	; 10
     71a:	be 01       	movw	r22, r28
     71c:	6f 5f       	subi	r22, 0xFF	; 255
     71e:	7f 4f       	sbci	r23, 0xFF	; 255
     720:	f8 01       	movw	r30, r16
     722:	82 85       	ldd	r24, Z+10	; 0x0a
     724:	93 85       	ldd	r25, Z+11	; 0x0b
     726:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	
	//Year
	itoa(intsTime[IDD_YEAR],szVariable,10);
	lcd_puts(szVariable);
     72a:	ce 01       	movw	r24, r28
     72c:	01 96       	adiw	r24, 0x01	; 1
     72e:	b9 d5       	rcall	.+2930   	; 0x12a2 <lcd_puts>
}
     730:	28 96       	adiw	r28, 0x08	; 8
     732:	0f b6       	in	r0, 0x3f	; 63
     734:	f8 94       	cli
     736:	de bf       	out	0x3e, r29	; 62
     738:	0f be       	out	0x3f, r0	; 63
     73a:	cd bf       	out	0x3d, r28	; 61
     73c:	df 91       	pop	r29
     73e:	cf 91       	pop	r28
     740:	1f 91       	pop	r17
     742:	0f 91       	pop	r16
     744:	08 95       	ret

00000746 <ShowBoth>:

//------------näytä päivä ja aika ------------------
void ShowBoth(void)
{
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	cd b7       	in	r28, 0x3d	; 61
     750:	de b7       	in	r29, 0x3e	; 62
     752:	2a 97       	sbiw	r28, 0x0a	; 10
     754:	0f b6       	in	r0, 0x3f	; 63
     756:	f8 94       	cli
     758:	de bf       	out	0x3e, r29	; 62
     75a:	0f be       	out	0x3f, r0	; 63
     75c:	cd bf       	out	0x3d, r28	; 61
	char  szVariable[10];  // print value here

	
	// Hours
	if( intsTime[IDD_HOUR] < 10)
     75e:	80 91 cf 03 	lds	r24, 0x03CF	; 0x8003cf <intsTime>
     762:	90 91 d0 03 	lds	r25, 0x03D0	; 0x8003d0 <intsTime+0x1>
     766:	0a 97       	sbiw	r24, 0x0a	; 10
     768:	14 f4       	brge	.+4      	; 0x76e <ShowBoth+0x28>
	lcd_putc('0');
     76a:	80 e3       	ldi	r24, 0x30	; 48
     76c:	96 d5       	rcall	.+2860   	; 0x129a <lcd_putc>
	
	itoa(intsTime[IDD_HOUR],szVariable,10);
     76e:	0f ec       	ldi	r16, 0xCF	; 207
     770:	13 e0       	ldi	r17, 0x03	; 3
     772:	4a e0       	ldi	r20, 0x0A	; 10
     774:	be 01       	movw	r22, r28
     776:	6f 5f       	subi	r22, 0xFF	; 255
     778:	7f 4f       	sbci	r23, 0xFF	; 255
     77a:	f8 01       	movw	r30, r16
     77c:	80 81       	ld	r24, Z
     77e:	91 81       	ldd	r25, Z+1	; 0x01
     780:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	lcd_puts(szVariable);
     784:	ce 01       	movw	r24, r28
     786:	01 96       	adiw	r24, 0x01	; 1
     788:	8c d5       	rcall	.+2840   	; 0x12a2 <lcd_puts>
	lcd_putc(':');
     78a:	8a e3       	ldi	r24, 0x3A	; 58
     78c:	86 d5       	rcall	.+2828   	; 0x129a <lcd_putc>
     78e:	f8 01       	movw	r30, r16
	
	// Minutes
	if( intsTime[IDD_MIN] < 10)
     790:	82 81       	ldd	r24, Z+2	; 0x02
     792:	93 81       	ldd	r25, Z+3	; 0x03
     794:	0a 97       	sbiw	r24, 0x0a	; 10
     796:	14 f4       	brge	.+4      	; 0x79c <ShowBoth+0x56>
	lcd_putc('0');
     798:	80 e3       	ldi	r24, 0x30	; 48
     79a:	7f d5       	rcall	.+2814   	; 0x129a <lcd_putc>
     79c:	0f ec       	ldi	r16, 0xCF	; 207
	
	itoa(intsTime[IDD_MIN],szVariable,10);
     79e:	13 e0       	ldi	r17, 0x03	; 3
     7a0:	4a e0       	ldi	r20, 0x0A	; 10
     7a2:	be 01       	movw	r22, r28
     7a4:	6f 5f       	subi	r22, 0xFF	; 255
     7a6:	7f 4f       	sbci	r23, 0xFF	; 255
     7a8:	f8 01       	movw	r30, r16
     7aa:	82 81       	ldd	r24, Z+2	; 0x02
     7ac:	93 81       	ldd	r25, Z+3	; 0x03
     7ae:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	lcd_puts(szVariable);
     7b2:	ce 01       	movw	r24, r28
     7b4:	01 96       	adiw	r24, 0x01	; 1
     7b6:	75 d5       	rcall	.+2794   	; 0x12a2 <lcd_puts>
	lcd_putc(' ');
     7b8:	80 e2       	ldi	r24, 0x20	; 32
     7ba:	6f d5       	rcall	.+2782   	; 0x129a <lcd_putc>
     7bc:	4a e0       	ldi	r20, 0x0A	; 10
     7be:	be 01       	movw	r22, r28
     7c0:	6f 5f       	subi	r22, 0xFF	; 255
     7c2:	7f 4f       	sbci	r23, 0xFF	; 255
     7c4:	f8 01       	movw	r30, r16
     7c6:	86 81       	ldd	r24, Z+6	; 0x06
     7c8:	97 81       	ldd	r25, Z+7	; 0x07
     7ca:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	
	//Day
	itoa(intsTime[IDD_DAY],szVariable,10);
	lcd_puts(szVariable);
     7ce:	ce 01       	movw	r24, r28
     7d0:	01 96       	adiw	r24, 0x01	; 1
     7d2:	67 d5       	rcall	.+2766   	; 0x12a2 <lcd_puts>
	lcd_putc('.');
     7d4:	8e e2       	ldi	r24, 0x2E	; 46
     7d6:	61 d5       	rcall	.+2754   	; 0x129a <lcd_putc>
     7d8:	4a e0       	ldi	r20, 0x0A	; 10
     7da:	be 01       	movw	r22, r28
     7dc:	6f 5f       	subi	r22, 0xFF	; 255
     7de:	7f 4f       	sbci	r23, 0xFF	; 255
     7e0:	f8 01       	movw	r30, r16
     7e2:	80 85       	ldd	r24, Z+8	; 0x08
     7e4:	91 85       	ldd	r25, Z+9	; 0x09
     7e6:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	
	//Month
	itoa(intsTime[IDD_MONTH],szVariable,10);
	lcd_puts(szVariable);
     7ea:	ce 01       	movw	r24, r28
     7ec:	01 96       	adiw	r24, 0x01	; 1
     7ee:	59 d5       	rcall	.+2738   	; 0x12a2 <lcd_puts>
	lcd_putc('.');
     7f0:	8e e2       	ldi	r24, 0x2E	; 46
     7f2:	53 d5       	rcall	.+2726   	; 0x129a <lcd_putc>
     7f4:	4a e0       	ldi	r20, 0x0A	; 10
     7f6:	be 01       	movw	r22, r28
     7f8:	6f 5f       	subi	r22, 0xFF	; 255
     7fa:	7f 4f       	sbci	r23, 0xFF	; 255
     7fc:	f8 01       	movw	r30, r16
     7fe:	82 85       	ldd	r24, Z+10	; 0x0a
     800:	93 85       	ldd	r25, Z+11	; 0x0b
     802:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
	
	//Year
	itoa(intsTime[IDD_YEAR],szVariable,10);
	lcd_puts(szVariable);
     806:	ce 01       	movw	r24, r28
     808:	01 96       	adiw	r24, 0x01	; 1
     80a:	4b d5       	rcall	.+2710   	; 0x12a2 <lcd_puts>
     80c:	2a 96       	adiw	r28, 0x0a	; 10
}
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	de bf       	out	0x3e, r29	; 62
     814:	0f be       	out	0x3f, r0	; 63
     816:	cd bf       	out	0x3d, r28	; 61
     818:	df 91       	pop	r29
     81a:	cf 91       	pop	r28
     81c:	1f 91       	pop	r17
     81e:	0f 91       	pop	r16
     820:	08 95       	ret

00000822 <vLcdHandler>:
     822:	cf 93       	push	r28
		
	}
}
//--------------------- lcd-näyttöä päivittävä taski -------------------------------
static void vLcdHandler( void *pvParameters )
{
     824:	df 93       	push	r29
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	28 97       	sbiw	r28, 0x08	; 8
     82c:	0f b6       	in	r0, 0x3f	; 63
     82e:	f8 94       	cli
     830:	de bf       	out	0x3e, r29	; 62
     832:	0f be       	out	0x3f, r0	; 63
     834:	cd bf       	out	0x3d, r28	; 61
	volatile  char *pChDisplay =0,  // osoitin, jota osoittaa nytn pohjatekstiss olevaan kirjaimeen
	*pChVariable=0; // osoitin, jota kytetään muuttujan arvon tulostukseen
	int             i;
	char            szVariable[8]; // muuttujan arvo tulostetaan tähän
	static DISPLAY_MESSAGE message;
	bool skip = false; // vältetään tulostamasta ylimääräisiä
     836:	a1 2c       	mov	r10, r1
	static char *pDisplay3[] = {"Ave=%i02\n%i03 C...%i04 C"}; // vasen, oikea
	static char *pDisplay4[] = {"Up=Set Time\nDown=Set Date"}; //select
	static char *pDisplay5[] = {"Set Time\n%t"};//select ylös
	static char *pDisplay6[] = {"Set Date\n%d"};//select alas
	
	volatile  char *pChDisplay =0,  // osoitin, jota osoittaa nytn pohjatekstiss olevaan kirjaimeen
     838:	00 e0       	ldi	r16, 0x00	; 0
     83a:	10 e0       	ldi	r17, 0x00	; 0

	( void ) pvParameters;	/* Just to stop compiler warnings. */
	
	for( ;; )
	{
		xQueueReceive(xDisplay,&message, portMAX_DELAY); // odotetaan viestiä
     83c:	c1 2c       	mov	r12, r1
			case IDM_AVERAGE:
			pChDisplay = pDisplay3[0];
			break;
			
			case IDM_TIME_DATE:
			pChDisplay = pDisplay4[0];
     83e:	0f 2e       	mov	r0, r31
     840:	f7 e3       	ldi	r31, 0x37	; 55
     842:	2f 2e       	mov	r2, r31
     844:	f2 e0       	ldi	r31, 0x02	; 2
     846:	3f 2e       	mov	r3, r31
     848:	f0 2d       	mov	r31, r0
			case IDM_SET_TIME:
			pChDisplay = pDisplay5[0];
			break;
			
			case IDM_SET_DATE:
			pChDisplay = pDisplay6[0];
     84a:	0f 2e       	mov	r0, r31
     84c:	fd e5       	ldi	r31, 0x5D	; 93
     84e:	4f 2e       	mov	r4, r31
     850:	f2 e0       	ldi	r31, 0x02	; 2
     852:	5f 2e       	mov	r5, r31
     854:	f0 2d       	mov	r31, r0
			case IDM_TIME_DATE:
			pChDisplay = pDisplay4[0];
			break;
			
			case IDM_SET_TIME:
			pChDisplay = pDisplay5[0];
     856:	0f 2e       	mov	r0, r31
     858:	f1 e5       	ldi	r31, 0x51	; 81
     85a:	6f 2e       	mov	r6, r31
     85c:	f2 e0       	ldi	r31, 0x02	; 2
     85e:	7f 2e       	mov	r7, r31
     860:	f0 2d       	mov	r31, r0
			case IDM_MAIN_SCREEN:
			pChDisplay = pDisplay[0];
			break;
			
			case IDM_MINMAX:
			pChDisplay = pDisplay2[0];
     862:	0f 2e       	mov	r0, r31
     864:	fc e0       	ldi	r31, 0x0C	; 12
     866:	8f 2e       	mov	r8, r31
     868:	f2 e0       	ldi	r31, 0x02	; 2
     86a:	9f 2e       	mov	r9, r31
     86c:	f0 2d       	mov	r31, r0
				}
				if(!skip)
				{
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     86e:	bb 24       	eor	r11, r11
     870:	b3 94       	inc	r11
     872:	dc 2c       	mov	r13, r12

	( void ) pvParameters;	/* Just to stop compiler warnings. */
	
	for( ;; )
	{
		xQueueReceive(xDisplay,&message, portMAX_DELAY); // odotetaan viestiä
     874:	2c 2d       	mov	r18, r12
     876:	4f ef       	ldi	r20, 0xFF	; 255
     878:	5f ef       	ldi	r21, 0xFF	; 255
     87a:	6c eb       	ldi	r22, 0xBC	; 188
     87c:	73 e0       	ldi	r23, 0x03	; 3
     87e:	80 91 cd 03 	lds	r24, 0x03CD	; 0x8003cd <xDisplay>
     882:	90 91 ce 03 	lds	r25, 0x03CE	; 0x8003ce <xDisplay+0x1>
     886:	0e 94 43 12 	call	0x2486	; 0x2486 <xQueueGenericReceive>
		
		// jos edellinen ruutu on eri, tyhjennä näyttö ja vaihda nykyiseen
		if(lastScreen != message.idMessage)
     88a:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <__data_end>
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	20 91 ea 03 	lds	r18, 0x03EA	; 0x8003ea <lastScreen>
     894:	30 91 eb 03 	lds	r19, 0x03EB	; 0x8003eb <lastScreen+0x1>
     898:	82 17       	cp	r24, r18
     89a:	93 07       	cpc	r25, r19
     89c:	41 f0       	breq	.+16     	; 0x8ae <vLcdHandler+0x8c>
		{
			lcd_clrscr();
     89e:	f4 d4       	rcall	.+2536   	; 0x1288 <lcd_clrscr>
			lastScreen = message.idMessage;
     8a0:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <__data_end>
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	90 93 eb 03 	sts	0x03EB, r25	; 0x8003eb <lastScreen+0x1>
     8aa:	80 93 ea 03 	sts	0x03EA, r24	; 0x8003ea <lastScreen>
		}
		//vaihdellaan näyttöjen välillä
		switch( message.idMessage)
     8ae:	80 91 bc 03 	lds	r24, 0x03BC	; 0x8003bc <__data_end>
     8b2:	83 30       	cpi	r24, 0x03	; 3
     8b4:	89 f0       	breq	.+34     	; 0x8d8 <vLcdHandler+0xb6>
     8b6:	28 f4       	brcc	.+10     	; 0x8c2 <vLcdHandler+0xa0>
     8b8:	81 30       	cpi	r24, 0x01	; 1
     8ba:	99 f0       	breq	.+38     	; 0x8e2 <vLcdHandler+0xc0>
     8bc:	82 30       	cpi	r24, 0x02	; 2
     8be:	51 f0       	breq	.+20     	; 0x8d4 <vLcdHandler+0xb2>
     8c0:	13 c0       	rjmp	.+38     	; 0x8e8 <vLcdHandler+0xc6>
     8c2:	85 30       	cpi	r24, 0x05	; 5
     8c4:	21 f0       	breq	.+8      	; 0x8ce <vLcdHandler+0xac>
     8c6:	58 f0       	brcs	.+22     	; 0x8de <vLcdHandler+0xbc>
     8c8:	86 30       	cpi	r24, 0x06	; 6
     8ca:	69 f0       	breq	.+26     	; 0x8e6 <vLcdHandler+0xc4>
     8cc:	0d c0       	rjmp	.+26     	; 0x8e8 <vLcdHandler+0xc6>
		{
			
			case IDM_MAIN_SCREEN:
			pChDisplay = pDisplay[0];
     8ce:	02 e0       	ldi	r16, 0x02	; 2
     8d0:	12 e0       	ldi	r17, 0x02	; 2
     8d2:	0a c0       	rjmp	.+20     	; 0x8e8 <vLcdHandler+0xc6>
			break;
			
			case IDM_MINMAX:
			pChDisplay = pDisplay2[0];
     8d4:	84 01       	movw	r16, r8
			break;
     8d6:	08 c0       	rjmp	.+16     	; 0x8e8 <vLcdHandler+0xc6>
			
			case IDM_AVERAGE:
			pChDisplay = pDisplay3[0];
     8d8:	0e e1       	ldi	r16, 0x1E	; 30
     8da:	12 e0       	ldi	r17, 0x02	; 2
			break;
     8dc:	05 c0       	rjmp	.+10     	; 0x8e8 <vLcdHandler+0xc6>
			
			case IDM_TIME_DATE:
			pChDisplay = pDisplay4[0];
     8de:	81 01       	movw	r16, r2
			break;
     8e0:	03 c0       	rjmp	.+6      	; 0x8e8 <vLcdHandler+0xc6>
			
			case IDM_SET_TIME:
			pChDisplay = pDisplay5[0];
     8e2:	83 01       	movw	r16, r6
			break;
     8e4:	01 c0       	rjmp	.+2      	; 0x8e8 <vLcdHandler+0xc6>
			
			case IDM_SET_DATE:
			pChDisplay = pDisplay6[0];
     8e6:	82 01       	movw	r16, r4
			
			default:
			break;
		}
		
		xSemaphoreTake(xPortB, portMAX_DELAY);
     8e8:	2c 2d       	mov	r18, r12
     8ea:	4f ef       	ldi	r20, 0xFF	; 255
     8ec:	5f ef       	ldi	r21, 0xFF	; 255
     8ee:	60 e0       	ldi	r22, 0x00	; 0
     8f0:	70 e0       	ldi	r23, 0x00	; 0
     8f2:	80 91 c9 03 	lds	r24, 0x03C9	; 0x8003c9 <xPortB>
     8f6:	90 91 ca 03 	lds	r25, 0x03CA	; 0x8003ca <xPortB+0x1>
     8fa:	0e 94 43 12 	call	0x2486	; 0x2486 <xQueueGenericReceive>
		
		lcd_gotoxy(0, 0);	// lcd-näytön alkuun
     8fe:	6c 2d       	mov	r22, r12
     900:	8c 2d       	mov	r24, r12
     902:	ae d4       	rcall	.+2396   	; 0x1260 <lcd_gotoxy>
		
		// tulostetaan näyttö tässä silmukassa
		while(*pChDisplay != 0)
     904:	d8 01       	movw	r26, r16
     906:	8c 91       	ld	r24, X
     908:	88 23       	and	r24, r24
     90a:	09 f4       	brne	.+2      	; 0x90e <vLcdHandler+0xec>
     90c:	8c c0       	rjmp	.+280    	; 0xa26 <vLcdHandler+0x204>
		{
			// onko muuttujan tulostuspaikka?
			if( *pChDisplay == '%')
     90e:	f8 01       	movw	r30, r16
     910:	80 81       	ld	r24, Z
     912:	85 32       	cpi	r24, 0x25	; 37
     914:	09 f0       	breq	.+2      	; 0x918 <vLcdHandler+0xf6>
     916:	72 c0       	rjmp	.+228    	; 0x9fc <vLcdHandler+0x1da>
			{
				pChDisplay++; //ohitetaan %-merkki
     918:	78 01       	movw	r14, r16
     91a:	ff ef       	ldi	r31, 0xFF	; 255
     91c:	ef 1a       	sub	r14, r31
     91e:	ff 0a       	sbc	r15, r31
				
				// minkä tyypin dataa?
				switch(*pChDisplay)
     920:	d8 01       	movw	r26, r16
     922:	11 96       	adiw	r26, 0x01	; 1
     924:	8c 91       	ld	r24, X
     926:	84 36       	cpi	r24, 0x64	; 100
     928:	81 f0       	breq	.+32     	; 0x94a <vLcdHandler+0x128>
     92a:	18 f4       	brcc	.+6      	; 0x932 <vLcdHandler+0x110>
     92c:	82 36       	cpi	r24, 0x62	; 98
     92e:	a1 f0       	breq	.+40     	; 0x958 <vLcdHandler+0x136>
     930:	44 c0       	rjmp	.+136    	; 0x9ba <vLcdHandler+0x198>
     932:	89 36       	cpi	r24, 0x69	; 105
     934:	c1 f0       	breq	.+48     	; 0x966 <vLcdHandler+0x144>
     936:	84 37       	cpi	r24, 0x74	; 116
     938:	09 f0       	breq	.+2      	; 0x93c <vLcdHandler+0x11a>
     93a:	3f c0       	rjmp	.+126    	; 0x9ba <vLcdHandler+0x198>
				{
					case 't':
					taskENTER_CRITICAL();
     93c:	0f b6       	in	r0, 0x3f	; 63
     93e:	f8 94       	cli
					ShowTime();
     940:	0f 92       	push	r0
     942:	66 de       	rcall	.-820    	; 0x610 <ShowTime>
					taskEXIT_CRITICAL();
     944:	0f 90       	pop	r0
     946:	0f be       	out	0x3f, r0	; 63
					skip = true;
					break;
     948:	77 c0       	rjmp	.+238    	; 0xa38 <vLcdHandler+0x216>
					
					case 'd':
					taskENTER_CRITICAL();
     94a:	0f b6       	in	r0, 0x3f	; 63
     94c:	f8 94       	cli
					ShowDate();
     94e:	0f 92       	push	r0
     950:	b9 de       	rcall	.-654    	; 0x6c4 <ShowDate>
					taskEXIT_CRITICAL();
     952:	0f 90       	pop	r0
     954:	0f be       	out	0x3f, r0	; 63
					skip = true;
					break;
					
					case 'b':
					taskENTER_CRITICAL();
     956:	70 c0       	rjmp	.+224    	; 0xa38 <vLcdHandler+0x216>
     958:	0f b6       	in	r0, 0x3f	; 63
     95a:	f8 94       	cli
					ShowBoth();
     95c:	0f 92       	push	r0
     95e:	f3 de       	rcall	.-538    	; 0x746 <ShowBoth>
					taskEXIT_CRITICAL();
     960:	0f 90       	pop	r0
     962:	0f be       	out	0x3f, r0	; 63
					skip = true;
					break;
     964:	69 c0       	rjmp	.+210    	; 0xa38 <vLcdHandler+0x216>
					
					case 'i': pChDisplay++;// int-tyypin kokonaislukuja
					// muuttujan arvo poimitaan ints-taulukosta indeksin määräämästä paikasta
					// indeksi annettu muodossa 09, 10,11,..
					i = (*pChDisplay - '0')*10;
     966:	f8 01       	movw	r30, r16
     968:	82 81       	ldd	r24, Z+2	; 0x02
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	c0 97       	sbiw	r24, 0x30	; 48
     96e:	fc 01       	movw	r30, r24
     970:	ee 0f       	add	r30, r30
     972:	ff 1f       	adc	r31, r31
     974:	88 0f       	add	r24, r24
     976:	99 1f       	adc	r25, r25
     978:	88 0f       	add	r24, r24
     97a:	99 1f       	adc	r25, r25
     97c:	88 0f       	add	r24, r24
     97e:	99 1f       	adc	r25, r25
     980:	e8 0f       	add	r30, r24
     982:	f9 1f       	adc	r31, r25
					pChDisplay++;
     984:	78 01       	movw	r14, r16
     986:	83 e0       	ldi	r24, 0x03	; 3
     988:	e8 0e       	add	r14, r24
     98a:	f1 1c       	adc	r15, r1
					i +=  (*pChDisplay- '0'); // indeksi ints-taulukkoon
     98c:	d8 01       	movw	r26, r16
     98e:	13 96       	adiw	r26, 0x03	; 3
     990:	8c 91       	ld	r24, X
					taskENTER_CRITICAL();
     992:	0f b6       	in	r0, 0x3f	; 63
     994:	f8 94       	cli
     996:	0f 92       	push	r0
					itoa(ints[i],szVariable,10);
     998:	e8 0f       	add	r30, r24
     99a:	f1 1d       	adc	r31, r1
     99c:	ee 0f       	add	r30, r30
     99e:	ff 1f       	adc	r31, r31
     9a0:	e5 58       	subi	r30, 0x85	; 133
     9a2:	fc 4f       	sbci	r31, 0xFC	; 252
     9a4:	4a e0       	ldi	r20, 0x0A	; 10
     9a6:	be 01       	movw	r22, r28
     9a8:	6f 5f       	subi	r22, 0xFF	; 255
     9aa:	7f 4f       	sbci	r23, 0xFF	; 255
     9ac:	80 81       	ld	r24, Z
     9ae:	91 81       	ldd	r25, Z+1	; 0x01
     9b0:	0e 94 37 22 	call	0x446e	; 0x446e <__itoa_ncheck>
					taskEXIT_CRITICAL();
     9b4:	0f 90       	pop	r0
     9b6:	0f be       	out	0x3f, r0	; 63
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <vLcdHandler+0x19c>
					skip = false;
					break;
				}
				if(!skip)
     9ba:	a1 10       	cpse	r10, r1
     9bc:	2d c0       	rjmp	.+90     	; 0xa18 <vLcdHandler+0x1f6>
				{
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     9be:	89 81       	ldd	r24, Y+1	; 0x01
     9c0:	88 23       	and	r24, r24
     9c2:	49 f1       	breq	.+82     	; 0xa16 <vLcdHandler+0x1f4>
     9c4:	8e 01       	movw	r16, r28
     9c6:	0f 5f       	subi	r16, 0xFF	; 255
     9c8:	1f 4f       	sbci	r17, 0xFF	; 255
					{
						
						pChVariable++; // seuraava kirjain
						if(*pChVariable == 0)
     9ca:	f8 01       	movw	r30, r16
     9cc:	81 81       	ldd	r24, Z+1	; 0x01
     9ce:	81 11       	cpse	r24, r1
						lcd_putc('.');
     9d0:	02 c0       	rjmp	.+4      	; 0x9d6 <vLcdHandler+0x1b4>
     9d2:	8e e2       	ldi	r24, 0x2E	; 46
     9d4:	62 d4       	rcall	.+2244   	; 0x129a <lcd_putc>
						
						pChVariable--;
						
						lcd_putc(*pChVariable); // tulosta muuttuja
     9d6:	d8 01       	movw	r26, r16
     9d8:	8c 91       	ld	r24, X
     9da:	5f d4       	rcall	.+2238   	; 0x129a <lcd_putc>
     9dc:	f8 01       	movw	r30, r16
						while(xSerialPutChar(&xSerialPort, *pChVariable)==pdFAIL);//lähetetään merkit sarjaliikenneportin kautta
     9de:	60 81       	ld	r22, Z
     9e0:	86 e5       	ldi	r24, 0x56	; 86
     9e2:	96 e1       	ldi	r25, 0x16	; 22
     9e4:	0e 94 ac 1b 	call	0x3758	; 0x3758 <xSerialPutChar>
     9e8:	88 23       	and	r24, r24
     9ea:	c1 f3       	breq	.-16     	; 0x9dc <vLcdHandler+0x1ba>
     9ec:	0f 5f       	subi	r16, 0xFF	; 255
						pChVariable++;	//seuraava merkki
     9ee:	1f 4f       	sbci	r17, 0xFF	; 255
     9f0:	d8 01       	movw	r26, r16
				}
				if(!skip)
				{
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     9f2:	8c 91       	ld	r24, X
     9f4:	81 11       	cpse	r24, r1
     9f6:	e9 cf       	rjmp	.-46     	; 0x9ca <vLcdHandler+0x1a8>
     9f8:	ad 2c       	mov	r10, r13
     9fa:	0e c0       	rjmp	.+28     	; 0xa18 <vLcdHandler+0x1f6>
						while(xSerialPutChar(&xSerialPort, *pChVariable)==pdFAIL);//lähetetään merkit sarjaliikenneportin kautta
						pChVariable++;	//seuraava merkki
					}
				}
			}
			else if( *pChDisplay == '\n')
     9fc:	f8 01       	movw	r30, r16
     9fe:	80 81       	ld	r24, Z
     a00:	8a 30       	cpi	r24, 0x0A	; 10
			{
				lcd_gotoxy(0,1); // 2nd line
     a02:	29 f4       	brne	.+10     	; 0xa0e <vLcdHandler+0x1ec>
     a04:	6b 2d       	mov	r22, r11
     a06:	8d 2d       	mov	r24, r13
     a08:	2b d4       	rcall	.+2134   	; 0x1260 <lcd_gotoxy>
     a0a:	78 01       	movw	r14, r16
     a0c:	05 c0       	rjmp	.+10     	; 0xa18 <vLcdHandler+0x1f6>
			}
			else
			// näytön pohjateksti
			lcd_putc(*pChDisplay); // merkki näkyviin
     a0e:	80 81       	ld	r24, Z
     a10:	44 d4       	rcall	.+2184   	; 0x129a <lcd_putc>
     a12:	78 01       	movw	r14, r16
     a14:	01 c0       	rjmp	.+2      	; 0xa18 <vLcdHandler+0x1f6>
     a16:	ad 2c       	mov	r10, r13
				}
				if(!skip)
				{
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     a18:	87 01       	movw	r16, r14
				lcd_gotoxy(0,1); // 2nd line
			}
			else
			// näytön pohjateksti
			lcd_putc(*pChDisplay); // merkki näkyviin
			pChDisplay++; // seuraava kirjain
     a1a:	0f 5f       	subi	r16, 0xFF	; 255
     a1c:	1f 4f       	sbci	r17, 0xFF	; 255
     a1e:	f7 01       	movw	r30, r14
		xSemaphoreTake(xPortB, portMAX_DELAY);
		
		lcd_gotoxy(0, 0);	// lcd-näytön alkuun
		
		// tulostetaan näyttö tässä silmukassa
		while(*pChDisplay != 0)
     a20:	81 81       	ldd	r24, Z+1	; 0x01
     a22:	81 11       	cpse	r24, r1
     a24:	74 cf       	rjmp	.-280    	; 0x90e <vLcdHandler+0xec>
     a26:	60 e0       	ldi	r22, 0x00	; 0
			else
			// näytön pohjateksti
			lcd_putc(*pChDisplay); // merkki näkyviin
			pChDisplay++; // seuraava kirjain
		}
		xSemaphoreGive(xPortB);
     a28:	70 e0       	ldi	r23, 0x00	; 0
     a2a:	80 91 c9 03 	lds	r24, 0x03C9	; 0x8003c9 <xPortB>
     a2e:	90 91 ca 03 	lds	r25, 0x03CA	; 0x8003ca <xPortB+0x1>
     a32:	0e 94 ab 10 	call	0x2156	; 0x2156 <xQueueGive>
     a36:	1e cf       	rjmp	.-452    	; 0x874 <vLcdHandler+0x52>
	}
     a38:	ab 2c       	mov	r10, r11
				}
				if(!skip)
				{
					// tulostetaan muuttuja
					pChVariable = szVariable;
					while(*pChVariable != 0)
     a3a:	ee cf       	rjmp	.-36     	; 0xa18 <vLcdHandler+0x1f6>

00000a3c <SetTime>:
     a3c:	ef 92       	push	r14
//----------This function lets you set time--------
void SetTime(void)
{
     a3e:	ff 92       	push	r15
     a40:	0f 93       	push	r16
     a42:	1f 93       	push	r17
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
	unsigned int hour, min, sec;
	
	stopScreenTimer = true;
     a48:	81 e0       	ldi	r24, 0x01	; 1
     a4a:	80 93 e9 03 	sts	0x03E9, r24	; 0x8003e9 <stopScreenTimer>
	xSemaphoreTake( xPortC, portMAX_DELAY ); // take semaphore
     a4e:	20 e0       	ldi	r18, 0x00	; 0
     a50:	4f ef       	ldi	r20, 0xFF	; 255
     a52:	5f ef       	ldi	r21, 0xFF	; 255
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	70 e0       	ldi	r23, 0x00	; 0
     a58:	80 91 c7 03 	lds	r24, 0x03C7	; 0x8003c7 <xPortC>
     a5c:	90 91 c8 03 	lds	r25, 0x03C8	; 0x8003c8 <xPortC+0x1>
     a60:	0e 94 43 12 	call	0x2486	; 0x2486 <xQueueGenericReceive>
	
	hour = ReadKeyPadWithLCD("SET TIME\nHours? ",23);
     a64:	67 e1       	ldi	r22, 0x17	; 23
     a66:	70 e0       	ldi	r23, 0x00	; 0
     a68:	89 e6       	ldi	r24, 0x69	; 105
     a6a:	92 e0       	ldi	r25, 0x02	; 2
     a6c:	4d dd       	rcall	.-1382   	; 0x508 <ReadKeyPadWithLCD>
     a6e:	7c 01       	movw	r14, r24
	vTaskDelay(20);
     a70:	84 e1       	ldi	r24, 0x14	; 20
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	
	min = ReadKeyPadWithLCD("SET TIME\nMinutes? ",60);
     a78:	6c e3       	ldi	r22, 0x3C	; 60
     a7a:	70 e0       	ldi	r23, 0x00	; 0
     a7c:	8a e7       	ldi	r24, 0x7A	; 122
     a7e:	92 e0       	ldi	r25, 0x02	; 2
     a80:	43 dd       	rcall	.-1402   	; 0x508 <ReadKeyPadWithLCD>
     a82:	8c 01       	movw	r16, r24
	vTaskDelay(20);
     a84:	84 e1       	ldi	r24, 0x14	; 20
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	
	sec = ReadKeyPadWithLCD("SET TIME\nSeconds? ",60);
     a8c:	6c e3       	ldi	r22, 0x3C	; 60
     a8e:	70 e0       	ldi	r23, 0x00	; 0
     a90:	8d e8       	ldi	r24, 0x8D	; 141
     a92:	92 e0       	ldi	r25, 0x02	; 2
     a94:	39 dd       	rcall	.-1422   	; 0x508 <ReadKeyPadWithLCD>
     a96:	ec 01       	movw	r28, r24
	vTaskDelay(20);
     a98:	84 e1       	ldi	r24, 0x14	; 20
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	
	// set time
	secondsFromMidNight = hour*3600L + min*60L + sec;
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	9e e0       	ldi	r25, 0x0E	; 14
     aa4:	e8 9e       	mul	r14, r24
     aa6:	90 01       	movw	r18, r0
     aa8:	e9 9e       	mul	r14, r25
     aaa:	30 0d       	add	r19, r0
     aac:	f8 9e       	mul	r15, r24
     aae:	30 0d       	add	r19, r0
     ab0:	11 24       	eor	r1, r1
     ab2:	4c e3       	ldi	r20, 0x3C	; 60
     ab4:	40 9f       	mul	r20, r16
     ab6:	c0 01       	movw	r24, r0
     ab8:	41 9f       	mul	r20, r17
     aba:	90 0d       	add	r25, r0
     abc:	11 24       	eor	r1, r1
     abe:	82 0f       	add	r24, r18
     ac0:	93 1f       	adc	r25, r19
     ac2:	8c 0f       	add	r24, r28
     ac4:	9d 1f       	adc	r25, r29
     ac6:	90 93 ed 03 	sts	0x03ED, r25	; 0x8003ed <secondsFromMidNight+0x1>
     aca:	80 93 ec 03 	sts	0x03EC, r24	; 0x8003ec <secondsFromMidNight>
	intsTime[IDD_HOUR] = hour;
     ace:	ef ec       	ldi	r30, 0xCF	; 207
     ad0:	f3 e0       	ldi	r31, 0x03	; 3
     ad2:	f1 82       	std	Z+1, r15	; 0x01
     ad4:	e0 82       	st	Z, r14
	intsTime[IDD_MIN] = min;
     ad6:	13 83       	std	Z+3, r17	; 0x03
     ad8:	02 83       	std	Z+2, r16	; 0x02
	intsTime[IDD_SEC] = sec;
     ada:	d5 83       	std	Z+5, r29	; 0x05
     adc:	c4 83       	std	Z+4, r28	; 0x04
	vTaskDelay(20); // wait 1 second
     ade:	84 e1       	ldi	r24, 0x14	; 20
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	
	stopScreenTimer = false;
     ae6:	10 92 e9 03 	sts	0x03E9, r1	; 0x8003e9 <stopScreenTimer>
	xSemaphoreGive( xPortC ); // give semaphore
     aea:	60 e0       	ldi	r22, 0x00	; 0
     aec:	70 e0       	ldi	r23, 0x00	; 0
     aee:	80 91 c7 03 	lds	r24, 0x03C7	; 0x8003c7 <xPortC>
     af2:	90 91 c8 03 	lds	r25, 0x03C8	; 0x8003c8 <xPortC+0x1>
     af6:	0e 94 ab 10 	call	0x2156	; 0x2156 <xQueueGive>
}
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	ff 90       	pop	r15
     b04:	ef 90       	pop	r14
     b06:	08 95       	ret

00000b08 <DaysInMonth>:
}

int DaysInMonth(int month, int year)
{
	int days = 0;
	int mNumber = month - 1;
     b08:	01 97       	sbiw	r24, 0x01	; 1
	
	if(mNumber == eApril || mNumber == eJune || mNumber == eSeptember || mNumber == eNovember)
     b0a:	83 30       	cpi	r24, 0x03	; 3
     b0c:	91 05       	cpc	r25, r1
     b0e:	89 f0       	breq	.+34     	; 0xb32 <DaysInMonth+0x2a>
     b10:	85 30       	cpi	r24, 0x05	; 5
     b12:	91 05       	cpc	r25, r1
     b14:	89 f0       	breq	.+34     	; 0xb38 <DaysInMonth+0x30>
     b16:	9c 01       	movw	r18, r24
     b18:	2d 7f       	andi	r18, 0xFD	; 253
     b1a:	28 30       	cpi	r18, 0x08	; 8
     b1c:	31 05       	cpc	r19, r1
     b1e:	79 f0       	breq	.+30     	; 0xb3e <DaysInMonth+0x36>
	days = 30;
	
	else if(mNumber == eFebruary)
     b20:	01 97       	sbiw	r24, 0x01	; 1
     b22:	81 f4       	brne	.+32     	; 0xb44 <DaysInMonth+0x3c>
	{
		if(!(year % 4))
     b24:	63 70       	andi	r22, 0x03	; 3
     b26:	77 27       	eor	r23, r23
     b28:	67 2b       	or	r22, r23
     b2a:	79 f0       	breq	.+30     	; 0xb4a <DaysInMonth+0x42>
		days = 29;
		
		else
		days = 28;
     b2c:	8c e1       	ldi	r24, 0x1C	; 28
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	08 95       	ret
{
	int days = 0;
	int mNumber = month - 1;
	
	if(mNumber == eApril || mNumber == eJune || mNumber == eSeptember || mNumber == eNovember)
	days = 30;
     b32:	8e e1       	ldi	r24, 0x1E	; 30
     b34:	90 e0       	ldi	r25, 0x00	; 0
     b36:	08 95       	ret
     b38:	8e e1       	ldi	r24, 0x1E	; 30
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	08 95       	ret
     b3e:	8e e1       	ldi	r24, 0x1E	; 30
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	08 95       	ret
		else
		days = 28;
		
	}
	else
	days = 31;
     b44:	8f e1       	ldi	r24, 0x1F	; 31
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	08 95       	ret
	days = 30;
	
	else if(mNumber == eFebruary)
	{
		if(!(year % 4))
		days = 29;
     b4a:	8d e1       	ldi	r24, 0x1D	; 29
     b4c:	90 e0       	ldi	r25, 0x00	; 0
	else
	days = 31;
	
	return days;
	
}
     b4e:	08 95       	ret

00000b50 <SetDate>:
	stopScreenTimer = false;
	xSemaphoreGive( xPortC ); // give semaphore
}

void SetDate(void)
{
     b50:	ef 92       	push	r14
     b52:	ff 92       	push	r15
     b54:	0f 93       	push	r16
     b56:	1f 93       	push	r17
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
	unsigned int day, month, year;
	
	stopScreenTimer = true;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
     b5e:	80 93 e9 03 	sts	0x03E9, r24	; 0x8003e9 <stopScreenTimer>
	xSemaphoreTake( xPortC, portMAX_DELAY ); // take semaphore
     b62:	20 e0       	ldi	r18, 0x00	; 0
     b64:	4f ef       	ldi	r20, 0xFF	; 255
     b66:	5f ef       	ldi	r21, 0xFF	; 255
     b68:	60 e0       	ldi	r22, 0x00	; 0
     b6a:	70 e0       	ldi	r23, 0x00	; 0
     b6c:	80 91 c7 03 	lds	r24, 0x03C7	; 0x8003c7 <xPortC>
     b70:	90 91 c8 03 	lds	r25, 0x03C8	; 0x8003c8 <xPortC+0x1>
     b74:	0e 94 43 12 	call	0x2486	; 0x2486 <xQueueGenericReceive>
	
	year = ReadKeyPadWithLCD("SET DATE\nYear?   2000", 99);
     b78:	63 e6       	ldi	r22, 0x63	; 99
     b7a:	70 e0       	ldi	r23, 0x00	; 0
     b7c:	80 ea       	ldi	r24, 0xA0	; 160
     b7e:	92 e0       	ldi	r25, 0x02	; 2
     b80:	c3 dc       	rcall	.-1658   	; 0x508 <ReadKeyPadWithLCD>
     b82:	8c 01       	movw	r16, r24
	vTaskDelay(20);
     b84:	84 e1       	ldi	r24, 0x14	; 20
     b86:	90 e0       	ldi	r25, 0x00	; 0
     b88:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	
	month = ReadKeyPadWithLCD("SET DATE\nMonth? ", 12);
     b8c:	6c e0       	ldi	r22, 0x0C	; 12
     b8e:	70 e0       	ldi	r23, 0x00	; 0
     b90:	86 eb       	ldi	r24, 0xB6	; 182
     b92:	92 e0       	ldi	r25, 0x02	; 2
     b94:	b9 dc       	rcall	.-1678   	; 0x508 <ReadKeyPadWithLCD>
     b96:	ec 01       	movw	r28, r24
	if(month == 0)
     b98:	89 2b       	or	r24, r25
     b9a:	11 f4       	brne	.+4      	; 0xba0 <SetDate+0x50>
	month = 1;
     b9c:	c1 e0       	ldi	r28, 0x01	; 1
     b9e:	d0 e0       	ldi	r29, 0x00	; 0
	vTaskDelay(20);
     ba0:	84 e1       	ldi	r24, 0x14	; 20
     ba2:	90 e0       	ldi	r25, 0x00	; 0
     ba4:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	
	day = ReadKeyPadWithLCD("SET DATE\nDay? ", DaysInMonth(month, year));
     ba8:	ec 2e       	mov	r14, r28
     baa:	fd 2e       	mov	r15, r29
     bac:	b8 01       	movw	r22, r16
     bae:	ce 01       	movw	r24, r28
     bb0:	ab df       	rcall	.-170    	; 0xb08 <DaysInMonth>
     bb2:	bc 01       	movw	r22, r24
     bb4:	87 ec       	ldi	r24, 0xC7	; 199
     bb6:	92 e0       	ldi	r25, 0x02	; 2
     bb8:	a7 dc       	rcall	.-1714   	; 0x508 <ReadKeyPadWithLCD>
     bba:	ec 01       	movw	r28, r24
	if(day == 0)
     bbc:	89 2b       	or	r24, r25
     bbe:	11 f4       	brne	.+4      	; 0xbc4 <SetDate+0x74>
	day = 1;
     bc0:	c1 e0       	ldi	r28, 0x01	; 1
     bc2:	d0 e0       	ldi	r29, 0x00	; 0
	vTaskDelay(20);
     bc4:	84 e1       	ldi	r24, 0x14	; 20
     bc6:	90 e0       	ldi	r25, 0x00	; 0
     bc8:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	
	// set date
	intsTime[IDD_DAY] = day;
     bcc:	ef ec       	ldi	r30, 0xCF	; 207
     bce:	f3 e0       	ldi	r31, 0x03	; 3
     bd0:	d7 83       	std	Z+7, r29	; 0x07
     bd2:	c6 83       	std	Z+6, r28	; 0x06
	intsTime[IDD_MONTH] = month;
     bd4:	e0 86       	std	Z+8, r14	; 0x08
     bd6:	f1 86       	std	Z+9, r15	; 0x09
	intsTime[IDD_YEAR] = year;
     bd8:	13 87       	std	Z+11, r17	; 0x0b
     bda:	02 87       	std	Z+10, r16	; 0x0a
	vTaskDelay(20); // wait 1 second
     bdc:	84 e1       	ldi	r24, 0x14	; 20
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
	
	stopScreenTimer = false;
     be4:	10 92 e9 03 	sts	0x03E9, r1	; 0x8003e9 <stopScreenTimer>
	xSemaphoreGive( xPortC ); // give semaphore
     be8:	60 e0       	ldi	r22, 0x00	; 0
     bea:	70 e0       	ldi	r23, 0x00	; 0
     bec:	80 91 c7 03 	lds	r24, 0x03C7	; 0x8003c7 <xPortC>
     bf0:	90 91 c8 03 	lds	r25, 0x03C8	; 0x8003c8 <xPortC+0x1>
     bf4:	0e 94 ab 10 	call	0x2156	; 0x2156 <xQueueGive>
}
     bf8:	df 91       	pop	r29
     bfa:	cf 91       	pop	r28
     bfc:	1f 91       	pop	r17
     bfe:	0f 91       	pop	r16
     c00:	ff 90       	pop	r15
     c02:	ef 90       	pop	r14
     c04:	08 95       	ret

00000c06 <vKeyPadHandler>:
{
	static unsigned char ch = 0;
	const TickType_t xDelay = 500 / portTICK_PERIOD_MS;	// 0.5sec wait
	static DISPLAY_MESSAGE message;
	
	message.data = 0;
     c06:	10 92 c1 03 	sts	0x03C1, r1	; 0x8003c1 <message.3082+0x1>
			//--------------------------------------------------------
			case IDK_RIGHT: case IDK_LEFT:
			
			if(lastScreen != IDM_SET_TIME && lastScreen != IDM_TIME_DATE)
			{
				message.idMessage = IDM_AVERAGE;	//keskiarvo
     c0a:	c0 ec       	ldi	r28, 0xC0	; 192
     c0c:	d3 e0       	ldi	r29, 0x03	; 3
     c0e:	0f 2e       	mov	r0, r31
     c10:	f3 e0       	ldi	r31, 0x03	; 3
     c12:	ff 2e       	mov	r15, r31
     c14:	f0 2d       	mov	r31, r0
		screenTimer = 0;

		switch( ch )
		{
			case IDK_SELECT: // näppäinten käyttö
			message.idMessage = IDM_TIME_DATE; // viestin id
     c16:	14 e0       	ldi	r17, 0x04	; 4
					vTaskDelay(20);
					message.idMessage = IDM_MAIN_SCREEN;
				}
			}
			else if (lastScreen != IDM_SET_TIME && lastScreen != IDM_TIME_DATE)
			message.idMessage = IDM_MINMAX;
     c18:	02 e0       	ldi	r16, 0x02	; 2
				// jos painettu down aloita aseta päivä
				else if (ch == IDK_DOWN)
				{
					SetDate();
					vTaskDelay(20);
					message.idMessage = IDM_MAIN_SCREEN;
     c1a:	0f 2e       	mov	r0, r31
     c1c:	f5 e0       	ldi	r31, 0x05	; 5
     c1e:	ef 2e       	mov	r14, r31
     c20:	f0 2d       	mov	r31, r0


	for( ;; )
	{
		// odota
		vTaskDelay(xDelay);
     c22:	84 e6       	ldi	r24, 0x64	; 100
     c24:	90 e0       	ldi	r25, 0x00	; 0
     c26:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
		
		do
		{
			xSemaphoreTake( xPortC, portMAX_DELAY);
     c2a:	20 e0       	ldi	r18, 0x00	; 0
     c2c:	4f ef       	ldi	r20, 0xFF	; 255
     c2e:	5f ef       	ldi	r21, 0xFF	; 255
     c30:	60 e0       	ldi	r22, 0x00	; 0
     c32:	70 e0       	ldi	r23, 0x00	; 0
     c34:	80 91 c7 03 	lds	r24, 0x03C7	; 0x8003c7 <xPortC>
     c38:	90 91 c8 03 	lds	r25, 0x03C8	; 0x8003c8 <xPortC+0x1>
     c3c:	0e 94 43 12 	call	0x2486	; 0x2486 <xQueueGenericReceive>
			ch =GetKey();vTaskDelay(1);
     c40:	3e d2       	rcall	.+1148   	; 0x10be <GetKey>
     c42:	80 93 bf 03 	sts	0x03BF, r24	; 0x8003bf <ch.3080>
     c46:	81 e0       	ldi	r24, 0x01	; 1
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
			xSemaphoreGive( xPortC);
     c4e:	60 e0       	ldi	r22, 0x00	; 0
     c50:	70 e0       	ldi	r23, 0x00	; 0
     c52:	80 91 c7 03 	lds	r24, 0x03C7	; 0x8003c7 <xPortC>
     c56:	90 91 c8 03 	lds	r25, 0x03C8	; 0x8003c8 <xPortC+0x1>
     c5a:	0e 94 ab 10 	call	0x2156	; 0x2156 <xQueueGive>
			
		}while (ch == NO_KEY);
     c5e:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <ch.3080>
     c62:	83 36       	cpi	r24, 0x63	; 99
     c64:	11 f3       	breq	.-60     	; 0xc2a <vKeyPadHandler+0x24>
		
		// nollaa näyttöaika
		screenTimer = 0;
     c66:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     c6a:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <__DATA_REGION_ORIGIN__>

		switch( ch )
     c6e:	84 30       	cpi	r24, 0x04	; 4
     c70:	28 f4       	brcc	.+10     	; 0xc7c <vKeyPadHandler+0x76>
     c72:	82 30       	cpi	r24, 0x02	; 2
     c74:	98 f4       	brcc	.+38     	; 0xc9c <vKeyPadHandler+0x96>
     c76:	81 30       	cpi	r24, 0x01	; 1
     c78:	c9 f1       	breq	.+114    	; 0xcec <vKeyPadHandler+0xe6>
     c7a:	d3 cf       	rjmp	.-90     	; 0xc22 <vKeyPadHandler+0x1c>
     c7c:	84 30       	cpi	r24, 0x04	; 4
     c7e:	b1 f1       	breq	.+108    	; 0xcec <vKeyPadHandler+0xe6>
     c80:	85 30       	cpi	r24, 0x05	; 5
     c82:	79 f6       	brne	.-98     	; 0xc22 <vKeyPadHandler+0x1c>
		{
			case IDK_SELECT: // näppäinten käyttö
			message.idMessage = IDM_TIME_DATE; // viestin id
     c84:	18 83       	st	Y, r17
			xQueueSend( xDisplay, (void*)&message,0); // lähetä viesti näytölle
     c86:	20 e0       	ldi	r18, 0x00	; 0
     c88:	40 e0       	ldi	r20, 0x00	; 0
     c8a:	50 e0       	ldi	r21, 0x00	; 0
     c8c:	be 01       	movw	r22, r28
     c8e:	80 91 cd 03 	lds	r24, 0x03CD	; 0x8003cd <xDisplay>
     c92:	90 91 ce 03 	lds	r25, 0x03CE	; 0x8003ce <xDisplay+0x1>
     c96:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xQueueGenericSend>
			break;
     c9a:	c3 cf       	rjmp	.-122    	; 0xc22 <vKeyPadHandler+0x1c>
			//--------------------------------------------------------
			case IDK_DOWN: case IDK_UP:
			//jos näyttö on "set time or date"
			if (lastScreen == IDM_TIME_DATE)
     c9c:	20 91 ea 03 	lds	r18, 0x03EA	; 0x8003ea <lastScreen>
     ca0:	30 91 eb 03 	lds	r19, 0x03EB	; 0x8003eb <lastScreen+0x1>
     ca4:	24 30       	cpi	r18, 0x04	; 4
     ca6:	31 05       	cpc	r19, r1
     ca8:	91 f4       	brne	.+36     	; 0xcce <vKeyPadHandler+0xc8>
			{
				// jos valittu up aloita aseta aika
				if (ch == IDK_UP)
     caa:	82 30       	cpi	r24, 0x02	; 2
				{
					SetTime();
     cac:	39 f4       	brne	.+14     	; 0xcbc <vKeyPadHandler+0xb6>
     cae:	c6 de       	rcall	.-628    	; 0xa3c <SetTime>
					vTaskDelay(20);
     cb0:	84 e1       	ldi	r24, 0x14	; 20
     cb2:	90 e0       	ldi	r25, 0x00	; 0
     cb4:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
					message.idMessage = IDM_MAIN_SCREEN;
     cb8:	e8 82       	st	Y, r14
     cba:	0d c0       	rjmp	.+26     	; 0xcd6 <vKeyPadHandler+0xd0>
				}
				// jos painettu down aloita aseta päivä
				else if (ch == IDK_DOWN)
     cbc:	83 30       	cpi	r24, 0x03	; 3
				{
					SetDate();
     cbe:	59 f4       	brne	.+22     	; 0xcd6 <vKeyPadHandler+0xd0>
     cc0:	47 df       	rcall	.-370    	; 0xb50 <SetDate>
					vTaskDelay(20);
     cc2:	84 e1       	ldi	r24, 0x14	; 20
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	0e 94 df 14 	call	0x29be	; 0x29be <vTaskDelay>
					message.idMessage = IDM_MAIN_SCREEN;
     cca:	e8 82       	st	Y, r14
     ccc:	04 c0       	rjmp	.+8      	; 0xcd6 <vKeyPadHandler+0xd0>
				}
			}
			else if (lastScreen != IDM_SET_TIME && lastScreen != IDM_TIME_DATE)
     cce:	21 30       	cpi	r18, 0x01	; 1
     cd0:	31 05       	cpc	r19, r1
     cd2:	09 f0       	breq	.+2      	; 0xcd6 <vKeyPadHandler+0xd0>
			message.idMessage = IDM_MINMAX;
     cd4:	08 83       	st	Y, r16
			
			xQueueSend( xDisplay, (void*)&message,0); // lähetä viesti näytölle
     cd6:	20 e0       	ldi	r18, 0x00	; 0
     cd8:	40 e0       	ldi	r20, 0x00	; 0
     cda:	50 e0       	ldi	r21, 0x00	; 0
     cdc:	be 01       	movw	r22, r28
     cde:	80 91 cd 03 	lds	r24, 0x03CD	; 0x8003cd <xDisplay>
     ce2:	90 91 ce 03 	lds	r25, 0x03CE	; 0x8003ce <xDisplay+0x1>
     ce6:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xQueueGenericSend>
			break;
     cea:	9b cf       	rjmp	.-202    	; 0xc22 <vKeyPadHandler+0x1c>
			//--------------------------------------------------------
			case IDK_RIGHT: case IDK_LEFT:
			
			if(lastScreen != IDM_SET_TIME && lastScreen != IDM_TIME_DATE)
     cec:	80 91 ea 03 	lds	r24, 0x03EA	; 0x8003ea <lastScreen>
     cf0:	90 91 eb 03 	lds	r25, 0x03EB	; 0x8003eb <lastScreen+0x1>
     cf4:	81 30       	cpi	r24, 0x01	; 1
     cf6:	91 05       	cpc	r25, r1
     cf8:	09 f4       	brne	.+2      	; 0xcfc <vKeyPadHandler+0xf6>
     cfa:	93 cf       	rjmp	.-218    	; 0xc22 <vKeyPadHandler+0x1c>
     cfc:	04 97       	sbiw	r24, 0x04	; 4
     cfe:	09 f4       	brne	.+2      	; 0xd02 <vKeyPadHandler+0xfc>
     d00:	90 cf       	rjmp	.-224    	; 0xc22 <vKeyPadHandler+0x1c>
			{
				message.idMessage = IDM_AVERAGE;	//keskiarvo
     d02:	f8 82       	st	Y, r15
				xQueueSend( xDisplay, (void*)&message,0);
     d04:	20 e0       	ldi	r18, 0x00	; 0
     d06:	40 e0       	ldi	r20, 0x00	; 0
     d08:	50 e0       	ldi	r21, 0x00	; 0
     d0a:	be 01       	movw	r22, r28
     d0c:	80 91 cd 03 	lds	r24, 0x03CD	; 0x8003cd <xDisplay>
     d10:	90 91 ce 03 	lds	r25, 0x03CE	; 0x8003ce <xDisplay+0x1>
     d14:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xQueueGenericSend>
     d18:	84 cf       	rjmp	.-248    	; 0xc22 <vKeyPadHandler+0x1c>

00000d1a <StartTimer>:
}

void StartTimer( int ticks)
{
	// 0 = stop  1 = clock  2 = clock/8 3 = clock/64  4 = clock/256 5 = clock/1024
	TCCR0B = (1<<FOC0A) | ( 1<<CS02) | (1<<CS00); // processor clock/1024   , if 16MHz => 64 us
     d1a:	95 e8       	ldi	r25, 0x85	; 133
     d1c:	95 bd       	out	0x25, r25	; 37
	TIMSK0 |= (1 << OCIE0A); // reference interrupt
     d1e:	ee e6       	ldi	r30, 0x6E	; 110
     d20:	f0 e0       	ldi	r31, 0x00	; 0
     d22:	90 81       	ld	r25, Z
     d24:	92 60       	ori	r25, 0x02	; 2
     d26:	90 83       	st	Z, r25
	OCR0A = ticks; // given number as a reference
     d28:	87 bd       	out	0x27, r24	; 39
	TCNT0 = 0;    // to start of the counter
     d2a:	16 bc       	out	0x26, r1	; 38
     d2c:	08 95       	ret

00000d2e <vClock>:

static void vClock( void *pvParameters )
{
	( void ) pvParameters; // Just to stop compiler warnings.
	
	vSemaphoreCreateBinary( xClock );// luodaan semafori
     d2e:	43 e0       	ldi	r20, 0x03	; 3
     d30:	60 e0       	ldi	r22, 0x00	; 0
     d32:	81 e0       	ldi	r24, 0x01	; 1
     d34:	f6 d7       	rcall	.+4076   	; 0x1d22 <xQueueGenericCreate>
     d36:	90 93 cc 03 	sts	0x03CC, r25	; 0x8003cc <xClock+0x1>
     d3a:	80 93 cb 03 	sts	0x03CB, r24	; 0x8003cb <xClock>
     d3e:	00 97       	sbiw	r24, 0x00	; 0
     d40:	21 f0       	breq	.+8      	; 0xd4a <vClock+0x1c>
     d42:	60 e0       	ldi	r22, 0x00	; 0
     d44:	70 e0       	ldi	r23, 0x00	; 0
     d46:	0e 94 ab 10 	call	0x2156	; 0x2156 <xQueueGive>
	static DISPLAY_MESSAGE message;
	
	StartTimer(125); // = 8 msekunnin välein keskeytys 8*125 = 1000ms = 1s
     d4a:	8d e7       	ldi	r24, 0x7D	; 125
     d4c:	90 e0       	ldi	r25, 0x00	; 0
     d4e:	e5 df       	rcall	.-54     	; 0xd1a <StartTimer>
	
	// esiasetettu päivä
	intsTime[IDD_DAY] = 25;
     d50:	ef ec       	ldi	r30, 0xCF	; 207
     d52:	f3 e0       	ldi	r31, 0x03	; 3
     d54:	89 e1       	ldi	r24, 0x19	; 25
     d56:	90 e0       	ldi	r25, 0x00	; 0
     d58:	97 83       	std	Z+7, r25	; 0x07
     d5a:	86 83       	std	Z+6, r24	; 0x06
	intsTime[IDD_MONTH] = 1;
     d5c:	81 e0       	ldi	r24, 0x01	; 1
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	91 87       	std	Z+9, r25	; 0x09
     d62:	80 87       	std	Z+8, r24	; 0x08
	intsTime[IDD_YEAR] = 2021;
     d64:	85 ee       	ldi	r24, 0xE5	; 229
     d66:	97 e0       	ldi	r25, 0x07	; 7
     d68:	93 87       	std	Z+11, r25	; 0x0b
     d6a:	82 87       	std	Z+10, r24	; 0x0a
	
	message.data = 0;
     d6c:	e2 ec       	ldi	r30, 0xC2	; 194
     d6e:	f3 e0       	ldi	r31, 0x03	; 3
     d70:	11 82       	std	Z+1, r1	; 0x01
	message.idMessage = IDM_MAIN_SCREEN;
     d72:	85 e0       	ldi	r24, 0x05	; 5
     d74:	80 83       	st	Z, r24
	for( ;; )
	{
		xSemaphoreTake( xClock, portMAX_DELAY ); // odotetaan tietoa keskeytyksestä

		taskENTER_CRITICAL(); /////////////////////////////////////////
		intsTime[ IDD_HOUR ]   =  secondsFromMidNight / 3600L;         ////
     d76:	cf ec       	ldi	r28, 0xCF	; 207
     d78:	d3 e0       	ldi	r29, 0x03	; 3
     d7a:	0f 2e       	mov	r0, r31
     d7c:	f0 e1       	ldi	r31, 0x10	; 16
     d7e:	cf 2e       	mov	r12, r31
     d80:	fe e0       	ldi	r31, 0x0E	; 14
     d82:	df 2e       	mov	r13, r31
     d84:	f0 2d       	mov	r31, r0
		intsTime[ IDD_MIN ] = (secondsFromMidNight % 3600L) / 60L ; ////
		intsTime[ IDD_SEC ] =  secondsFromMidNight % 60L;           ////
     d86:	0f 2e       	mov	r0, r31
     d88:	fc e3       	ldi	r31, 0x3C	; 60
     d8a:	bf 2e       	mov	r11, r31
     d8c:	f0 2d       	mov	r31, r0
		}
		
		// jos kuukausi on vaihtunut
		if(intsTime[IDD_DAY] > DaysInMonth(intsTime[IDD_MONTH], intsTime[IDD_MONTH]))
		{
			intsTime[IDD_DAY] = 1;
     d8e:	ee 24       	eor	r14, r14
     d90:	e3 94       	inc	r14
     d92:	f1 2c       	mov	r15, r1
	message.data = 0;
	message.idMessage = IDM_MAIN_SCREEN;
	
	for( ;; )
	{
		xSemaphoreTake( xClock, portMAX_DELAY ); // odotetaan tietoa keskeytyksestä
     d94:	20 e0       	ldi	r18, 0x00	; 0
     d96:	4f ef       	ldi	r20, 0xFF	; 255
     d98:	5f ef       	ldi	r21, 0xFF	; 255
     d9a:	60 e0       	ldi	r22, 0x00	; 0
     d9c:	70 e0       	ldi	r23, 0x00	; 0
     d9e:	80 91 cb 03 	lds	r24, 0x03CB	; 0x8003cb <xClock>
     da2:	90 91 cc 03 	lds	r25, 0x03CC	; 0x8003cc <xClock+0x1>
     da6:	0e 94 43 12 	call	0x2486	; 0x2486 <xQueueGenericReceive>

		taskENTER_CRITICAL(); /////////////////////////////////////////
     daa:	0f b6       	in	r0, 0x3f	; 63
     dac:	f8 94       	cli
     dae:	0f 92       	push	r0
		intsTime[ IDD_HOUR ]   =  secondsFromMidNight / 3600L;         ////
     db0:	e0 91 ec 03 	lds	r30, 0x03EC	; 0x8003ec <secondsFromMidNight>
     db4:	f0 91 ed 03 	lds	r31, 0x03ED	; 0x8003ed <secondsFromMidNight+0x1>
     db8:	cf 01       	movw	r24, r30
     dba:	b6 01       	movw	r22, r12
     dbc:	0e 94 ab 21 	call	0x4356	; 0x4356 <__udivmodhi4>
     dc0:	79 83       	std	Y+1, r23	; 0x01
     dc2:	68 83       	st	Y, r22
		intsTime[ IDD_MIN ] = (secondsFromMidNight % 3600L) / 60L ; ////
     dc4:	9c 01       	movw	r18, r24
     dc6:	a9 e8       	ldi	r26, 0x89	; 137
     dc8:	b8 e8       	ldi	r27, 0x88	; 136
     dca:	0e 94 18 22 	call	0x4430	; 0x4430 <__umulhisi3>
     dce:	96 95       	lsr	r25
     dd0:	87 95       	ror	r24
     dd2:	92 95       	swap	r25
     dd4:	82 95       	swap	r24
     dd6:	8f 70       	andi	r24, 0x0F	; 15
     dd8:	89 27       	eor	r24, r25
     dda:	9f 70       	andi	r25, 0x0F	; 15
     ddc:	89 27       	eor	r24, r25
     dde:	9b 83       	std	Y+3, r25	; 0x03
     de0:	8a 83       	std	Y+2, r24	; 0x02
		intsTime[ IDD_SEC ] =  secondsFromMidNight % 60L;           ////
     de2:	9f 01       	movw	r18, r30
     de4:	0e 94 18 22 	call	0x4430	; 0x4430 <__umulhisi3>
     de8:	96 95       	lsr	r25
     dea:	87 95       	ror	r24
     dec:	92 95       	swap	r25
     dee:	82 95       	swap	r24
     df0:	8f 70       	andi	r24, 0x0F	; 15
     df2:	89 27       	eor	r24, r25
     df4:	9f 70       	andi	r25, 0x0F	; 15
     df6:	89 27       	eor	r24, r25
     df8:	b8 9e       	mul	r11, r24
     dfa:	90 01       	movw	r18, r0
     dfc:	b9 9e       	mul	r11, r25
     dfe:	30 0d       	add	r19, r0
     e00:	11 24       	eor	r1, r1
     e02:	e2 1b       	sub	r30, r18
     e04:	f3 0b       	sbc	r31, r19
     e06:	fd 83       	std	Y+5, r31	; 0x05
     e08:	ec 83       	std	Y+4, r30	; 0x04
		taskEXIT_CRITICAL(); //////////////////////////////////////////
     e0a:	0f 90       	pop	r0
     e0c:	0f be       	out	0x3f, r0	; 63
			secondsFromMidNight = 0;
			intsTime[IDD_DAY]++;
		}
		
		// jos kuukausi on vaihtunut
		if(intsTime[IDD_DAY] > DaysInMonth(intsTime[IDD_MONTH], intsTime[IDD_MONTH]))
     e0e:	8e 80       	ldd	r8, Y+6	; 0x06
     e10:	9f 80       	ldd	r9, Y+7	; 0x07
     e12:	08 85       	ldd	r16, Y+8	; 0x08
     e14:	19 85       	ldd	r17, Y+9	; 0x09
     e16:	b8 01       	movw	r22, r16
     e18:	c8 01       	movw	r24, r16
     e1a:	76 de       	rcall	.-788    	; 0xb08 <DaysInMonth>
     e1c:	88 15       	cp	r24, r8
     e1e:	99 05       	cpc	r25, r9
     e20:	34 f4       	brge	.+12     	; 0xe2e <vClock+0x100>
		{
			intsTime[IDD_DAY] = 1;
     e22:	ff 82       	std	Y+7, r15	; 0x07
     e24:	ee 82       	std	Y+6, r14	; 0x06
			intsTime[IDD_MONTH]++;
     e26:	0f 5f       	subi	r16, 0xFF	; 255
     e28:	1f 4f       	sbci	r17, 0xFF	; 255
     e2a:	19 87       	std	Y+9, r17	; 0x09
     e2c:	08 87       	std	Y+8, r16	; 0x08
		}
		
		// jos vuosi on vaihtunut
		if(intsTime[IDD_MONTH] > 12)
     e2e:	88 85       	ldd	r24, Y+8	; 0x08
     e30:	99 85       	ldd	r25, Y+9	; 0x09
     e32:	0d 97       	sbiw	r24, 0x0d	; 13
     e34:	3c f0       	brlt	.+14     	; 0xe44 <vClock+0x116>
		{
			intsTime[IDD_MONTH] = 1;
     e36:	f9 86       	std	Y+9, r15	; 0x09
     e38:	e8 86       	std	Y+8, r14	; 0x08
			intsTime[IDD_YEAR]++;
     e3a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e3c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e3e:	01 96       	adiw	r24, 0x01	; 1
     e40:	9b 87       	std	Y+11, r25	; 0x0b
     e42:	8a 87       	std	Y+10, r24	; 0x0a
		}
		
		// kolmen sekunnin palautus
		if(screenTimer >= waitTime)
     e44:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     e48:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     e4c:	03 97       	sbiw	r24, 0x03	; 3
     e4e:	50 f0       	brcs	.+20     	; 0xe64 <vClock+0x136>
		xQueueSend(xDisplay, (void*)&message, 0);
     e50:	20 e0       	ldi	r18, 0x00	; 0
     e52:	40 e0       	ldi	r20, 0x00	; 0
     e54:	50 e0       	ldi	r21, 0x00	; 0
     e56:	62 ec       	ldi	r22, 0xC2	; 194
     e58:	73 e0       	ldi	r23, 0x03	; 3
     e5a:	80 91 cd 03 	lds	r24, 0x03CD	; 0x8003cd <xDisplay>
     e5e:	90 91 ce 03 	lds	r25, 0x03CE	; 0x8003ce <xDisplay+0x1>
     e62:	ad d7       	rcall	.+3930   	; 0x1dbe <xQueueGenericSend>
		
		// jos ajastin ei ole pysähtynyt lisää ajastin
		if(!stopScreenTimer)
     e64:	80 91 e9 03 	lds	r24, 0x03E9	; 0x8003e9 <stopScreenTimer>
     e68:	81 11       	cpse	r24, r1
     e6a:	94 cf       	rjmp	.-216    	; 0xd94 <vClock+0x66>
		screenTimer++;
     e6c:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     e70:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     e74:	01 96       	adiw	r24, 0x01	; 1
     e76:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     e7a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     e7e:	8a cf       	rjmp	.-236    	; 0xd94 <vClock+0x66>

00000e80 <__vector_21>:
}

SIGNAL(TIMER0_COMPA_vect) {
     e80:	1f 92       	push	r1
     e82:	0f 92       	push	r0
     e84:	0f b6       	in	r0, 0x3f	; 63
     e86:	0f 92       	push	r0
     e88:	11 24       	eor	r1, r1
     e8a:	0b b6       	in	r0, 0x3b	; 59
     e8c:	0f 92       	push	r0
     e8e:	2f 93       	push	r18
     e90:	3f 93       	push	r19
     e92:	4f 93       	push	r20
     e94:	5f 93       	push	r21
     e96:	6f 93       	push	r22
     e98:	7f 93       	push	r23
     e9a:	8f 93       	push	r24
     e9c:	9f 93       	push	r25
     e9e:	af 93       	push	r26
     ea0:	bf 93       	push	r27
     ea2:	ef 93       	push	r30
     ea4:	ff 93       	push	r31
	static BaseType_t xTaskWoken = pdFALSE;
	static unsigned msCounter = 0;
	msCounter += 8 ; // interval 8ms
     ea6:	80 91 c5 03 	lds	r24, 0x03C5	; 0x8003c5 <msCounter.3033>
     eaa:	90 91 c6 03 	lds	r25, 0x03C6	; 0x8003c6 <msCounter.3033+0x1>
     eae:	08 96       	adiw	r24, 0x08	; 8
     eb0:	90 93 c6 03 	sts	0x03C6, r25	; 0x8003c6 <msCounter.3033+0x1>
     eb4:	80 93 c5 03 	sts	0x03C5, r24	; 0x8003c5 <msCounter.3033>
	TCNT0 = 0; // to start of the counter
     eb8:	16 bc       	out	0x26, r1	; 38
	//timer0 interrupt handler
	if ( msCounter == 1000)
     eba:	80 91 c5 03 	lds	r24, 0x03C5	; 0x8003c5 <msCounter.3033>
     ebe:	90 91 c6 03 	lds	r25, 0x03C6	; 0x8003c6 <msCounter.3033+0x1>
     ec2:	88 3e       	cpi	r24, 0xE8	; 232
     ec4:	93 40       	sbci	r25, 0x03	; 3
     ec6:	a9 f4       	brne	.+42     	; 0xef2 <__vector_21+0x72>
	{
		secondsFromMidNight++;
     ec8:	80 91 ec 03 	lds	r24, 0x03EC	; 0x8003ec <secondsFromMidNight>
     ecc:	90 91 ed 03 	lds	r25, 0x03ED	; 0x8003ed <secondsFromMidNight+0x1>
     ed0:	01 96       	adiw	r24, 0x01	; 1
     ed2:	90 93 ed 03 	sts	0x03ED, r25	; 0x8003ed <secondsFromMidNight+0x1>
     ed6:	80 93 ec 03 	sts	0x03EC, r24	; 0x8003ec <secondsFromMidNight>
		xSemaphoreGiveFromISR( xClock, &xTaskWoken ); // inform the change in time
     eda:	64 ec       	ldi	r22, 0xC4	; 196
     edc:	73 e0       	ldi	r23, 0x03	; 3
     ede:	80 91 cb 03 	lds	r24, 0x03CB	; 0x8003cb <xClock>
     ee2:	90 91 cc 03 	lds	r25, 0x03CC	; 0x8003cc <xClock+0x1>
     ee6:	0e 94 18 12 	call	0x2430	; 0x2430 <xQueueGiveFromISR>
		msCounter = 0;
     eea:	10 92 c6 03 	sts	0x03C6, r1	; 0x8003c6 <msCounter.3033+0x1>
     eee:	10 92 c5 03 	sts	0x03C5, r1	; 0x8003c5 <msCounter.3033>
	}
}
     ef2:	ff 91       	pop	r31
     ef4:	ef 91       	pop	r30
     ef6:	bf 91       	pop	r27
     ef8:	af 91       	pop	r26
     efa:	9f 91       	pop	r25
     efc:	8f 91       	pop	r24
     efe:	7f 91       	pop	r23
     f00:	6f 91       	pop	r22
     f02:	5f 91       	pop	r21
     f04:	4f 91       	pop	r20
     f06:	3f 91       	pop	r19
     f08:	2f 91       	pop	r18
     f0a:	0f 90       	pop	r0
     f0c:	0b be       	out	0x3b, r0	; 59
     f0e:	0f 90       	pop	r0
     f10:	0f be       	out	0x3f, r0	; 63
     f12:	0f 90       	pop	r0
     f14:	1f 90       	pop	r1
     f16:	18 95       	reti

00000f18 <main>:
#include "AppTask.h"			// taskien funktiot

//--------------------------------------------------------
// pÃ¤Ã¤ohjelma luo taskit ja kÃ¤ynnistÃ¤Ã¤ systeemin
int main( void )
{
     f18:	af 92       	push	r10
     f1a:	bf 92       	push	r11
     f1c:	cf 92       	push	r12
     f1e:	df 92       	push	r13
     f20:	ef 92       	push	r14
     f22:	ff 92       	push	r15
     f24:	0f 93       	push	r16
     f26:	1f 93       	push	r17
     f28:	cf 93       	push	r28
     f2a:	df 93       	push	r29
     f2c:	cd b7       	in	r28, 0x3d	; 61
     f2e:	de b7       	in	r29, 0x3e	; 62
     f30:	a2 97       	sbiw	r28, 0x22	; 34
     f32:	0f b6       	in	r0, 0x3f	; 63
     f34:	f8 94       	cli
     f36:	de bf       	out	0x3e, r29	; 62
     f38:	0f be       	out	0x3f, r0	; 63
     f3a:	cd bf       	out	0x3d, r28	; 61
	xDisplay = xQueueCreate( 2, sizeof(DISPLAY_MESSAGE));// luodaan postilaatikko nÃ¤yttÃ¶taskille
     f3c:	40 e0       	ldi	r20, 0x00	; 0
     f3e:	62 e0       	ldi	r22, 0x02	; 2
     f40:	82 e0       	ldi	r24, 0x02	; 2
     f42:	ef d6       	rcall	.+3550   	; 0x1d22 <xQueueGenericCreate>
     f44:	90 93 ce 03 	sts	0x03CE, r25	; 0x8003ce <xDisplay+0x1>
     f48:	80 93 cd 03 	sts	0x03CD, r24	; 0x8003cd <xDisplay>

	// luodaan semafori 
	vSemaphoreCreateBinary(xPortC);
     f4c:	43 e0       	ldi	r20, 0x03	; 3
     f4e:	60 e0       	ldi	r22, 0x00	; 0
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	e7 d6       	rcall	.+3534   	; 0x1d22 <xQueueGenericCreate>
     f54:	90 93 c8 03 	sts	0x03C8, r25	; 0x8003c8 <xPortC+0x1>
     f58:	80 93 c7 03 	sts	0x03C7, r24	; 0x8003c7 <xPortC>
     f5c:	00 97       	sbiw	r24, 0x00	; 0
     f5e:	21 f0       	breq	.+8      	; 0xf68 <main+0x50>
     f60:	60 e0       	ldi	r22, 0x00	; 0
     f62:	70 e0       	ldi	r23, 0x00	; 0
     f64:	0e 94 ab 10 	call	0x2156	; 0x2156 <xQueueGive>
	vSemaphoreCreateBinary( xPortB );
     f68:	43 e0       	ldi	r20, 0x03	; 3
     f6a:	60 e0       	ldi	r22, 0x00	; 0
     f6c:	81 e0       	ldi	r24, 0x01	; 1
     f6e:	d9 d6       	rcall	.+3506   	; 0x1d22 <xQueueGenericCreate>
     f70:	90 93 ca 03 	sts	0x03CA, r25	; 0x8003ca <xPortB+0x1>
     f74:	80 93 c9 03 	sts	0x03C9, r24	; 0x8003c9 <xPortB>
     f78:	00 97       	sbiw	r24, 0x00	; 0
     f7a:	21 f0       	breq	.+8      	; 0xf84 <main+0x6c>
     f7c:	60 e0       	ldi	r22, 0x00	; 0
     f7e:	70 e0       	ldi	r23, 0x00	; 0
     f80:	0e 94 ab 10 	call	0x2156	; 0x2156 <xQueueGive>

	// alustetaan sarjaportti
	xSerialPort = xSerialPortInitMinimal(0, mainCOM_BAUD_RATE, comBUFFER_LEN ,10);
     f84:	0f 2e       	mov	r0, r31
     f86:	fa e0       	ldi	r31, 0x0A	; 10
     f88:	ef 2e       	mov	r14, r31
     f8a:	f1 2c       	mov	r15, r1
     f8c:	f0 2d       	mov	r31, r0
     f8e:	02 e3       	ldi	r16, 0x32	; 50
     f90:	10 e0       	ldi	r17, 0x00	; 0
     f92:	20 e8       	ldi	r18, 0x80	; 128
     f94:	35 e2       	ldi	r19, 0x25	; 37
     f96:	40 e0       	ldi	r20, 0x00	; 0
     f98:	50 e0       	ldi	r21, 0x00	; 0
     f9a:	60 e0       	ldi	r22, 0x00	; 0
     f9c:	ce 01       	movw	r24, r28
     f9e:	01 96       	adiw	r24, 0x01	; 1
     fa0:	0e 94 41 1c 	call	0x3882	; 0x3882 <xSerialPortInitMinimal>
     fa4:	82 e2       	ldi	r24, 0x22	; 34
     fa6:	fe 01       	movw	r30, r28
     fa8:	31 96       	adiw	r30, 0x01	; 1
     faa:	a6 e5       	ldi	r26, 0x56	; 86
     fac:	b6 e1       	ldi	r27, 0x16	; 22
     fae:	01 90       	ld	r0, Z+
     fb0:	0d 92       	st	X+, r0
     fb2:	8a 95       	dec	r24
	lcd_init(LCD_DISP_ON);  // lcd-kuntoon
     fb4:	e1 f7       	brne	.-8      	; 0xfae <main+0x96>
     fb6:	8c e0       	ldi	r24, 0x0C	; 12
     fb8:	83 d1       	rcall	.+774    	; 0x12c0 <lcd_init>

	// luodaan taskit
	xTaskCreate( vLcdHandler, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     fba:	a1 2c       	mov	r10, r1
     fbc:	b1 2c       	mov	r11, r1
     fbe:	c1 2c       	mov	r12, r1
     fc0:	d1 2c       	mov	r13, r1
     fc2:	e1 2c       	mov	r14, r1
     fc4:	f1 2c       	mov	r15, r1
     fc6:	02 e0       	ldi	r16, 0x02	; 2
     fc8:	20 e0       	ldi	r18, 0x00	; 0
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	44 e6       	ldi	r20, 0x64	; 100
     fce:	50 e0       	ldi	r21, 0x00	; 0
     fd0:	60 e0       	ldi	r22, 0x00	; 0
     fd2:	70 e0       	ldi	r23, 0x00	; 0
     fd4:	81 e1       	ldi	r24, 0x11	; 17
     fd6:	94 e0       	ldi	r25, 0x04	; 4
     fd8:	0e 94 cf 13 	call	0x279e	; 0x279e <xTaskGenericCreate>
	xTaskCreate( vDoMeasurements, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     fdc:	20 e0       	ldi	r18, 0x00	; 0
     fde:	30 e0       	ldi	r19, 0x00	; 0
     fe0:	44 e6       	ldi	r20, 0x64	; 100
     fe2:	50 e0       	ldi	r21, 0x00	; 0
     fe4:	60 e0       	ldi	r22, 0x00	; 0
     fe6:	70 e0       	ldi	r23, 0x00	; 0
     fe8:	81 e3       	ldi	r24, 0x31	; 49
     fea:	92 e0       	ldi	r25, 0x02	; 2
     fec:	0e 94 cf 13 	call	0x279e	; 0x279e <xTaskGenericCreate>
	xTaskCreate( vKeyPadHandler, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     ff0:	20 e0       	ldi	r18, 0x00	; 0
     ff2:	30 e0       	ldi	r19, 0x00	; 0
     ff4:	44 e6       	ldi	r20, 0x64	; 100
     ff6:	50 e0       	ldi	r21, 0x00	; 0
     ff8:	60 e0       	ldi	r22, 0x00	; 0
     ffa:	70 e0       	ldi	r23, 0x00	; 0
     ffc:	83 e0       	ldi	r24, 0x03	; 3
     ffe:	96 e0       	ldi	r25, 0x06	; 6
    1000:	0e 94 cf 13 	call	0x279e	; 0x279e <xTaskGenericCreate>
	xTaskCreate( vClock, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
    1004:	20 e0       	ldi	r18, 0x00	; 0
    1006:	30 e0       	ldi	r19, 0x00	; 0
    1008:	44 e6       	ldi	r20, 0x64	; 100
    100a:	50 e0       	ldi	r21, 0x00	; 0
    100c:	60 e0       	ldi	r22, 0x00	; 0
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	87 e9       	ldi	r24, 0x97	; 151
    1012:	96 e0       	ldi	r25, 0x06	; 6
    1014:	0e 94 cf 13 	call	0x279e	; 0x279e <xTaskGenericCreate>

	vTaskStartScheduler();  // ajastus pÃ¤Ã¤lle
    1018:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <vTaskStartScheduler>


	return 0;
}
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	a2 96       	adiw	r28, 0x22	; 34
    1022:	0f b6       	in	r0, 0x3f	; 63
    1024:	f8 94       	cli
    1026:	de bf       	out	0x3e, r29	; 62
    1028:	0f be       	out	0x3f, r0	; 63
    102a:	cd bf       	out	0x3d, r28	; 61
    102c:	df 91       	pop	r29
    102e:	cf 91       	pop	r28
    1030:	1f 91       	pop	r17
    1032:	0f 91       	pop	r16
    1034:	ff 90       	pop	r15
    1036:	ef 90       	pop	r14
    1038:	df 90       	pop	r13
    103a:	cf 90       	pop	r12
    103c:	bf 90       	pop	r11
    103e:	af 90       	pop	r10
    1040:	08 95       	ret

00001042 <ReadADC>:
#include <avr\io.h>              // Most basic include files
#include "adc.h"
// oletus kellotaajuus 16 Mhz Atmega328P
int ReadADC(void)
{
    1042:	cf 93       	push	r28
    1044:	df 93       	push	r29
  char i;
  int  lukema;

  int  tulos = 0;

  ADCSRA |= 1 << ADEN; // laite päälle
    1046:	ea e7       	ldi	r30, 0x7A	; 122
    1048:	f0 e0       	ldi	r31, 0x00	; 0
    104a:	80 81       	ld	r24, Z
    104c:	80 68       	ori	r24, 0x80	; 128
    104e:	80 83       	st	Z, r24

  //pitkäkestoinen lukema pois
  ADCSRA |= (1<<ADSC); //
    1050:	80 81       	ld	r24, Z
    1052:	80 64       	ori	r24, 0x40	; 64
    1054:	80 83       	st	Z, r24
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee päälle lopuksi
    1056:	80 81       	ld	r24, Z
    1058:	84 ff       	sbrs	r24, 4
    105a:	fd cf       	rjmp	.-6      	; 0x1056 <ReadADC+0x14>
    105c:	48 e0       	ldi	r20, 0x08	; 8
    105e:	60 e0       	ldi	r22, 0x00	; 0
    1060:	70 e0       	ldi	r23, 0x00	; 0

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
  {
    ADCSRA |= (1<<ADSC); // aloita muunnos
    1062:	ea e7       	ldi	r30, 0x7A	; 122
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    while(!(ADCSRA & (1 << ADIF))); // ADIF tulee päälle lopuksi

    lukema = ADCL;         // alaosa luetaan ensiksi
    1066:	c8 e7       	ldi	r28, 0x78	; 120
    1068:	d0 e0       	ldi	r29, 0x00	; 0
    lukema += (ADCH << 8); // yläosan luenta
    106a:	a9 e7       	ldi	r26, 0x79	; 121
    106c:	b0 e0       	ldi	r27, 0x00	; 0
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee päälle lopuksi

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
  {
    ADCSRA |= (1<<ADSC); // aloita muunnos
    106e:	90 81       	ld	r25, Z
    1070:	90 64       	ori	r25, 0x40	; 64
    1072:	90 83       	st	Z, r25
    while(!(ADCSRA & (1 << ADIF))); // ADIF tulee päälle lopuksi
    1074:	90 81       	ld	r25, Z
    1076:	94 ff       	sbrs	r25, 4
    1078:	fd cf       	rjmp	.-6      	; 0x1074 <ReadADC+0x32>

    lukema = ADCL;         // alaosa luetaan ensiksi
    107a:	88 81       	ld	r24, Y
    lukema += (ADCH << 8); // yläosan luenta
    107c:	2c 91       	ld	r18, X

    // otetaan 8 lukemaa summaksi
    tulos += lukema;
    107e:	30 e0       	ldi	r19, 0x00	; 0
    1080:	32 2f       	mov	r19, r18
    1082:	22 27       	eor	r18, r18
    1084:	28 0f       	add	r18, r24
    1086:	31 1d       	adc	r19, r1
    1088:	62 0f       	add	r22, r18
    108a:	73 1f       	adc	r23, r19
    108c:	41 50       	subi	r20, 0x01	; 1
  //pitkäkestoinen lukema pois
  ADCSRA |= (1<<ADSC); //
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee päälle lopuksi

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
    108e:	79 f7       	brne	.-34     	; 0x106e <ReadADC+0x2c>
    tulos += lukema;
  }

  tulos = tulos >> 3; // lukemien keskiarvo

  ADCSRA &= ~(1<<ADEN); // AD-muunnin pois päältä
    1090:	ea e7       	ldi	r30, 0x7A	; 122
    1092:	f0 e0       	ldi	r31, 0x00	; 0
    1094:	80 81       	ld	r24, Z
    1096:	8f 77       	andi	r24, 0x7F	; 127
    1098:	80 83       	st	Z, r24
  return tulos;
}
    109a:	cb 01       	movw	r24, r22
    109c:	95 95       	asr	r25
    109e:	87 95       	ror	r24
    10a0:	95 95       	asr	r25
    10a2:	87 95       	ror	r24
    10a4:	95 95       	asr	r25
    10a6:	87 95       	ror	r24
    10a8:	df 91       	pop	r29
    10aa:	cf 91       	pop	r28
    10ac:	08 95       	ret

000010ae <InitADC>:

void InitADC(char portti)
{
  // sisäinen referenssijännite + kanavan valinta
  //ADMUX = (1 << REFS1) | (1 << REFS0) | portti;
  ADMUX =  (1 << REFS0) | portti;
    10ae:	80 64       	ori	r24, 0x40	; 64
    10b0:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x70007c>

  // laite päälle + kellotaajuudeksi 16MHz / 128 = 125kHz
  ADCSRA = (1<<ADEN) | (1<<ADPS0) | (1<<ADPS1) | (1<<ADPS2);
    10b4:	87 e8       	ldi	r24, 0x87	; 135
    10b6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  ReadADC(); // nollataan muunnin lukemalla kertaalleen
    10ba:	c3 cf       	rjmp	.-122    	; 0x1042 <ReadADC>
    10bc:	08 95       	ret

000010be <GetKey>:
#include "device.h"

unsigned char GetKey(void)
{
    10be:	0f 93       	push	r16
    10c0:	1f 93       	push	r17
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29

  int nValue;

  InitADC(0);
    10c6:	80 e0       	ldi	r24, 0x00	; 0
    10c8:	f2 df       	rcall	.-28     	; 0x10ae <InitADC>

  nValue = ReadADC();
    10ca:	bb df       	rcall	.-138    	; 0x1042 <ReadADC>
    10cc:	85 38       	cpi	r24, 0x85	; 133
  
  // jos mikään näppäin ei ole alhaalla
  // saadaan 1023, mutta siirtymävaiheessa
  // saattaa tulla hieman pienempiä arvoja
  // tulkitaan nekin ei näppäiksi
  if (nValue > 900)
    10ce:	93 40       	sbci	r25, 0x03	; 3
    10d0:	0c f5       	brge	.+66     	; 0x1114 <GetKey+0x56>
    10d2:	ca e0       	ldi	r28, 0x0A	; 10
    10d4:	d0 e0       	ldi	r29, 0x00	; 0
    10d6:	00 e0       	ldi	r16, 0x00	; 0
    10d8:	10 e0       	ldi	r17, 0x00	; 0
  
  // luetaan 10 kertaa ja käytetään keskiarvoa
  // transienttilukemien eliminoimiseksi
  nValue = 0;
  for(int i=0; i < 10; i++)
   nValue += ReadADC();
    10da:	b3 df       	rcall	.-154    	; 0x1042 <ReadADC>
    10dc:	08 0f       	add	r16, r24
    10de:	19 1f       	adc	r17, r25
    10e0:	21 97       	sbiw	r28, 0x01	; 1
    10e2:	d9 f7       	brne	.-10     	; 0x10da <GetKey+0x1c>
     return NO_KEY;  
  
  // luetaan 10 kertaa ja käytetään keskiarvoa
  // transienttilukemien eliminoimiseksi
  nValue = 0;
  for(int i=0; i < 10; i++)
    10e4:	c8 01       	movw	r24, r16
   nValue += ReadADC();
  nValue /= 10; // keskiarvo
    10e6:	6a e0       	ldi	r22, 0x0A	; 10
    10e8:	70 e0       	ldi	r23, 0x00	; 0
    10ea:	0e 94 bf 21 	call	0x437e	; 0x437e <__divmodhi4>
    10ee:	62 33       	cpi	r22, 0x32	; 50

  // tunnistetaan
  if (nValue < 50)
    10f0:	71 05       	cpc	r23, r1
    10f2:	94 f0       	brlt	.+36     	; 0x1118 <GetKey+0x5a>
    10f4:	66 3e       	cpi	r22, 0xE6	; 230
	  return IDK_RIGHT;
  else if (nValue < 230)
    10f6:	71 05       	cpc	r23, r1
    10f8:	8c f0       	brlt	.+34     	; 0x111c <GetKey+0x5e>
    10fa:	62 3c       	cpi	r22, 0xC2	; 194
	  return IDK_UP;
  else if (nValue < 450)
    10fc:	81 e0       	ldi	r24, 0x01	; 1
    10fe:	78 07       	cpc	r23, r24
    1100:	7c f0       	brlt	.+30     	; 0x1120 <GetKey+0x62>
    1102:	6a 38       	cpi	r22, 0x8A	; 138
	  return IDK_DOWN;
  else if (nValue < 650)
    1104:	22 e0       	ldi	r18, 0x02	; 2
    1106:	72 07       	cpc	r23, r18
    1108:	6c f0       	brlt	.+26     	; 0x1124 <GetKey+0x66>
    110a:	64 38       	cpi	r22, 0x84	; 132
	  return IDK_LEFT;
  else if (nValue < 900)
    110c:	73 40       	sbci	r23, 0x03	; 3
    110e:	64 f0       	brlt	.+24     	; 0x1128 <GetKey+0x6a>
    1110:	83 e6       	ldi	r24, 0x63	; 99
	  return IDK_SELECT;
  else return NO_KEY; // ei yhtään alhaalla
    1112:	0b c0       	rjmp	.+22     	; 0x112a <GetKey+0x6c>
    1114:	83 e6       	ldi	r24, 0x63	; 99
  // jos mikään näppäin ei ole alhaalla
  // saadaan 1023, mutta siirtymävaiheessa
  // saattaa tulla hieman pienempiä arvoja
  // tulkitaan nekin ei näppäiksi
  if (nValue > 900)
     return NO_KEY;  
    1116:	09 c0       	rjmp	.+18     	; 0x112a <GetKey+0x6c>
    1118:	81 e0       	ldi	r24, 0x01	; 1
   nValue += ReadADC();
  nValue /= 10; // keskiarvo

  // tunnistetaan
  if (nValue < 50)
	  return IDK_RIGHT;
    111a:	07 c0       	rjmp	.+14     	; 0x112a <GetKey+0x6c>
    111c:	82 e0       	ldi	r24, 0x02	; 2
  else if (nValue < 230)
	  return IDK_UP;
    111e:	05 c0       	rjmp	.+10     	; 0x112a <GetKey+0x6c>
    1120:	83 e0       	ldi	r24, 0x03	; 3
  else if (nValue < 450)
	  return IDK_DOWN;
    1122:	03 c0       	rjmp	.+6      	; 0x112a <GetKey+0x6c>
    1124:	84 e0       	ldi	r24, 0x04	; 4
  else if (nValue < 650)
	  return IDK_LEFT;
    1126:	01 c0       	rjmp	.+2      	; 0x112a <GetKey+0x6c>
    1128:	85 e0       	ldi	r24, 0x05	; 5
  else if (nValue < 900)
	  return IDK_SELECT;
    112a:	df 91       	pop	r29
  else return NO_KEY; // ei yhtään alhaalla
}
    112c:	cf 91       	pop	r28
    112e:	1f 91       	pop	r17
    1130:	0f 91       	pop	r16
    1132:	08 95       	ret

00001134 <lcd_write>:
    1134:	66 23       	and	r22, r22
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) )
        lcd_putc(c);

}
    1136:	31 f0       	breq	.+12     	; 0x1144 <lcd_write+0x10>
    1138:	e2 e0       	ldi	r30, 0x02	; 2
    113a:	f1 e0       	ldi	r31, 0x01	; 1
    113c:	90 81       	ld	r25, Z
    113e:	90 62       	ori	r25, 0x20	; 32
    1140:	90 83       	st	Z, r25
    1142:	05 c0       	rjmp	.+10     	; 0x114e <lcd_write+0x1a>
    1144:	e2 e0       	ldi	r30, 0x02	; 2
    1146:	f1 e0       	ldi	r31, 0x01	; 1
    1148:	90 81       	ld	r25, Z
    114a:	9f 7d       	andi	r25, 0xDF	; 223
    114c:	90 83       	st	Z, r25
    114e:	41 11       	cpse	r20, r1
    1150:	3d c0       	rjmp	.+122    	; 0x11cc <lcd_write+0x98>
    1152:	88 23       	and	r24, r24
    1154:	34 f4       	brge	.+12     	; 0x1162 <lcd_write+0x2e>
    1156:	e2 e0       	ldi	r30, 0x02	; 2
    1158:	f1 e0       	ldi	r31, 0x01	; 1
    115a:	90 81       	ld	r25, Z
    115c:	90 61       	ori	r25, 0x10	; 16
    115e:	90 83       	st	Z, r25
    1160:	05 c0       	rjmp	.+10     	; 0x116c <lcd_write+0x38>
    1162:	e2 e0       	ldi	r30, 0x02	; 2
    1164:	f1 e0       	ldi	r31, 0x01	; 1
    1166:	90 81       	ld	r25, Z
    1168:	9f 7e       	andi	r25, 0xEF	; 239
    116a:	90 83       	st	Z, r25
    116c:	86 ff       	sbrs	r24, 6
    116e:	06 c0       	rjmp	.+12     	; 0x117c <lcd_write+0x48>
    1170:	e2 e0       	ldi	r30, 0x02	; 2
    1172:	f1 e0       	ldi	r31, 0x01	; 1
    1174:	90 81       	ld	r25, Z
    1176:	98 60       	ori	r25, 0x08	; 8
    1178:	90 83       	st	Z, r25
    117a:	05 c0       	rjmp	.+10     	; 0x1186 <lcd_write+0x52>
    117c:	e2 e0       	ldi	r30, 0x02	; 2
    117e:	f1 e0       	ldi	r31, 0x01	; 1
    1180:	90 81       	ld	r25, Z
    1182:	97 7f       	andi	r25, 0xF7	; 247
    1184:	90 83       	st	Z, r25
    1186:	85 ff       	sbrs	r24, 5
    1188:	02 c0       	rjmp	.+4      	; 0x118e <lcd_write+0x5a>
    118a:	73 9a       	sbi	0x0e, 3	; 14
    118c:	01 c0       	rjmp	.+2      	; 0x1190 <lcd_write+0x5c>
    118e:	73 98       	cbi	0x0e, 3	; 14
    1190:	84 ff       	sbrs	r24, 4
    1192:	02 c0       	rjmp	.+4      	; 0x1198 <lcd_write+0x64>
    1194:	a5 9a       	sbi	0x14, 5	; 20
    1196:	01 c0       	rjmp	.+2      	; 0x119a <lcd_write+0x66>
    1198:	a5 98       	cbi	0x14, 5	; 20
    119a:	e2 e0       	ldi	r30, 0x02	; 2
    119c:	f1 e0       	ldi	r31, 0x01	; 1
    119e:	90 81       	ld	r25, Z
    11a0:	9f 7b       	andi	r25, 0xBF	; 191
    11a2:	90 83       	st	Z, r25
    11a4:	95 e0       	ldi	r25, 0x05	; 5
    11a6:	9a 95       	dec	r25
    11a8:	f1 f7       	brne	.-4      	; 0x11a6 <lcd_write+0x72>
    11aa:	00 00       	nop
    11ac:	90 81       	ld	r25, Z
    11ae:	90 64       	ori	r25, 0x40	; 64
    11b0:	90 83       	st	Z, r25
    11b2:	95 e0       	ldi	r25, 0x05	; 5
    11b4:	9a 95       	dec	r25
    11b6:	f1 f7       	brne	.-4      	; 0x11b4 <lcd_write+0x80>
    11b8:	00 00       	nop
    11ba:	90 81       	ld	r25, Z
    11bc:	9f 7b       	andi	r25, 0xBF	; 191
    11be:	90 83       	st	Z, r25
    11c0:	ef e9       	ldi	r30, 0x9F	; 159
    11c2:	ff e0       	ldi	r31, 0x0F	; 15
    11c4:	31 97       	sbiw	r30, 0x01	; 1
    11c6:	f1 f7       	brne	.-4      	; 0x11c4 <lcd_write+0x90>
    11c8:	00 c0       	rjmp	.+0      	; 0x11ca <lcd_write+0x96>
    11ca:	00 00       	nop
    11cc:	83 ff       	sbrs	r24, 3
    11ce:	06 c0       	rjmp	.+12     	; 0x11dc <lcd_write+0xa8>
    11d0:	e2 e0       	ldi	r30, 0x02	; 2
    11d2:	f1 e0       	ldi	r31, 0x01	; 1
    11d4:	90 81       	ld	r25, Z
    11d6:	90 61       	ori	r25, 0x10	; 16
    11d8:	90 83       	st	Z, r25
    11da:	05 c0       	rjmp	.+10     	; 0x11e6 <lcd_write+0xb2>
    11dc:	e2 e0       	ldi	r30, 0x02	; 2
    11de:	f1 e0       	ldi	r31, 0x01	; 1
    11e0:	90 81       	ld	r25, Z
    11e2:	9f 7e       	andi	r25, 0xEF	; 239
    11e4:	90 83       	st	Z, r25
    11e6:	82 ff       	sbrs	r24, 2
    11e8:	06 c0       	rjmp	.+12     	; 0x11f6 <lcd_write+0xc2>
    11ea:	e2 e0       	ldi	r30, 0x02	; 2
    11ec:	f1 e0       	ldi	r31, 0x01	; 1
    11ee:	90 81       	ld	r25, Z
    11f0:	98 60       	ori	r25, 0x08	; 8
    11f2:	90 83       	st	Z, r25
    11f4:	05 c0       	rjmp	.+10     	; 0x1200 <lcd_write+0xcc>
    11f6:	e2 e0       	ldi	r30, 0x02	; 2
    11f8:	f1 e0       	ldi	r31, 0x01	; 1
    11fa:	90 81       	ld	r25, Z
    11fc:	97 7f       	andi	r25, 0xF7	; 247
    11fe:	90 83       	st	Z, r25
    1200:	81 ff       	sbrs	r24, 1
    1202:	02 c0       	rjmp	.+4      	; 0x1208 <lcd_write+0xd4>
    1204:	73 9a       	sbi	0x0e, 3	; 14
    1206:	01 c0       	rjmp	.+2      	; 0x120a <lcd_write+0xd6>
    1208:	73 98       	cbi	0x0e, 3	; 14
    120a:	80 ff       	sbrs	r24, 0
    120c:	02 c0       	rjmp	.+4      	; 0x1212 <lcd_write+0xde>
    120e:	a5 9a       	sbi	0x14, 5	; 20
    1210:	01 c0       	rjmp	.+2      	; 0x1214 <lcd_write+0xe0>
    1212:	a5 98       	cbi	0x14, 5	; 20
    1214:	e2 e0       	ldi	r30, 0x02	; 2
    1216:	f1 e0       	ldi	r31, 0x01	; 1
    1218:	80 81       	ld	r24, Z
    121a:	8f 7b       	andi	r24, 0xBF	; 191
    121c:	80 83       	st	Z, r24
    121e:	85 e0       	ldi	r24, 0x05	; 5
    1220:	8a 95       	dec	r24
    1222:	f1 f7       	brne	.-4      	; 0x1220 <lcd_write+0xec>
    1224:	00 00       	nop
    1226:	80 81       	ld	r24, Z
    1228:	80 64       	ori	r24, 0x40	; 64
    122a:	80 83       	st	Z, r24
    122c:	95 e0       	ldi	r25, 0x05	; 5
    122e:	9a 95       	dec	r25
    1230:	f1 f7       	brne	.-4      	; 0x122e <lcd_write+0xfa>
    1232:	00 00       	nop
    1234:	80 81       	ld	r24, Z
    1236:	8f 7b       	andi	r24, 0xBF	; 191
    1238:	80 83       	st	Z, r24
    123a:	8f e9       	ldi	r24, 0x9F	; 159
    123c:	9f e0       	ldi	r25, 0x0F	; 15
    123e:	01 97       	sbiw	r24, 0x01	; 1
    1240:	f1 f7       	brne	.-4      	; 0x123e <lcd_write+0x10a>
    1242:	00 c0       	rjmp	.+0      	; 0x1244 <lcd_write+0x110>
    1244:	00 00       	nop
    1246:	a5 9a       	sbi	0x14, 5	; 20
    1248:	73 9a       	sbi	0x0e, 3	; 14
    124a:	80 81       	ld	r24, Z
    124c:	88 60       	ori	r24, 0x08	; 8
    124e:	80 83       	st	Z, r24
    1250:	80 81       	ld	r24, Z
    1252:	80 61       	ori	r24, 0x10	; 16
    1254:	80 83       	st	Z, r24
    1256:	08 95       	ret

00001258 <lcd_command>:
    1258:	40 e0       	ldi	r20, 0x00	; 0
    125a:	60 e0       	ldi	r22, 0x00	; 0
    125c:	6b cf       	rjmp	.-298    	; 0x1134 <lcd_write>
    125e:	08 95       	ret

00001260 <lcd_gotoxy>:
    1260:	cf 93       	push	r28
    1262:	df 93       	push	r29
    1264:	d8 2f       	mov	r29, r24
    1266:	c6 2f       	mov	r28, r22
    1268:	82 e0       	ldi	r24, 0x02	; 2
    126a:	f6 df       	rcall	.-20     	; 0x1258 <lcd_command>
    126c:	c1 30       	cpi	r28, 0x01	; 1
    126e:	09 f4       	brne	.+2      	; 0x1272 <lcd_gotoxy+0x12>
    1270:	d8 5d       	subi	r29, 0xD8	; 216
    1272:	dd 23       	and	r29, r29
    1274:	31 f0       	breq	.+12     	; 0x1282 <lcd_gotoxy+0x22>
    1276:	c0 e0       	ldi	r28, 0x00	; 0
    1278:	84 e1       	ldi	r24, 0x14	; 20
    127a:	ee df       	rcall	.-36     	; 0x1258 <lcd_command>
    127c:	cf 5f       	subi	r28, 0xFF	; 255
    127e:	dc 13       	cpse	r29, r28
    1280:	fb cf       	rjmp	.-10     	; 0x1278 <lcd_gotoxy+0x18>
    1282:	df 91       	pop	r29
    1284:	cf 91       	pop	r28
    1286:	08 95       	ret

00001288 <lcd_clrscr>:
    1288:	81 e0       	ldi	r24, 0x01	; 1
    128a:	e6 df       	rcall	.-52     	; 0x1258 <lcd_command>
    128c:	8f ed       	ldi	r24, 0xDF	; 223
    128e:	9e e2       	ldi	r25, 0x2E	; 46
    1290:	01 97       	sbiw	r24, 0x01	; 1
    1292:	f1 f7       	brne	.-4      	; 0x1290 <lcd_clrscr+0x8>
    1294:	00 c0       	rjmp	.+0      	; 0x1296 <lcd_clrscr+0xe>
    1296:	00 00       	nop
    1298:	08 95       	ret

0000129a <lcd_putc>:
    129a:	40 e0       	ldi	r20, 0x00	; 0
    129c:	61 e0       	ldi	r22, 0x01	; 1
    129e:	4a cf       	rjmp	.-364    	; 0x1134 <lcd_write>
    12a0:	08 95       	ret

000012a2 <lcd_puts>:
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	ec 01       	movw	r28, r24
    12a8:	21 96       	adiw	r28, 0x01	; 1
    12aa:	fc 01       	movw	r30, r24
    12ac:	80 81       	ld	r24, Z
    12ae:	88 23       	and	r24, r24
    12b0:	21 f0       	breq	.+8      	; 0x12ba <lcd_puts+0x18>
    12b2:	f3 df       	rcall	.-26     	; 0x129a <lcd_putc>
    12b4:	89 91       	ld	r24, Y+
    12b6:	81 11       	cpse	r24, r1
    12b8:	fc cf       	rjmp	.-8      	; 0x12b2 <lcd_puts+0x10>
    12ba:	df 91       	pop	r29
    12bc:	cf 91       	pop	r28
    12be:	08 95       	ret

000012c0 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
    12c0:	cf 93       	push	r28
    12c2:	c8 2f       	mov	r28, r24
   //
   //  Initialize LCD to 4 bit I/O mode
   //

    // configure all port bits as output
   DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
    12c4:	e1 e0       	ldi	r30, 0x01	; 1
    12c6:	f1 e0       	ldi	r31, 0x01	; 1
    12c8:	80 81       	ld	r24, Z
    12ca:	80 62       	ori	r24, 0x20	; 32
    12cc:	80 83       	st	Z, r24
   //DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
   DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    12ce:	80 81       	ld	r24, Z
    12d0:	80 64       	ori	r24, 0x40	; 64
    12d2:	80 83       	st	Z, r24
   DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
    12d4:	9d 9a       	sbi	0x13, 5	; 19
   DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
    12d6:	6b 9a       	sbi	0x0d, 3	; 13
   DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
    12d8:	80 81       	ld	r24, Z
    12da:	88 60       	ori	r24, 0x08	; 8
    12dc:	80 83       	st	Z, r24
   DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    12de:	80 81       	ld	r24, Z
    12e0:	80 61       	ori	r24, 0x10	; 16
    12e2:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    12e4:	2f ef       	ldi	r18, 0xFF	; 255
    12e6:	8d ee       	ldi	r24, 0xED	; 237
    12e8:	92 e0       	ldi	r25, 0x02	; 2
    12ea:	21 50       	subi	r18, 0x01	; 1
    12ec:	80 40       	sbci	r24, 0x00	; 0
    12ee:	90 40       	sbci	r25, 0x00	; 0
    12f0:	e1 f7       	brne	.-8      	; 0x12ea <lcd_init+0x2a>
    12f2:	00 c0       	rjmp	.+0      	; 0x12f4 <lcd_init+0x34>
    12f4:	00 00       	nop
   _delay_ms(60);     //  wait 50ms or more after power-on

   // reset the lcd circuit
 //  lcd_write(0x33, 0,0);
 //  _delay_ms(5);      // wait 5 ms
    lcd_rs_low();
    12f6:	e2 e0       	ldi	r30, 0x02	; 2
    12f8:	f1 e0       	ldi	r31, 0x01	; 1
    12fa:	80 81       	ld	r24, Z
    12fc:	8f 7d       	andi	r24, 0xDF	; 223
    12fe:	80 83       	st	Z, r24
    lcd_e_low();
    1300:	80 81       	ld	r24, Z
    1302:	8f 7b       	andi	r24, 0xBF	; 191
    1304:	80 83       	st	Z, r24


   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
    1306:	41 e0       	ldi	r20, 0x01	; 1
    1308:	60 e0       	ldi	r22, 0x00	; 0
    130a:	83 e0       	ldi	r24, 0x03	; 3
    130c:	13 df       	rcall	.-474    	; 0x1134 <lcd_write>
    130e:	8f e1       	ldi	r24, 0x1F	; 31
    1310:	9e e4       	ldi	r25, 0x4E	; 78
    1312:	01 97       	sbiw	r24, 0x01	; 1
    1314:	f1 f7       	brne	.-4      	; 0x1312 <lcd_init+0x52>
    1316:	00 c0       	rjmp	.+0      	; 0x1318 <lcd_init+0x58>
    1318:	00 00       	nop
   _delay_ms(5);      // wait 5 ms
   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
    131a:	41 e0       	ldi	r20, 0x01	; 1
    131c:	60 e0       	ldi	r22, 0x00	; 0
    131e:	83 e0       	ldi	r24, 0x03	; 3
    1320:	09 df       	rcall	.-494    	; 0x1134 <lcd_write>
    1322:	8f e9       	ldi	r24, 0x9F	; 159
    1324:	9f e0       	ldi	r25, 0x0F	; 15
    1326:	01 97       	sbiw	r24, 0x01	; 1
    1328:	f1 f7       	brne	.-4      	; 0x1326 <lcd_init+0x66>
    132a:	00 c0       	rjmp	.+0      	; 0x132c <lcd_init+0x6c>
    132c:	00 00       	nop
   _delay_ms(1);      // wait 1 ms
   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
    132e:	41 e0       	ldi	r20, 0x01	; 1
    1330:	60 e0       	ldi	r22, 0x00	; 0
    1332:	83 e0       	ldi	r24, 0x03	; 3
    1334:	ff de       	rcall	.-514    	; 0x1134 <lcd_write>
    1336:	8f e9       	ldi	r24, 0x9F	; 159
    1338:	9f e0       	ldi	r25, 0x0F	; 15
    133a:	01 97       	sbiw	r24, 0x01	; 1
    133c:	f1 f7       	brne	.-4      	; 0x133a <lcd_init+0x7a>
    133e:	00 c0       	rjmp	.+0      	; 0x1340 <lcd_init+0x80>
    1340:	00 00       	nop
   _delay_ms(1);      // wait 5 ms
   // finally, set to 4-bit interface
   lcd_write(0x02,0,1);
    1342:	41 e0       	ldi	r20, 0x01	; 1
    1344:	60 e0       	ldi	r22, 0x00	; 0
    1346:	82 e0       	ldi	r24, 0x02	; 2
    1348:	f5 de       	rcall	.-534    	; 0x1134 <lcd_write>

   // set 2 lines and 5x7 dots /character mode
   // NFXX
   //   N = 1 2 lines  F = 1 5x10   F = 0 5x7
   lcd_write(0x28,0,0);
    134a:	40 e0       	ldi	r20, 0x00	; 0
    134c:	60 e0       	ldi	r22, 0x00	; 0
    134e:	88 e2       	ldi	r24, 0x28	; 40

   // from now the LCD only accepts 4 bit I/O, we can use lcd_command()
    lcd_clrscr();                     // display clear
    1350:	f1 de       	rcall	.-542    	; 0x1134 <lcd_write>
    1352:	9a df       	rcall	.-204    	; 0x1288 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);    // set entry mode
    1354:	86 e0       	ldi	r24, 0x06	; 6
    1356:	80 df       	rcall	.-256    	; 0x1258 <lcd_command>
    1358:	8c 2f       	mov	r24, r28
	lcd_command(dispAttr);
    135a:	7e df       	rcall	.-260    	; 0x1258 <lcd_command>
    135c:	cf 91       	pop	r28
    135e:	08 95       	ret

00001360 <crc8>:
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
    1360:	61 15       	cp	r22, r1
    1362:	71 05       	cpc	r23, r1
    1364:	a9 f0       	breq	.+42     	; 0x1390 <crc8+0x30>
    1366:	fc 01       	movw	r30, r24
    1368:	68 0f       	add	r22, r24
    136a:	79 1f       	adc	r23, r25
    136c:	80 e0       	ldi	r24, 0x00	; 0
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
    136e:	48 e1       	ldi	r20, 0x18	; 24
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
	{
		b = data[loop_count];
    1370:	21 91       	ld	r18, Z+
    1372:	98 e0       	ldi	r25, 0x08	; 8
		
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
    1374:	38 2f       	mov	r19, r24
    1376:	32 27       	eor	r19, r18
    1378:	30 ff       	sbrs	r19, 0
    137a:	0c c0       	rjmp	.+24     	; 0x1394 <crc8+0x34>
				crc = crc ^ CRC8POLY;
    137c:	84 27       	eor	r24, r20
			}
			crc = (crc >> 1) & 0x7F;
    137e:	86 95       	lsr	r24
			if ( feedback_bit == 0x01 ) {
				crc = crc | 0x80;
    1380:	80 68       	ori	r24, 0x80	; 128
			}
		
			b = b >> 1;
    1382:	26 95       	lsr	r18
    1384:	91 50       	subi	r25, 0x01	; 1
			bit_counter--;
		
		} while (bit_counter > 0);
    1386:	b1 f7       	brne	.-20     	; 0x1374 <crc8+0x14>
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
    1388:	e6 17       	cp	r30, r22
    138a:	f7 07       	cpc	r31, r23
    138c:	89 f7       	brne	.-30     	; 0x1370 <crc8+0x10>
    138e:	08 95       	ret
	uint16_t loop_count;
	uint8_t  bit_counter;
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;
    1390:	80 e0       	ldi	r24, 0x00	; 0
			bit_counter--;
		
		} while (bit_counter > 0);
	}
	
	return crc;
    1392:	08 95       	ret
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
			}
			crc = (crc >> 1) & 0x7F;
    1394:	86 95       	lsr	r24
    1396:	f5 cf       	rjmp	.-22     	; 0x1382 <crc8+0x22>

00001398 <read_scratchpad>:
//********************************************************//

uint8_t DS18X20_conversion_in_progress(void)
{
	return ow_bit_io( 1 ) ? DS18X20_CONVERSION_DONE : DS18X20_CONVERTING;
}
    1398:	ef 92       	push	r14
    139a:	ff 92       	push	r15
    139c:	0f 93       	push	r16
    139e:	1f 93       	push	r17
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	7b 01       	movw	r14, r22
    13a6:	04 2f       	mov	r16, r20
    13a8:	bc 01       	movw	r22, r24
    13aa:	8e eb       	ldi	r24, 0xBE	; 190
    13ac:	dd d1       	rcall	.+954    	; 0x1768 <ow_command>
    13ae:	00 23       	and	r16, r16
    13b0:	61 f0       	breq	.+24     	; 0x13ca <read_scratchpad+0x32>
    13b2:	e7 01       	movw	r28, r14
    13b4:	01 50       	subi	r16, 0x01	; 1
    13b6:	10 e0       	ldi	r17, 0x00	; 0
    13b8:	0f 5f       	subi	r16, 0xFF	; 255
    13ba:	1f 4f       	sbci	r17, 0xFF	; 255
    13bc:	0e 0d       	add	r16, r14
    13be:	1f 1d       	adc	r17, r15
    13c0:	7c d1       	rcall	.+760    	; 0x16ba <ow_byte_rd>
    13c2:	89 93       	st	Y+, r24
    13c4:	c0 17       	cp	r28, r16
    13c6:	d1 07       	cpc	r29, r17
    13c8:	d9 f7       	brne	.-10     	; 0x13c0 <read_scratchpad+0x28>
    13ca:	69 e0       	ldi	r22, 0x09	; 9
    13cc:	70 e0       	ldi	r23, 0x00	; 0
    13ce:	c7 01       	movw	r24, r14
    13d0:	c7 df       	rcall	.-114    	; 0x1360 <crc8>
    13d2:	81 11       	cpse	r24, r1
    13d4:	83 e0       	ldi	r24, 0x03	; 3
    13d6:	df 91       	pop	r29
    13d8:	cf 91       	pop	r28
    13da:	1f 91       	pop	r17
    13dc:	0f 91       	pop	r16
    13de:	ff 90       	pop	r15
    13e0:	ef 90       	pop	r14
    13e2:	08 95       	ret

000013e4 <DS18X20_find_sensor>:
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
    13ec:	ec 01       	movw	r28, r24
    13ee:	8b 01       	movw	r16, r22
    13f0:	b8 01       	movw	r22, r16
    13f2:	88 81       	ld	r24, Y
    13f4:	65 d1       	rcall	.+714    	; 0x16c0 <ow_rom_search>
    13f6:	88 83       	st	Y, r24
    13f8:	81 50       	subi	r24, 0x01	; 1
    13fa:	8d 3f       	cpi	r24, 0xFD	; 253
    13fc:	50 f4       	brcc	.+20     	; 0x1412 <DS18X20_find_sensor+0x2e>
    13fe:	f8 01       	movw	r30, r16
    1400:	80 81       	ld	r24, Z
    1402:	88 32       	cpi	r24, 0x28	; 40
    1404:	41 f0       	breq	.+16     	; 0x1416 <DS18X20_find_sensor+0x32>
    1406:	80 31       	cpi	r24, 0x10	; 16
    1408:	41 f0       	breq	.+16     	; 0x141a <DS18X20_find_sensor+0x36>
    140a:	82 32       	cpi	r24, 0x22	; 34
    140c:	89 f7       	brne	.-30     	; 0x13f0 <DS18X20_find_sensor+0xc>
    140e:	80 e0       	ldi	r24, 0x00	; 0
    1410:	05 c0       	rjmp	.+10     	; 0x141c <DS18X20_find_sensor+0x38>
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	03 c0       	rjmp	.+6      	; 0x141c <DS18X20_find_sensor+0x38>
    1416:	80 e0       	ldi	r24, 0x00	; 0
    1418:	01 c0       	rjmp	.+2      	; 0x141c <DS18X20_find_sensor+0x38>
    141a:	80 e0       	ldi	r24, 0x00	; 0
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	08 95       	ret

00001426 <DS18X20_start_meas>:
    1426:	1f 93       	push	r17
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
    142c:	18 2f       	mov	r17, r24
    142e:	eb 01       	movw	r28, r22
    1430:	cf d0       	rcall	.+414    	; 0x15d0 <ow_reset>
    1432:	a7 d0       	rcall	.+334    	; 0x1582 <ow_input_pin_state>
    1434:	88 23       	and	r24, r24
    1436:	61 f0       	breq	.+24     	; 0x1450 <DS18X20_start_meas+0x2a>
    1438:	11 30       	cpi	r17, 0x01	; 1
    143a:	29 f0       	breq	.+10     	; 0x1446 <DS18X20_start_meas+0x20>
    143c:	be 01       	movw	r22, r28
    143e:	84 e4       	ldi	r24, 0x44	; 68
    1440:	96 d1       	rcall	.+812    	; 0x176e <ow_command_with_parasite_enable>
    1442:	80 e0       	ldi	r24, 0x00	; 0
    1444:	0e c0       	rjmp	.+28     	; 0x1462 <DS18X20_start_meas+0x3c>
    1446:	be 01       	movw	r22, r28
    1448:	84 e4       	ldi	r24, 0x44	; 68
    144a:	8e d1       	rcall	.+796    	; 0x1768 <ow_command>
    144c:	80 e0       	ldi	r24, 0x00	; 0
    144e:	09 c0       	rjmp	.+18     	; 0x1462 <DS18X20_start_meas+0x3c>
    1450:	86 ed       	ldi	r24, 0xD6	; 214
    1452:	92 e0       	ldi	r25, 0x02	; 2
    1454:	9f 93       	push	r25
    1456:	8f 93       	push	r24
    1458:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <printf>
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	82 e0       	ldi	r24, 0x02	; 2
    1462:	df 91       	pop	r29
    1464:	cf 91       	pop	r28
    1466:	1f 91       	pop	r17
    1468:	08 95       	ret

0000146a <DS18X20_read_maxres>:

	return temperaturevalue;
}

uint8_t DS18X20_read_maxres( uint8_t id[], long *temperaturevalue )
{
    146a:	ef 92       	push	r14
    146c:	ff 92       	push	r15
    146e:	0f 93       	push	r16
    1470:	1f 93       	push	r17
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	cd b7       	in	r28, 0x3d	; 61
    1478:	de b7       	in	r29, 0x3e	; 62
    147a:	29 97       	sbiw	r28, 0x09	; 9
    147c:	0f b6       	in	r0, 0x3f	; 63
    147e:	f8 94       	cli
    1480:	de bf       	out	0x3e, r29	; 62
    1482:	0f be       	out	0x3f, r0	; 63
    1484:	cd bf       	out	0x3d, r28	; 61
    1486:	7c 01       	movw	r14, r24
    1488:	8b 01       	movw	r16, r22
	uint8_t sp[DS18X20_SP_SIZE];
	uint8_t ret;
	
	ow_reset();
    148a:	a2 d0       	rcall	.+324    	; 0x15d0 <ow_reset>
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
    148c:	49 e0       	ldi	r20, 0x09	; 9
    148e:	be 01       	movw	r22, r28
    1490:	6f 5f       	subi	r22, 0xFF	; 255
    1492:	7f 4f       	sbci	r23, 0xFF	; 255
    1494:	c7 01       	movw	r24, r14
    1496:	80 df       	rcall	.-256    	; 0x1398 <read_scratchpad>
    1498:	e8 2f       	mov	r30, r24
	if ( ret == DS18X20_OK ) {
    149a:	81 11       	cpse	r24, r1
    149c:	64 c0       	rjmp	.+200    	; 0x1566 <DS18X20_read_maxres+0xfc>
{
	uint16_t measure;
	uint8_t  negative;
	int32_t  temperaturevalue;

	measure = sp[0] | (sp[1] << 8);
    149e:	4a 81       	ldd	r20, Y+2	; 0x02
    14a0:	50 e0       	ldi	r21, 0x00	; 0
    14a2:	54 2f       	mov	r21, r20
    14a4:	44 27       	eor	r20, r20
    14a6:	89 81       	ldd	r24, Y+1	; 0x01
    14a8:	48 2b       	or	r20, r24
	//measure = 0xFF5E; // test -10.125
	//measure = 0xFE6F; // test -25.0625

	if( familycode == DS18S20_FAMILY_CODE ) {   // 9 -> 12 bit if 18S20
    14aa:	d7 01       	movw	r26, r14
    14ac:	8c 91       	ld	r24, X
    14ae:	80 31       	cpi	r24, 0x10	; 16
    14b0:	71 f4       	brne	.+28     	; 0x14ce <DS18X20_read_maxres+0x64>
		/* Extended measurements for DS18S20 contributed by Carsten Foss */
		measure &= (uint16_t)0xfffe;   // Discard LSB, needed for later extended precicion calc
    14b2:	4e 7f       	andi	r20, 0xFE	; 254
		measure <<= 3;                 // Convert to 12-bit, now degrees are in 1/16 degrees units
    14b4:	44 0f       	add	r20, r20
    14b6:	55 1f       	adc	r21, r21
    14b8:	44 0f       	add	r20, r20
    14ba:	55 1f       	adc	r21, r21
    14bc:	44 0f       	add	r20, r20
    14be:	55 1f       	adc	r21, r21
		measure += ( 16 - sp[6] ) - 4; // Add the compensation and remember to subtract 0.25 degree (4/16)
    14c0:	2f 81       	ldd	r18, Y+7	; 0x07
    14c2:	8c e0       	ldi	r24, 0x0C	; 12
    14c4:	90 e0       	ldi	r25, 0x00	; 0
    14c6:	82 1b       	sub	r24, r18
    14c8:	91 09       	sbc	r25, r1
    14ca:	48 0f       	add	r20, r24
    14cc:	59 1f       	adc	r21, r25
	}

	// Tarkastetaan onko negatiivinen 
	if ( measure & 0x8000 )  {
    14ce:	55 23       	and	r21, r21
    14d0:	6c f5       	brge	.+90     	; 0x152c <DS18X20_read_maxres+0xc2>
		negative = 1;       // merkataan negatiivinen
		measure ^= 0xffff;  // muunna positiiviseksi => (kahden kómplementti)++
		measure++;
    14d2:	51 95       	neg	r21
    14d4:	41 95       	neg	r20
    14d6:	51 09       	sbc	r21, r1
	}
	else {
		negative = 0;
	}	

	temperaturevalue  = (measure >> 4);
    14d8:	9a 01       	movw	r18, r20
    14da:	32 95       	swap	r19
    14dc:	22 95       	swap	r18
    14de:	2f 70       	andi	r18, 0x0F	; 15
    14e0:	23 27       	eor	r18, r19
    14e2:	3f 70       	andi	r19, 0x0F	; 15
    14e4:	23 27       	eor	r18, r19
	temperaturevalue *= 10000;
    14e6:	a0 e1       	ldi	r26, 0x10	; 16
    14e8:	b7 e2       	ldi	r27, 0x27	; 39
    14ea:	0e 94 18 22 	call	0x4430	; 0x4430 <__umulhisi3>
	temperaturevalue +=( measure & 0x000F ) * DS18X20_FRACCONV;
    14ee:	4f 70       	andi	r20, 0x0F	; 15
    14f0:	55 27       	eor	r21, r21
    14f2:	a1 e7       	ldi	r26, 0x71	; 113
    14f4:	b2 e0       	ldi	r27, 0x02	; 2
    14f6:	4a 9f       	mul	r20, r26
    14f8:	90 01       	movw	r18, r0
    14fa:	4b 9f       	mul	r20, r27
    14fc:	30 0d       	add	r19, r0
    14fe:	5a 9f       	mul	r21, r26
    1500:	30 0d       	add	r19, r0
    1502:	11 24       	eor	r1, r1
    1504:	dc 01       	movw	r26, r24
    1506:	cb 01       	movw	r24, r22
    1508:	82 0f       	add	r24, r18
    150a:	93 1f       	adc	r25, r19
    150c:	a1 1d       	adc	r26, r1
    150e:	b1 1d       	adc	r27, r1

	if ( negative ) {
		temperaturevalue = -temperaturevalue;
    1510:	44 27       	eor	r20, r20
    1512:	55 27       	eor	r21, r21
    1514:	ba 01       	movw	r22, r20
    1516:	48 1b       	sub	r20, r24
    1518:	59 0b       	sbc	r21, r25
    151a:	6a 0b       	sbc	r22, r26
    151c:	7b 0b       	sbc	r23, r27
	uint8_t ret;
	
	ow_reset();
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
	if ( ret == DS18X20_OK ) {
		*temperaturevalue = DS18X20_raw_to_maxres( id[0], sp );
    151e:	d8 01       	movw	r26, r16
    1520:	4d 93       	st	X+, r20
    1522:	5d 93       	st	X+, r21
    1524:	6d 93       	st	X+, r22
    1526:	7c 93       	st	X, r23
    1528:	13 97       	sbiw	r26, 0x03	; 3
	}
	return ret;
    152a:	1d c0       	rjmp	.+58     	; 0x1566 <DS18X20_read_maxres+0xfc>
	}
	else {
		negative = 0;
	}	

	temperaturevalue  = (measure >> 4);
    152c:	9a 01       	movw	r18, r20
    152e:	32 95       	swap	r19
    1530:	22 95       	swap	r18
    1532:	2f 70       	andi	r18, 0x0F	; 15
    1534:	23 27       	eor	r18, r19
    1536:	3f 70       	andi	r19, 0x0F	; 15
    1538:	23 27       	eor	r18, r19
	temperaturevalue *= 10000;
    153a:	a0 e1       	ldi	r26, 0x10	; 16
    153c:	b7 e2       	ldi	r27, 0x27	; 39
    153e:	0e 94 18 22 	call	0x4430	; 0x4430 <__umulhisi3>
	temperaturevalue +=( measure & 0x000F ) * DS18X20_FRACCONV;
    1542:	4f 70       	andi	r20, 0x0F	; 15
    1544:	55 27       	eor	r21, r21
    1546:	a1 e7       	ldi	r26, 0x71	; 113
    1548:	b2 e0       	ldi	r27, 0x02	; 2
    154a:	4a 9f       	mul	r20, r26
    154c:	90 01       	movw	r18, r0
    154e:	4b 9f       	mul	r20, r27
    1550:	30 0d       	add	r19, r0
    1552:	5a 9f       	mul	r21, r26
    1554:	30 0d       	add	r19, r0
    1556:	11 24       	eor	r1, r1
    1558:	ab 01       	movw	r20, r22
    155a:	bc 01       	movw	r22, r24
    155c:	42 0f       	add	r20, r18
    155e:	53 1f       	adc	r21, r19
    1560:	61 1d       	adc	r22, r1
    1562:	71 1d       	adc	r23, r1
    1564:	dc cf       	rjmp	.-72     	; 0x151e <DS18X20_read_maxres+0xb4>
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
	if ( ret == DS18X20_OK ) {
		*temperaturevalue = DS18X20_raw_to_maxres( id[0], sp );
	}
	return ret;
}
    1566:	8e 2f       	mov	r24, r30
    1568:	29 96       	adiw	r28, 0x09	; 9
    156a:	0f b6       	in	r0, 0x3f	; 63
    156c:	f8 94       	cli
    156e:	de bf       	out	0x3e, r29	; 62
    1570:	0f be       	out	0x3f, r0	; 63
    1572:	cd bf       	out	0x3d, r28	; 61
    1574:	df 91       	pop	r29
    1576:	cf 91       	pop	r28
    1578:	1f 91       	pop	r17
    157a:	0f 91       	pop	r16
    157c:	ff 90       	pop	r15
    157e:	ef 90       	pop	r14
    1580:	08 95       	ret

00001582 <ow_input_pin_state>:
	OW_DIR_OUT();
}

void ow_parasite_disable(void)
{
	OW_DIR_IN();
    1582:	8f b1       	in	r24, 0x0f	; 15
    1584:	80 78       	andi	r24, 0x80	; 128
    1586:	08 95       	ret

00001588 <ow_parasite_enable>:
    1588:	8f 9a       	sbi	0x11, 7	; 17
    158a:	87 9a       	sbi	0x10, 7	; 16
    158c:	08 95       	ret

0000158e <ow_bit_io_intern>:
    158e:	cf 93       	push	r28
    1590:	c8 2f       	mov	r28, r24
    1592:	f8 94       	cli
    1594:	87 9a       	sbi	0x10, 7	; 16
    1596:	8a e0       	ldi	r24, 0x0A	; 10
    1598:	8a 95       	dec	r24
    159a:	f1 f7       	brne	.-4      	; 0x1598 <ow_bit_io_intern+0xa>
    159c:	00 c0       	rjmp	.+0      	; 0x159e <ow_bit_io_intern+0x10>
    159e:	c1 11       	cpse	r28, r1
    15a0:	87 98       	cbi	0x10, 7	; 16
    15a2:	85 e4       	ldi	r24, 0x45	; 69
    15a4:	8a 95       	dec	r24
    15a6:	f1 f7       	brne	.-4      	; 0x15a4 <ow_bit_io_intern+0x16>
    15a8:	00 00       	nop
    15aa:	8f b1       	in	r24, 0x0f	; 15
    15ac:	88 0f       	add	r24, r24
    15ae:	88 0b       	sbc	r24, r24
    15b0:	c8 23       	and	r28, r24
    15b2:	85 ee       	ldi	r24, 0xE5	; 229
    15b4:	8a 95       	dec	r24
    15b6:	f1 f7       	brne	.-4      	; 0x15b4 <ow_bit_io_intern+0x26>
    15b8:	00 00       	nop
    15ba:	87 98       	cbi	0x10, 7	; 16
    15bc:	61 11       	cpse	r22, r1
    15be:	e4 df       	rcall	.-56     	; 0x1588 <ow_parasite_enable>
    15c0:	85 e3       	ldi	r24, 0x35	; 53
    15c2:	8a 95       	dec	r24
    15c4:	f1 f7       	brne	.-4      	; 0x15c2 <ow_bit_io_intern+0x34>
    15c6:	00 00       	nop
    15c8:	78 94       	sei
    15ca:	8c 2f       	mov	r24, r28
    15cc:	cf 91       	pop	r28
    15ce:	08 95       	ret

000015d0 <ow_reset>:

uint8_t ow_reset(void)
{
	uint8_t err;
	
	OW_OUT_LOW();
    15d0:	8f 98       	cbi	0x11, 7	; 17
	OW_DIR_OUT();            // Vedetään OW-Pinni alas: 480us
    15d2:	87 9a       	sbi	0x10, 7	; 16
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    15d4:	8f e7       	ldi	r24, 0x7F	; 127
    15d6:	97 e0       	ldi	r25, 0x07	; 7
    15d8:	01 97       	sbiw	r24, 0x01	; 1
    15da:	f1 f7       	brne	.-4      	; 0x15d8 <ow_reset+0x8>
    15dc:	00 c0       	rjmp	.+0      	; 0x15de <ow_reset+0xe>
    15de:	00 00       	nop
	_delay_us(480);

    cli();
    15e0:	f8 94       	cli
	// Asetetaan pinni sisääntuloksi - odotetaan, että orjat vetävät alas
	OW_DIR_IN(); // sisääntulo
    15e2:	87 98       	cbi	0x10, 7	; 16
    15e4:	ef ef       	ldi	r30, 0xFF	; 255
    15e6:	f0 e0       	ldi	r31, 0x00	; 0
    15e8:	31 97       	sbiw	r30, 0x01	; 1
    15ea:	f1 f7       	brne	.-4      	; 0x15e8 <ow_reset+0x18>
    15ec:	00 c0       	rjmp	.+0      	; 0x15ee <ow_reset+0x1e>
    15ee:	00 00       	nop
	
	_delay_us(64);       // was 66
	err = OW_GET_IN();   // ei laitteita havaittu
    15f0:	8f b1       	in	r24, 0x0f	; 15
    15f2:	ef e7       	ldi	r30, 0x7F	; 127
    15f4:	f6 e0       	ldi	r31, 0x06	; 6
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	f1 f7       	brne	.-4      	; 0x15f6 <ow_reset+0x26>
    15fa:	00 c0       	rjmp	.+0      	; 0x15fc <ow_reset+0x2c>
    15fc:	00 00       	nop
	
	// Viiveen jälkeen orjien tulisi vapauttaa linja
	// ja sisääntulo-pinni palaa takaisin ylätilaan ylösvetovastuksen toimesta
	
	_delay_us(480 - 64);       // was 480-66
	if( OW_GET_IN() == 0 ) {
    15fe:	7f 9b       	sbis	0x0f, 7	; 15
    1600:	02 c0       	rjmp	.+4      	; 0x1606 <ow_reset+0x36>
    cli();
	// Asetetaan pinni sisääntuloksi - odotetaan, että orjat vetävät alas
	OW_DIR_IN(); // sisääntulo
	
	_delay_us(64);       // was 66
	err = OW_GET_IN();   // ei laitteita havaittu
    1602:	80 78       	andi	r24, 0x80	; 128
    1604:	01 c0       	rjmp	.+2      	; 0x1608 <ow_reset+0x38>
	// Viiveen jälkeen orjien tulisi vapauttaa linja
	// ja sisääntulo-pinni palaa takaisin ylätilaan ylösvetovastuksen toimesta
	
	_delay_us(480 - 64);       // was 480-66
	if( OW_GET_IN() == 0 ) {
		err = 1;             // short circuit, expected low but got high
    1606:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	sei();
    1608:	78 94       	sei
	return err;
}
    160a:	08 95       	ret

0000160c <ow_bit_io>:
	return b;
}

uint8_t ow_bit_io( uint8_t b )
{
	return ow_bit_io_intern( b & 1, 0 );
    160c:	60 e0       	ldi	r22, 0x00	; 0
    160e:	81 70       	andi	r24, 0x01	; 1
    1610:	be cf       	rjmp	.-132    	; 0x158e <ow_bit_io_intern>
}
    1612:	08 95       	ret

00001614 <ow_byte_wr>:

uint8_t ow_byte_wr( uint8_t b )
{
    1614:	cf 93       	push	r28
    1616:	df 93       	push	r29
    1618:	c8 2f       	mov	r28, r24
    161a:	d8 e0       	ldi	r29, 0x08	; 8
	uint8_t i = 8, j;
	
	do {
		j = ow_bit_io( b & 1 );
    161c:	8c 2f       	mov	r24, r28
    161e:	81 70       	andi	r24, 0x01	; 1
    1620:	f5 df       	rcall	.-22     	; 0x160c <ow_bit_io>
		b >>= 1;
    1622:	c6 95       	lsr	r28
		if( j ) {
    1624:	81 11       	cpse	r24, r1
			b |= 0x80;
    1626:	c0 68       	ori	r28, 0x80	; 128
    1628:	d1 50       	subi	r29, 0x01	; 1
		}
	} while( --i );
    162a:	c1 f7       	brne	.-16     	; 0x161c <ow_byte_wr+0x8>
	
	return b;
}
    162c:	8c 2f       	mov	r24, r28
    162e:	df 91       	pop	r29
    1630:	cf 91       	pop	r28
    1632:	08 95       	ret

00001634 <ow_byte_wr_with_parasite_enable>:

uint8_t ow_byte_wr_with_parasite_enable( uint8_t b )
{
    1634:	cf 93       	push	r28
    1636:	df 93       	push	r29
    1638:	c8 2f       	mov	r28, r24
	uint8_t i = 8, j;
    163a:	d8 e0       	ldi	r29, 0x08	; 8
	
	do {
		if ( i != 1 ) {
    163c:	d1 30       	cpi	r29, 0x01	; 1
    163e:	41 f0       	breq	.+16     	; 0x1650 <ow_byte_wr_with_parasite_enable+0x1c>
			j = ow_bit_io_intern( b & 1, 0 );
    1640:	60 e0       	ldi	r22, 0x00	; 0
    1642:	8c 2f       	mov	r24, r28
    1644:	81 70       	andi	r24, 0x01	; 1
    1646:	a3 df       	rcall	.-186    	; 0x158e <ow_bit_io_intern>
		} else {
			j = ow_bit_io_intern( b & 1, 1 );
		}
		b >>= 1;
    1648:	c6 95       	lsr	r28
		if( j ) {
    164a:	81 11       	cpse	r24, r1
    164c:	08 c0       	rjmp	.+16     	; 0x165e <ow_byte_wr_with_parasite_enable+0x2a>
    164e:	08 c0       	rjmp	.+16     	; 0x1660 <ow_byte_wr_with_parasite_enable+0x2c>
	
	do {
		if ( i != 1 ) {
			j = ow_bit_io_intern( b & 1, 0 );
		} else {
			j = ow_bit_io_intern( b & 1, 1 );
    1650:	61 e0       	ldi	r22, 0x01	; 1
    1652:	8c 2f       	mov	r24, r28
    1654:	81 70       	andi	r24, 0x01	; 1
    1656:	9b df       	rcall	.-202    	; 0x158e <ow_bit_io_intern>
		}
		b >>= 1;
    1658:	c6 95       	lsr	r28
		if( j ) {
    165a:	88 23       	and	r24, r24
    165c:	19 f0       	breq	.+6      	; 0x1664 <ow_byte_wr_with_parasite_enable+0x30>
			b |= 0x80;
    165e:	c0 68       	ori	r28, 0x80	; 128
		}
	} while( --i );
    1660:	d1 50       	subi	r29, 0x01	; 1
    1662:	61 f7       	brne	.-40     	; 0x163c <ow_byte_wr_with_parasite_enable+0x8>
	
	return b;
}
    1664:	8c 2f       	mov	r24, r28
    1666:	df 91       	pop	r29
    1668:	cf 91       	pop	r28
    166a:	08 95       	ret

0000166c <ow_command_intern>:
	return next_diff;                   // jatketaan etsintää
}


static void ow_command_intern( uint8_t command, uint8_t *id, uint8_t with_parasite_enable )
{
    166c:	ef 92       	push	r14
    166e:	ff 92       	push	r15
    1670:	0f 93       	push	r16
    1672:	1f 93       	push	r17
    1674:	cf 93       	push	r28
    1676:	df 93       	push	r29
    1678:	e8 2e       	mov	r14, r24
    167a:	eb 01       	movw	r28, r22
    167c:	f4 2e       	mov	r15, r20
	uint8_t i;

	ow_reset();
    167e:	a8 df       	rcall	.-176    	; 0x15d0 <ow_reset>

	if( id ) {
    1680:	20 97       	sbiw	r28, 0x00	; 0
    1682:	59 f0       	breq	.+22     	; 0x169a <ow_command_intern+0x2e>
		ow_byte_wr( OW_MATCH_ROM );     // yksittäiselle laitteelle, osoitetaan tiettyä anturia
    1684:	85 e5       	ldi	r24, 0x55	; 85
    1686:	c6 df       	rcall	.-116    	; 0x1614 <ow_byte_wr>
    1688:	8e 01       	movw	r16, r28
    168a:	08 5f       	subi	r16, 0xF8	; 248
    168c:	1f 4f       	sbci	r17, 0xFF	; 255
		i = OW_ROMCODE_SIZE;			
		do {
			ow_byte_wr( *id );
    168e:	89 91       	ld	r24, Y+
    1690:	c1 df       	rcall	.-126    	; 0x1614 <ow_byte_wr>
    1692:	c0 17       	cp	r28, r16
			id++;
		} while( --i );
    1694:	d1 07       	cpc	r29, r17
    1696:	d9 f7       	brne	.-10     	; 0x168e <ow_command_intern+0x22>
    1698:	02 c0       	rjmp	.+4      	; 0x169e <ow_command_intern+0x32>
	} 
	else {
		ow_byte_wr( OW_SKIP_ROM );      // kaikille laitteille, säästetään aikaa väylällä, 
    169a:	8c ec       	ldi	r24, 0xCC	; 204
    169c:	bb df       	rcall	.-138    	; 0x1614 <ow_byte_wr>
										// jossa vain yksi anturi
	}									 
	
	if ( with_parasite_enable  ) {
    169e:	ff 20       	and	r15, r15
    16a0:	19 f0       	breq	.+6      	; 0x16a8 <ow_command_intern+0x3c>
		ow_byte_wr_with_parasite_enable( command );
    16a2:	8e 2d       	mov	r24, r14
    16a4:	c7 df       	rcall	.-114    	; 0x1634 <ow_byte_wr_with_parasite_enable>
    16a6:	02 c0       	rjmp	.+4      	; 0x16ac <ow_command_intern+0x40>
	} else {
		ow_byte_wr( command );
    16a8:	8e 2d       	mov	r24, r14
    16aa:	b4 df       	rcall	.-152    	; 0x1614 <ow_byte_wr>
    16ac:	df 91       	pop	r29
	}
}
    16ae:	cf 91       	pop	r28
    16b0:	1f 91       	pop	r17
    16b2:	0f 91       	pop	r16
    16b4:	ff 90       	pop	r15
    16b6:	ef 90       	pop	r14
    16b8:	08 95       	ret

000016ba <ow_byte_rd>:
    16ba:	8f ef       	ldi	r24, 0xFF	; 255

uint8_t ow_byte_rd( void )
{
	// read by sending only "1"s, so bus gets released
	// after the init low-pulse in every slot
	return ow_byte_wr( 0xFF ); 
    16bc:	ab cf       	rjmp	.-170    	; 0x1614 <ow_byte_wr>
}
    16be:	08 95       	ret

000016c0 <ow_rom_search>:


uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
    16c0:	df 92       	push	r13
    16c2:	ef 92       	push	r14
    16c4:	ff 92       	push	r15
    16c6:	0f 93       	push	r16
    16c8:	1f 93       	push	r17
    16ca:	cf 93       	push	r28
    16cc:	df 93       	push	r29
    16ce:	d8 2e       	mov	r13, r24
    16d0:	8b 01       	movw	r16, r22
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) {
    16d2:	7e df       	rcall	.-260    	; 0x15d0 <ow_reset>
    16d4:	81 11       	cpse	r24, r1
    16d6:	28 c0       	rjmp	.+80     	; 0x1728 <ow_rom_search+0x68>
		return OW_PRESENCE_ERR;         // error, no device found <--- early exit!
	}
	
	ow_byte_wr( OW_SEARCH_ROM );        // ROM search komento
    16d8:	80 ef       	ldi	r24, 0xF0	; 240
    16da:	9c df       	rcall	.-200    	; 0x1614 <ow_byte_wr>
	next_diff = OW_LAST_DEVICE;         // unchanged on last device
    16dc:	e1 2c       	mov	r14, r1
	
	i = OW_ROMCODE_SIZE * 8;            // 8 tavua
    16de:	c0 e4       	ldi	r28, 0x40	; 64
    16e0:	0f 2e       	mov	r0, r31
    16e2:	f8 ef       	ldi	r31, 0xF8	; 248
    16e4:	ff 2e       	mov	r15, r31
    16e6:	f0 2d       	mov	r31, r0
	
	do {
		j = 8;                          // 8 bittiä
		do {
			b = ow_bit_io( 1 );         // lue bitti
    16e8:	fc 0e       	add	r15, r28
    16ea:	81 e0       	ldi	r24, 0x01	; 1
    16ec:	8f df       	rcall	.-226    	; 0x160c <ow_bit_io>
			if( ow_bit_io( 1 ) ) {      // lue komplementti bitti
    16ee:	d8 2f       	mov	r29, r24
    16f0:	81 e0       	ldi	r24, 0x01	; 1
    16f2:	8c df       	rcall	.-232    	; 0x160c <ow_bit_io>
    16f4:	88 23       	and	r24, r24
    16f6:	19 f0       	breq	.+6      	; 0x16fe <ow_rom_search+0x3e>
				if( b ) {               // 0b11
    16f8:	dd 23       	and	r29, r29
    16fa:	d1 f0       	breq	.+52     	; 0x1730 <ow_rom_search+0x70>
    16fc:	17 c0       	rjmp	.+46     	; 0x172c <ow_rom_search+0x6c>
					return OW_DATA_ERR; // data error <--- early exit!
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
    16fe:	d1 11       	cpse	r29, r1
    1700:	23 c0       	rjmp	.+70     	; 0x1748 <ow_rom_search+0x88>
					if( diff > i || ((*id & 1) && diff != i) ) {
    1702:	cd 15       	cp	r28, r13
    1704:	e0 f0       	brcs	.+56     	; 0x173e <ow_rom_search+0x7e>
    1706:	f8 01       	movw	r30, r16
    1708:	80 81       	ld	r24, Z
    170a:	80 ff       	sbrs	r24, 0
    170c:	11 c0       	rjmp	.+34     	; 0x1730 <ow_rom_search+0x70>
    170e:	cd 11       	cpse	r28, r13
    1710:	19 c0       	rjmp	.+50     	; 0x1744 <ow_rom_search+0x84>
    1712:	0e c0       	rjmp	.+28     	; 0x1730 <ow_rom_search+0x70>
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
			}
			
			i--;
    1714:	c1 50       	subi	r28, 0x01	; 1
			
		} while( --j );
    1716:	fc 12       	cpse	r15, r28
    1718:	e8 cf       	rjmp	.-48     	; 0x16ea <ow_rom_search+0x2a>
		
		id++;                           // seuraava tavu
    171a:	0f 5f       	subi	r16, 0xFF	; 255
    171c:	1f 4f       	sbci	r17, 0xFF	; 255
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
			}
			
			i--;
    171e:	cf 2d       	mov	r28, r15
			
		} while( --j );
		
		id++;                           // seuraava tavu
	
	} while( i );
    1720:	f1 10       	cpse	r15, r1
    1722:	de cf       	rjmp	.-68     	; 0x16e0 <ow_rom_search+0x20>
    1724:	8e 2d       	mov	r24, r14
    1726:	18 c0       	rjmp	.+48     	; 0x1758 <ow_rom_search+0x98>
{
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) {
		return OW_PRESENCE_ERR;         // error, no device found <--- early exit!
    1728:	8f ef       	ldi	r24, 0xFF	; 255
		j = 8;                          // 8 bittiä
		do {
			b = ow_bit_io( 1 );         // lue bitti
			if( ow_bit_io( 1 ) ) {      // lue komplementti bitti
				if( b ) {               // 0b11
					return OW_DATA_ERR; // data error <--- early exit!
    172a:	16 c0       	rjmp	.+44     	; 0x1758 <ow_rom_search+0x98>
    172c:	8e ef       	ldi	r24, 0xFE	; 254
						b = 1;          // nyt 1
						next_diff = i;  // next pass 0
					}
				}
			}
			ow_bit_io( b );             // kirjoita bitti
    172e:	14 c0       	rjmp	.+40     	; 0x1758 <ow_rom_search+0x98>
    1730:	80 e0       	ldi	r24, 0x00	; 0
    1732:	6c df       	rcall	.-296    	; 0x160c <ow_bit_io>
			*id >>= 1;
    1734:	f8 01       	movw	r30, r16
    1736:	90 81       	ld	r25, Z
    1738:	96 95       	lsr	r25
    173a:	90 83       	st	Z, r25
    173c:	eb cf       	rjmp	.-42     	; 0x1714 <ow_rom_search+0x54>
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
						next_diff = i;  // next pass 0
    173e:	ec 2e       	mov	r14, r28
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
    1740:	d1 e0       	ldi	r29, 0x01	; 1
						next_diff = i;  // next pass 0
    1742:	02 c0       	rjmp	.+4      	; 0x1748 <ow_rom_search+0x88>
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
    1744:	ec 2e       	mov	r14, r28
						next_diff = i;  // next pass 0
					}
				}
			}
			ow_bit_io( b );             // kirjoita bitti
    1746:	d1 e0       	ldi	r29, 0x01	; 1
    1748:	8d 2f       	mov	r24, r29
    174a:	60 df       	rcall	.-320    	; 0x160c <ow_bit_io>
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
    174c:	f8 01       	movw	r30, r16
    174e:	90 81       	ld	r25, Z
    1750:	96 95       	lsr	r25
    1752:	90 68       	ori	r25, 0x80	; 128
    1754:	90 83       	st	Z, r25
    1756:	de cf       	rjmp	.-68     	; 0x1714 <ow_rom_search+0x54>
		id++;                           // seuraava tavu
	
	} while( i );
	
	return next_diff;                   // jatketaan etsintää
}
    1758:	df 91       	pop	r29
    175a:	cf 91       	pop	r28
    175c:	1f 91       	pop	r17
    175e:	0f 91       	pop	r16
    1760:	ff 90       	pop	r15
    1762:	ef 90       	pop	r14
    1764:	df 90       	pop	r13
    1766:	08 95       	ret

00001768 <ow_command>:
	}
}

void ow_command( uint8_t command, uint8_t *id )
{
	ow_command_intern( command, id, 0);
    1768:	40 e0       	ldi	r20, 0x00	; 0
    176a:	80 cf       	rjmp	.-256    	; 0x166c <ow_command_intern>
    176c:	08 95       	ret

0000176e <ow_command_with_parasite_enable>:
}

void ow_command_with_parasite_enable( uint8_t command, uint8_t *id )
{
	ow_command_intern( command, id, 1 );
    176e:	41 e0       	ldi	r20, 0x01	; 1
    1770:	7d cf       	rjmp	.-262    	; 0x166c <ow_command_intern>
    1772:	08 95       	ret

00001774 <search_sensors>:
}

uint8_t search_sensors(void)
{
    1774:	cf 92       	push	r12
    1776:	df 92       	push	r13
    1778:	ff 92       	push	r15
    177a:	0f 93       	push	r16
    177c:	1f 93       	push	r17
    177e:	cf 93       	push	r28
    1780:	df 93       	push	r29
    1782:	cd b7       	in	r28, 0x3d	; 61
    1784:	de b7       	in	r29, 0x3e	; 62
    1786:	29 97       	sbiw	r28, 0x09	; 9
    1788:	0f b6       	in	r0, 0x3f	; 63
    178a:	f8 94       	cli
    178c:	de bf       	out	0x3e, r29	; 62
    178e:	0f be       	out	0x3f, r0	; 63
    1790:	cd bf       	out	0x3d, r28	; 61
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1792:	2f ef       	ldi	r18, 0xFF	; 255
    1794:	89 eb       	ldi	r24, 0xB9	; 185
    1796:	9b ed       	ldi	r25, 0xDB	; 219
    1798:	21 50       	subi	r18, 0x01	; 1
    179a:	80 40       	sbci	r24, 0x00	; 0
    179c:	90 40       	sbci	r25, 0x00	; 0
    179e:	e1 f7       	brne	.-8      	; 0x1798 <search_sensors+0x24>
    17a0:	00 c0       	rjmp	.+0      	; 0x17a2 <search_sensors+0x2e>
    17a2:	00 00       	nop
	uint8_t id[OW_ROMCODE_SIZE];
	uint8_t diff, numberOfSensors;
	
	_delay_ms(1500*3);

	ow_reset();
    17a4:	15 df       	rcall	.-470    	; 0x15d0 <ow_reset>

	numberOfSensors = 0;
	
	diff = OW_SEARCH_FIRST;
    17a6:	8f ef       	ldi	r24, 0xFF	; 255
    17a8:	89 87       	std	Y+9, r24	; 0x09
    17aa:	0f 2e       	mov	r0, r31
    17ac:	f8 e7       	ldi	r31, 0x78	; 120
    17ae:	cf 2e       	mov	r12, r31
    17b0:	f6 e1       	ldi	r31, 0x16	; 22
    17b2:	df 2e       	mov	r13, r31
    17b4:	f0 2d       	mov	r31, r0
    17b6:	f1 2c       	mov	r15, r1
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
		DS18X20_find_sensor( &diff, &id[0] );
    17b8:	8e 01       	movw	r16, r28
    17ba:	07 5f       	subi	r16, 0xF7	; 247
    17bc:	1f 4f       	sbci	r17, 0xFF	; 255
    17be:	be 01       	movw	r22, r28
    17c0:	6f 5f       	subi	r22, 0xFF	; 255
    17c2:	7f 4f       	sbci	r23, 0xFF	; 255
    17c4:	c8 01       	movw	r24, r16
    17c6:	0e de       	rcall	.-996    	; 0x13e4 <DS18X20_find_sensor>
	
		if (diff != OW_PRESENCE_ERR)
    17c8:	99 85       	ldd	r25, Y+9	; 0x09
    17ca:	9f 3f       	cpi	r25, 0xFF	; 255
    17cc:	89 f0       	breq	.+34     	; 0x17f0 <search_sensors+0x7c>
    17ce:	fe 01       	movw	r30, r28
    17d0:	31 96       	adiw	r30, 0x01	; 1
    17d2:	d6 01       	movw	r26, r12
		{
		  for ( i=0; i < OW_ROMCODE_SIZE; i++ )
		    	getSensorIDs[numberOfSensors][i] = id[i];
    17d4:	81 91       	ld	r24, Z+
    17d6:	8d 93       	st	X+, r24
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
		DS18X20_find_sensor( &diff, &id[0] );
	
		if (diff != OW_PRESENCE_ERR)
		{
		  for ( i=0; i < OW_ROMCODE_SIZE; i++ )
    17d8:	e0 17       	cp	r30, r16
    17da:	f1 07       	cpc	r31, r17
    17dc:	d9 f7       	brne	.-10     	; 0x17d4 <search_sensors+0x60>
		    	getSensorIDs[numberOfSensors][i] = id[i];
	  	
		  numberOfSensors++;
    17de:	f3 94       	inc	r15
	ow_reset();

	numberOfSensors = 0;
	
	diff = OW_SEARCH_FIRST;
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
    17e0:	99 23       	and	r25, r25
    17e2:	31 f0       	breq	.+12     	; 0x17f0 <search_sensors+0x7c>
    17e4:	28 e0       	ldi	r18, 0x08	; 8
    17e6:	c2 0e       	add	r12, r18
    17e8:	d1 1c       	adc	r13, r1
    17ea:	88 e0       	ldi	r24, 0x08	; 8
    17ec:	f8 12       	cpse	r15, r24
    17ee:	e7 cf       	rjmp	.-50     	; 0x17be <search_sensors+0x4a>
		else
		  break;
	}
	
	return numberOfSensors;
}
    17f0:	8f 2d       	mov	r24, r15
    17f2:	29 96       	adiw	r28, 0x09	; 9
    17f4:	0f b6       	in	r0, 0x3f	; 63
    17f6:	f8 94       	cli
    17f8:	de bf       	out	0x3e, r29	; 62
    17fa:	0f be       	out	0x3f, r0	; 63
    17fc:	cd bf       	out	0x3d, r28	; 61
    17fe:	df 91       	pop	r29
    1800:	cf 91       	pop	r28
    1802:	1f 91       	pop	r17
    1804:	0f 91       	pop	r16
    1806:	ff 90       	pop	r15
    1808:	df 90       	pop	r13
    180a:	cf 90       	pop	r12
    180c:	08 95       	ret

0000180e <GetSensorCount>:

unsigned char GetSensorCount(void)
{
  return search_sensors();
    180e:	b2 cf       	rjmp	.-156    	; 0x1774 <search_sensors>
}
    1810:	08 95       	ret

00001812 <GetTemperature>:

long    GetTemperature( unsigned nSensor)
{ long temperature;
    1812:	0f 93       	push	r16
    1814:	1f 93       	push	r17
    1816:	cf 93       	push	r28
    1818:	df 93       	push	r29
    181a:	00 d0       	rcall	.+0      	; 0x181c <GetTemperature+0xa>
    181c:	1f 92       	push	r1
    181e:	cd b7       	in	r28, 0x3d	; 61
    1820:	de b7       	in	r29, 0x3e	; 62
    1822:	8c 01       	movw	r16, r24
   
   DS18X20_start_meas( DS18X20_POWER_PARASITE, NULL );
    1824:	60 e0       	ldi	r22, 0x00	; 0
    1826:	70 e0       	ldi	r23, 0x00	; 0
    1828:	80 e0       	ldi	r24, 0x00	; 0
    182a:	fd dd       	rcall	.-1030   	; 0x1426 <DS18X20_start_meas>
    182c:	2f ef       	ldi	r18, 0xFF	; 255
    182e:	8e e9       	ldi	r24, 0x9E	; 158
    1830:	94 e2       	ldi	r25, 0x24	; 36
    1832:	21 50       	subi	r18, 0x01	; 1
    1834:	80 40       	sbci	r24, 0x00	; 0
    1836:	90 40       	sbci	r25, 0x00	; 0
    1838:	e1 f7       	brne	.-8      	; 0x1832 <GetTemperature+0x20>
    183a:	00 c0       	rjmp	.+0      	; 0x183c <GetTemperature+0x2a>
    183c:	00 00       	nop
	  
   _delay_ms( DS18B20_TCONV_12BIT );

   DS18X20_read_maxres( &getSensorIDs[nSensor][0], &temperature );
    183e:	c8 01       	movw	r24, r16
    1840:	88 0f       	add	r24, r24
    1842:	99 1f       	adc	r25, r25
    1844:	88 0f       	add	r24, r24
    1846:	99 1f       	adc	r25, r25
    1848:	88 0f       	add	r24, r24
    184a:	99 1f       	adc	r25, r25
    184c:	be 01       	movw	r22, r28
    184e:	6f 5f       	subi	r22, 0xFF	; 255
    1850:	7f 4f       	sbci	r23, 0xFF	; 255
    1852:	88 58       	subi	r24, 0x88	; 136
    1854:	99 4e       	sbci	r25, 0xE9	; 233
    1856:	09 de       	rcall	.-1006   	; 0x146a <DS18X20_read_maxres>
   return temperature;
    1858:	69 81       	ldd	r22, Y+1	; 0x01
    185a:	7a 81       	ldd	r23, Y+2	; 0x02
    185c:	8b 81       	ldd	r24, Y+3	; 0x03
    185e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1860:	0f 90       	pop	r0
    1862:	0f 90       	pop	r0
    1864:	0f 90       	pop	r0
    1866:	0f 90       	pop	r0
    1868:	df 91       	pop	r29
    186a:	cf 91       	pop	r28
    186c:	1f 91       	pop	r17
    186e:	0f 91       	pop	r16
    1870:	08 95       	ret

00001872 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1872:	cf 93       	push	r28
    1874:	df 93       	push	r29
    1876:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1878:	0e 94 6b 17 	call	0x2ed6	; 0x2ed6 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    187c:	80 91 ee 03 	lds	r24, 0x03EE	; 0x8003ee <pucAlignedHeap.2023>
    1880:	90 91 ef 03 	lds	r25, 0x03EF	; 0x8003ef <pucAlignedHeap.2023+0x1>
    1884:	89 2b       	or	r24, r25
    1886:	31 f4       	brne	.+12     	; 0x1894 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1888:	83 ef       	ldi	r24, 0xF3	; 243
    188a:	93 e0       	ldi	r25, 0x03	; 3
    188c:	90 93 ef 03 	sts	0x03EF, r25	; 0x8003ef <pucAlignedHeap.2023+0x1>
    1890:	80 93 ee 03 	sts	0x03EE, r24	; 0x8003ee <pucAlignedHeap.2023>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1894:	20 91 f0 03 	lds	r18, 0x03F0	; 0x8003f0 <xNextFreeByte>
    1898:	30 91 f1 03 	lds	r19, 0x03F1	; 0x8003f1 <xNextFreeByte+0x1>
    189c:	c9 01       	movw	r24, r18
    189e:	8c 0f       	add	r24, r28
    18a0:	9d 1f       	adc	r25, r29
    18a2:	8f 3f       	cpi	r24, 0xFF	; 255
    18a4:	41 e1       	ldi	r20, 0x11	; 17
    18a6:	94 07       	cpc	r25, r20
    18a8:	70 f4       	brcc	.+28     	; 0x18c6 <pvPortMalloc+0x54>
    18aa:	28 17       	cp	r18, r24
    18ac:	39 07       	cpc	r19, r25
    18ae:	70 f4       	brcc	.+28     	; 0x18cc <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    18b0:	c0 91 ee 03 	lds	r28, 0x03EE	; 0x8003ee <pucAlignedHeap.2023>
    18b4:	d0 91 ef 03 	lds	r29, 0x03EF	; 0x8003ef <pucAlignedHeap.2023+0x1>
    18b8:	c2 0f       	add	r28, r18
    18ba:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    18bc:	90 93 f1 03 	sts	0x03F1, r25	; 0x8003f1 <xNextFreeByte+0x1>
    18c0:	80 93 f0 03 	sts	0x03F0, r24	; 0x8003f0 <xNextFreeByte>
    18c4:	05 c0       	rjmp	.+10     	; 0x18d0 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    18c6:	c0 e0       	ldi	r28, 0x00	; 0
    18c8:	d0 e0       	ldi	r29, 0x00	; 0
    18ca:	02 c0       	rjmp	.+4      	; 0x18d0 <pvPortMalloc+0x5e>
    18cc:	c0 e0       	ldi	r28, 0x00	; 0
    18ce:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    18d0:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    18d4:	ce 01       	movw	r24, r28
    18d6:	df 91       	pop	r29
    18d8:	cf 91       	pop	r28
    18da:	08 95       	ret

000018dc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    18dc:	08 95       	ret

000018de <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    18de:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18e0:	03 96       	adiw	r24, 0x03	; 3
    18e2:	92 83       	std	Z+2, r25	; 0x02
    18e4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    18e6:	2f ef       	ldi	r18, 0xFF	; 255
    18e8:	3f ef       	ldi	r19, 0xFF	; 255
    18ea:	34 83       	std	Z+4, r19	; 0x04
    18ec:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18ee:	96 83       	std	Z+6, r25	; 0x06
    18f0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18f2:	90 87       	std	Z+8, r25	; 0x08
    18f4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    18f6:	10 82       	st	Z, r1
    18f8:	08 95       	ret

000018fa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    18fa:	fc 01       	movw	r30, r24
    18fc:	11 86       	std	Z+9, r1	; 0x09
    18fe:	10 86       	std	Z+8, r1	; 0x08
    1900:	08 95       	ret

00001902 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1902:	cf 93       	push	r28
    1904:	df 93       	push	r29
    1906:	9c 01       	movw	r18, r24
    1908:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    190a:	dc 01       	movw	r26, r24
    190c:	11 96       	adiw	r26, 0x01	; 1
    190e:	cd 91       	ld	r28, X+
    1910:	dc 91       	ld	r29, X
    1912:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1914:	d3 83       	std	Z+3, r29	; 0x03
    1916:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1918:	8c 81       	ldd	r24, Y+4	; 0x04
    191a:	9d 81       	ldd	r25, Y+5	; 0x05
    191c:	95 83       	std	Z+5, r25	; 0x05
    191e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1920:	8c 81       	ldd	r24, Y+4	; 0x04
    1922:	9d 81       	ldd	r25, Y+5	; 0x05
    1924:	dc 01       	movw	r26, r24
    1926:	13 96       	adiw	r26, 0x03	; 3
    1928:	7c 93       	st	X, r23
    192a:	6e 93       	st	-X, r22
    192c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    192e:	7d 83       	std	Y+5, r23	; 0x05
    1930:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1932:	31 87       	std	Z+9, r19	; 0x09
    1934:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1936:	f9 01       	movw	r30, r18
    1938:	80 81       	ld	r24, Z
    193a:	8f 5f       	subi	r24, 0xFF	; 255
    193c:	80 83       	st	Z, r24
}
    193e:	df 91       	pop	r29
    1940:	cf 91       	pop	r28
    1942:	08 95       	ret

00001944 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1944:	cf 93       	push	r28
    1946:	df 93       	push	r29
    1948:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    194a:	48 81       	ld	r20, Y
    194c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    194e:	4f 3f       	cpi	r20, 0xFF	; 255
    1950:	2f ef       	ldi	r18, 0xFF	; 255
    1952:	52 07       	cpc	r21, r18
    1954:	21 f4       	brne	.+8      	; 0x195e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1956:	fc 01       	movw	r30, r24
    1958:	a7 81       	ldd	r26, Z+7	; 0x07
    195a:	b0 85       	ldd	r27, Z+8	; 0x08
    195c:	0d c0       	rjmp	.+26     	; 0x1978 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    195e:	dc 01       	movw	r26, r24
    1960:	13 96       	adiw	r26, 0x03	; 3
    1962:	01 c0       	rjmp	.+2      	; 0x1966 <vListInsert+0x22>
    1964:	df 01       	movw	r26, r30
    1966:	12 96       	adiw	r26, 0x02	; 2
    1968:	ed 91       	ld	r30, X+
    196a:	fc 91       	ld	r31, X
    196c:	13 97       	sbiw	r26, 0x03	; 3
    196e:	20 81       	ld	r18, Z
    1970:	31 81       	ldd	r19, Z+1	; 0x01
    1972:	42 17       	cp	r20, r18
    1974:	53 07       	cpc	r21, r19
    1976:	b0 f7       	brcc	.-20     	; 0x1964 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1978:	12 96       	adiw	r26, 0x02	; 2
    197a:	ed 91       	ld	r30, X+
    197c:	fc 91       	ld	r31, X
    197e:	13 97       	sbiw	r26, 0x03	; 3
    1980:	fb 83       	std	Y+3, r31	; 0x03
    1982:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1984:	d5 83       	std	Z+5, r29	; 0x05
    1986:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1988:	bd 83       	std	Y+5, r27	; 0x05
    198a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    198c:	13 96       	adiw	r26, 0x03	; 3
    198e:	dc 93       	st	X, r29
    1990:	ce 93       	st	-X, r28
    1992:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1994:	99 87       	std	Y+9, r25	; 0x09
    1996:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1998:	fc 01       	movw	r30, r24
    199a:	20 81       	ld	r18, Z
    199c:	2f 5f       	subi	r18, 0xFF	; 255
    199e:	20 83       	st	Z, r18
}
    19a0:	df 91       	pop	r29
    19a2:	cf 91       	pop	r28
    19a4:	08 95       	ret

000019a6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29
    19aa:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    19ac:	a0 85       	ldd	r26, Z+8	; 0x08
    19ae:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    19b0:	c2 81       	ldd	r28, Z+2	; 0x02
    19b2:	d3 81       	ldd	r29, Z+3	; 0x03
    19b4:	84 81       	ldd	r24, Z+4	; 0x04
    19b6:	95 81       	ldd	r25, Z+5	; 0x05
    19b8:	9d 83       	std	Y+5, r25	; 0x05
    19ba:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    19bc:	c4 81       	ldd	r28, Z+4	; 0x04
    19be:	d5 81       	ldd	r29, Z+5	; 0x05
    19c0:	82 81       	ldd	r24, Z+2	; 0x02
    19c2:	93 81       	ldd	r25, Z+3	; 0x03
    19c4:	9b 83       	std	Y+3, r25	; 0x03
    19c6:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    19c8:	11 96       	adiw	r26, 0x01	; 1
    19ca:	8d 91       	ld	r24, X+
    19cc:	9c 91       	ld	r25, X
    19ce:	12 97       	sbiw	r26, 0x02	; 2
    19d0:	e8 17       	cp	r30, r24
    19d2:	f9 07       	cpc	r31, r25
    19d4:	31 f4       	brne	.+12     	; 0x19e2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    19d6:	84 81       	ldd	r24, Z+4	; 0x04
    19d8:	95 81       	ldd	r25, Z+5	; 0x05
    19da:	12 96       	adiw	r26, 0x02	; 2
    19dc:	9c 93       	st	X, r25
    19de:	8e 93       	st	-X, r24
    19e0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    19e2:	11 86       	std	Z+9, r1	; 0x09
    19e4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    19e6:	8c 91       	ld	r24, X
    19e8:	81 50       	subi	r24, 0x01	; 1
    19ea:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    19ec:	df 91       	pop	r29
    19ee:	cf 91       	pop	r28
    19f0:	08 95       	ret

000019f2 <pxPortInitialiseStack>:

#elif defined( portUSE_TIMER0 )
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts

#elif defined( portUSE_TIMER1 )
	portTIMSK &= ~( _BV(OCIE1B)|_BV(OCIE1A)|_BV(TOIE1) );	// disable all Timer1 interrupts
    19f2:	31 e1       	ldi	r19, 0x11	; 17
    19f4:	fc 01       	movw	r30, r24
    19f6:	30 83       	st	Z, r19
    19f8:	31 97       	sbiw	r30, 0x01	; 1
    19fa:	22 e2       	ldi	r18, 0x22	; 34
    19fc:	20 83       	st	Z, r18
    19fe:	31 97       	sbiw	r30, 0x01	; 1
    1a00:	a3 e3       	ldi	r26, 0x33	; 51
    1a02:	a0 83       	st	Z, r26
    1a04:	31 97       	sbiw	r30, 0x01	; 1
    1a06:	60 83       	st	Z, r22
    1a08:	31 97       	sbiw	r30, 0x01	; 1
    1a0a:	70 83       	st	Z, r23
    1a0c:	31 97       	sbiw	r30, 0x01	; 1
    1a0e:	10 82       	st	Z, r1
    1a10:	31 97       	sbiw	r30, 0x01	; 1
    1a12:	10 82       	st	Z, r1
    1a14:	31 97       	sbiw	r30, 0x01	; 1
    1a16:	60 e8       	ldi	r22, 0x80	; 128
    1a18:	60 83       	st	Z, r22
    1a1a:	31 97       	sbiw	r30, 0x01	; 1
    1a1c:	10 82       	st	Z, r1
    1a1e:	31 97       	sbiw	r30, 0x01	; 1
    1a20:	10 82       	st	Z, r1
    1a22:	31 97       	sbiw	r30, 0x01	; 1
    1a24:	10 82       	st	Z, r1
    1a26:	31 97       	sbiw	r30, 0x01	; 1
    1a28:	62 e0       	ldi	r22, 0x02	; 2
    1a2a:	60 83       	st	Z, r22
    1a2c:	31 97       	sbiw	r30, 0x01	; 1
    1a2e:	63 e0       	ldi	r22, 0x03	; 3
    1a30:	60 83       	st	Z, r22
    1a32:	31 97       	sbiw	r30, 0x01	; 1
    1a34:	64 e0       	ldi	r22, 0x04	; 4
    1a36:	60 83       	st	Z, r22
    1a38:	31 97       	sbiw	r30, 0x01	; 1
    1a3a:	65 e0       	ldi	r22, 0x05	; 5
    1a3c:	60 83       	st	Z, r22
    1a3e:	31 97       	sbiw	r30, 0x01	; 1
    1a40:	66 e0       	ldi	r22, 0x06	; 6
    1a42:	60 83       	st	Z, r22
    1a44:	31 97       	sbiw	r30, 0x01	; 1
    1a46:	67 e0       	ldi	r22, 0x07	; 7
    1a48:	60 83       	st	Z, r22
    1a4a:	31 97       	sbiw	r30, 0x01	; 1
    1a4c:	68 e0       	ldi	r22, 0x08	; 8
    1a4e:	60 83       	st	Z, r22
    1a50:	31 97       	sbiw	r30, 0x01	; 1
    1a52:	69 e0       	ldi	r22, 0x09	; 9
    1a54:	60 83       	st	Z, r22
    1a56:	31 97       	sbiw	r30, 0x01	; 1
    1a58:	60 e1       	ldi	r22, 0x10	; 16
    1a5a:	60 83       	st	Z, r22
    1a5c:	31 97       	sbiw	r30, 0x01	; 1
    1a5e:	30 83       	st	Z, r19
    1a60:	31 97       	sbiw	r30, 0x01	; 1
    1a62:	32 e1       	ldi	r19, 0x12	; 18
    1a64:	30 83       	st	Z, r19
    1a66:	31 97       	sbiw	r30, 0x01	; 1
    1a68:	33 e1       	ldi	r19, 0x13	; 19
    1a6a:	30 83       	st	Z, r19
    1a6c:	31 97       	sbiw	r30, 0x01	; 1
    1a6e:	34 e1       	ldi	r19, 0x14	; 20
    1a70:	30 83       	st	Z, r19
    1a72:	31 97       	sbiw	r30, 0x01	; 1
    1a74:	35 e1       	ldi	r19, 0x15	; 21
    1a76:	30 83       	st	Z, r19
    1a78:	31 97       	sbiw	r30, 0x01	; 1
    1a7a:	36 e1       	ldi	r19, 0x16	; 22
    1a7c:	30 83       	st	Z, r19
    1a7e:	31 97       	sbiw	r30, 0x01	; 1
    1a80:	37 e1       	ldi	r19, 0x17	; 23
    1a82:	30 83       	st	Z, r19
    1a84:	31 97       	sbiw	r30, 0x01	; 1
    1a86:	38 e1       	ldi	r19, 0x18	; 24
    1a88:	30 83       	st	Z, r19
    1a8a:	31 97       	sbiw	r30, 0x01	; 1
    1a8c:	39 e1       	ldi	r19, 0x19	; 25
    1a8e:	30 83       	st	Z, r19
    1a90:	31 97       	sbiw	r30, 0x01	; 1
    1a92:	30 e2       	ldi	r19, 0x20	; 32
    1a94:	30 83       	st	Z, r19
    1a96:	31 97       	sbiw	r30, 0x01	; 1
    1a98:	31 e2       	ldi	r19, 0x21	; 33
    1a9a:	30 83       	st	Z, r19
    1a9c:	31 97       	sbiw	r30, 0x01	; 1
    1a9e:	20 83       	st	Z, r18
    1aa0:	31 97       	sbiw	r30, 0x01	; 1
    1aa2:	23 e2       	ldi	r18, 0x23	; 35
    1aa4:	20 83       	st	Z, r18
    1aa6:	31 97       	sbiw	r30, 0x01	; 1
    1aa8:	40 83       	st	Z, r20
    1aaa:	31 97       	sbiw	r30, 0x01	; 1
    1aac:	50 83       	st	Z, r21
    1aae:	31 97       	sbiw	r30, 0x01	; 1
    1ab0:	26 e2       	ldi	r18, 0x26	; 38
    1ab2:	20 83       	st	Z, r18
    1ab4:	31 97       	sbiw	r30, 0x01	; 1
    1ab6:	27 e2       	ldi	r18, 0x27	; 39
    1ab8:	20 83       	st	Z, r18
    1aba:	31 97       	sbiw	r30, 0x01	; 1
    1abc:	28 e2       	ldi	r18, 0x28	; 40
    1abe:	20 83       	st	Z, r18
    1ac0:	31 97       	sbiw	r30, 0x01	; 1
    1ac2:	29 e2       	ldi	r18, 0x29	; 41
    1ac4:	20 83       	st	Z, r18
    1ac6:	31 97       	sbiw	r30, 0x01	; 1
    1ac8:	20 e3       	ldi	r18, 0x30	; 48
    1aca:	20 83       	st	Z, r18
    1acc:	31 97       	sbiw	r30, 0x01	; 1
    1ace:	21 e3       	ldi	r18, 0x31	; 49
    1ad0:	20 83       	st	Z, r18
    1ad2:	89 97       	sbiw	r24, 0x29	; 41
    1ad4:	08 95       	ret

00001ad6 <xPortStartScheduler>:
    1ad6:	88 ec       	ldi	r24, 0xC8	; 200
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	90 93 b9 16 	sts	0x16B9, r25	; 0x8016b9 <portTickRateHz+0x1>
    1ade:	80 93 b8 16 	sts	0x16B8, r24	; 0x8016b8 <portTickRateHz>
    1ae2:	90 93 bb 16 	sts	0x16BB, r25	; 0x8016bb <ticksRemainingInSec+0x1>
    1ae6:	80 93 ba 16 	sts	0x16BA, r24	; 0x8016ba <ticksRemainingInSec>
    1aea:	84 e0       	ldi	r24, 0x04	; 4
    1aec:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1af0:	81 ee       	ldi	r24, 0xE1	; 225
    1af2:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    1af6:	8b e0       	ldi	r24, 0x0B	; 11
    1af8:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    1afc:	ef e6       	ldi	r30, 0x6F	; 111
    1afe:	f0 e0       	ldi	r31, 0x00	; 0
    1b00:	80 81       	ld	r24, Z
    1b02:	82 60       	ori	r24, 0x02	; 2
    1b04:	80 83       	st	Z, r24
    1b06:	a0 91 54 16 	lds	r26, 0x1654	; 0x801654 <pxCurrentTCB>
    1b0a:	b0 91 55 16 	lds	r27, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    1b0e:	cd 91       	ld	r28, X+
    1b10:	cd bf       	out	0x3d, r28	; 61
    1b12:	dd 91       	ld	r29, X+
    1b14:	de bf       	out	0x3e, r29	; 62
    1b16:	ff 91       	pop	r31
    1b18:	ef 91       	pop	r30
    1b1a:	df 91       	pop	r29
    1b1c:	cf 91       	pop	r28
    1b1e:	bf 91       	pop	r27
    1b20:	af 91       	pop	r26
    1b22:	9f 91       	pop	r25
    1b24:	8f 91       	pop	r24
    1b26:	7f 91       	pop	r23
    1b28:	6f 91       	pop	r22
    1b2a:	5f 91       	pop	r21
    1b2c:	4f 91       	pop	r20
    1b2e:	3f 91       	pop	r19
    1b30:	2f 91       	pop	r18
    1b32:	1f 91       	pop	r17
    1b34:	0f 91       	pop	r16
    1b36:	ff 90       	pop	r15
    1b38:	ef 90       	pop	r14
    1b3a:	df 90       	pop	r13
    1b3c:	cf 90       	pop	r12
    1b3e:	bf 90       	pop	r11
    1b40:	af 90       	pop	r10
    1b42:	9f 90       	pop	r9
    1b44:	8f 90       	pop	r8
    1b46:	7f 90       	pop	r7
    1b48:	6f 90       	pop	r6
    1b4a:	5f 90       	pop	r5
    1b4c:	4f 90       	pop	r4
    1b4e:	3f 90       	pop	r3
    1b50:	2f 90       	pop	r2
    1b52:	1f 90       	pop	r1
    1b54:	0f 90       	pop	r0
    1b56:	0c be       	out	0x3c, r0	; 60
    1b58:	0f 90       	pop	r0
    1b5a:	0b be       	out	0x3b, r0	; 59
    1b5c:	0f 90       	pop	r0
    1b5e:	0f be       	out	0x3f, r0	; 63
    1b60:	0f 90       	pop	r0
    1b62:	08 95       	ret
    1b64:	81 e0       	ldi	r24, 0x01	; 1
    1b66:	08 95       	ret

00001b68 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1b68:	0f 92       	push	r0
    1b6a:	0f b6       	in	r0, 0x3f	; 63
    1b6c:	f8 94       	cli
    1b6e:	0f 92       	push	r0
    1b70:	0b b6       	in	r0, 0x3b	; 59
    1b72:	0f 92       	push	r0
    1b74:	0c b6       	in	r0, 0x3c	; 60
    1b76:	0f 92       	push	r0
    1b78:	1f 92       	push	r1
    1b7a:	11 24       	eor	r1, r1
    1b7c:	2f 92       	push	r2
    1b7e:	3f 92       	push	r3
    1b80:	4f 92       	push	r4
    1b82:	5f 92       	push	r5
    1b84:	6f 92       	push	r6
    1b86:	7f 92       	push	r7
    1b88:	8f 92       	push	r8
    1b8a:	9f 92       	push	r9
    1b8c:	af 92       	push	r10
    1b8e:	bf 92       	push	r11
    1b90:	cf 92       	push	r12
    1b92:	df 92       	push	r13
    1b94:	ef 92       	push	r14
    1b96:	ff 92       	push	r15
    1b98:	0f 93       	push	r16
    1b9a:	1f 93       	push	r17
    1b9c:	2f 93       	push	r18
    1b9e:	3f 93       	push	r19
    1ba0:	4f 93       	push	r20
    1ba2:	5f 93       	push	r21
    1ba4:	6f 93       	push	r22
    1ba6:	7f 93       	push	r23
    1ba8:	8f 93       	push	r24
    1baa:	9f 93       	push	r25
    1bac:	af 93       	push	r26
    1bae:	bf 93       	push	r27
    1bb0:	cf 93       	push	r28
    1bb2:	df 93       	push	r29
    1bb4:	ef 93       	push	r30
    1bb6:	ff 93       	push	r31
    1bb8:	a0 91 54 16 	lds	r26, 0x1654	; 0x801654 <pxCurrentTCB>
    1bbc:	b0 91 55 16 	lds	r27, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    1bc0:	0d b6       	in	r0, 0x3d	; 61
    1bc2:	0d 92       	st	X+, r0
    1bc4:	0e b6       	in	r0, 0x3e	; 62
    1bc6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1bc8:	0e 94 9e 19 	call	0x333c	; 0x333c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1bcc:	a0 91 54 16 	lds	r26, 0x1654	; 0x801654 <pxCurrentTCB>
    1bd0:	b0 91 55 16 	lds	r27, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    1bd4:	cd 91       	ld	r28, X+
    1bd6:	cd bf       	out	0x3d, r28	; 61
    1bd8:	dd 91       	ld	r29, X+
    1bda:	de bf       	out	0x3e, r29	; 62
    1bdc:	ff 91       	pop	r31
    1bde:	ef 91       	pop	r30
    1be0:	df 91       	pop	r29
    1be2:	cf 91       	pop	r28
    1be4:	bf 91       	pop	r27
    1be6:	af 91       	pop	r26
    1be8:	9f 91       	pop	r25
    1bea:	8f 91       	pop	r24
    1bec:	7f 91       	pop	r23
    1bee:	6f 91       	pop	r22
    1bf0:	5f 91       	pop	r21
    1bf2:	4f 91       	pop	r20
    1bf4:	3f 91       	pop	r19
    1bf6:	2f 91       	pop	r18
    1bf8:	1f 91       	pop	r17
    1bfa:	0f 91       	pop	r16
    1bfc:	ff 90       	pop	r15
    1bfe:	ef 90       	pop	r14
    1c00:	df 90       	pop	r13
    1c02:	cf 90       	pop	r12
    1c04:	bf 90       	pop	r11
    1c06:	af 90       	pop	r10
    1c08:	9f 90       	pop	r9
    1c0a:	8f 90       	pop	r8
    1c0c:	7f 90       	pop	r7
    1c0e:	6f 90       	pop	r6
    1c10:	5f 90       	pop	r5
    1c12:	4f 90       	pop	r4
    1c14:	3f 90       	pop	r3
    1c16:	2f 90       	pop	r2
    1c18:	1f 90       	pop	r1
    1c1a:	0f 90       	pop	r0
    1c1c:	0c be       	out	0x3c, r0	; 60
    1c1e:	0f 90       	pop	r0
    1c20:	0b be       	out	0x3b, r0	; 59
    1c22:	0f 90       	pop	r0
    1c24:	0f be       	out	0x3f, r0	; 63
    1c26:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1c28:	08 95       	ret

00001c2a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c2a:	0f 92       	push	r0
    1c2c:	0f b6       	in	r0, 0x3f	; 63
    1c2e:	f8 94       	cli
    1c30:	0f 92       	push	r0
    1c32:	0b b6       	in	r0, 0x3b	; 59
    1c34:	0f 92       	push	r0
    1c36:	0c b6       	in	r0, 0x3c	; 60
    1c38:	0f 92       	push	r0
    1c3a:	1f 92       	push	r1
    1c3c:	11 24       	eor	r1, r1
    1c3e:	2f 92       	push	r2
    1c40:	3f 92       	push	r3
    1c42:	4f 92       	push	r4
    1c44:	5f 92       	push	r5
    1c46:	6f 92       	push	r6
    1c48:	7f 92       	push	r7
    1c4a:	8f 92       	push	r8
    1c4c:	9f 92       	push	r9
    1c4e:	af 92       	push	r10
    1c50:	bf 92       	push	r11
    1c52:	cf 92       	push	r12
    1c54:	df 92       	push	r13
    1c56:	ef 92       	push	r14
    1c58:	ff 92       	push	r15
    1c5a:	0f 93       	push	r16
    1c5c:	1f 93       	push	r17
    1c5e:	2f 93       	push	r18
    1c60:	3f 93       	push	r19
    1c62:	4f 93       	push	r20
    1c64:	5f 93       	push	r21
    1c66:	6f 93       	push	r22
    1c68:	7f 93       	push	r23
    1c6a:	8f 93       	push	r24
    1c6c:	9f 93       	push	r25
    1c6e:	af 93       	push	r26
    1c70:	bf 93       	push	r27
    1c72:	cf 93       	push	r28
    1c74:	df 93       	push	r29
    1c76:	ef 93       	push	r30
    1c78:	ff 93       	push	r31
    1c7a:	a0 91 54 16 	lds	r26, 0x1654	; 0x801654 <pxCurrentTCB>
    1c7e:	b0 91 55 16 	lds	r27, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    1c82:	0d b6       	in	r0, 0x3d	; 61
    1c84:	0d 92       	st	X+, r0
    1c86:	0e b6       	in	r0, 0x3e	; 62
    1c88:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    1c8a:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    1c8c:	80 91 ba 16 	lds	r24, 0x16BA	; 0x8016ba <ticksRemainingInSec>
    1c90:	90 91 bb 16 	lds	r25, 0x16BB	; 0x8016bb <ticksRemainingInSec+0x1>
    1c94:	01 97       	sbiw	r24, 0x01	; 1
    1c96:	90 93 bb 16 	sts	0x16BB, r25	; 0x8016bb <ticksRemainingInSec+0x1>
    1c9a:	80 93 ba 16 	sts	0x16BA, r24	; 0x8016ba <ticksRemainingInSec>
    1c9e:	89 2b       	or	r24, r25
    1ca0:	51 f4       	brne	.+20     	; 0x1cb6 <vPortYieldFromTick+0x8c>
	{
		system_tick();
    1ca2:	0e 94 15 02 	call	0x42a	; 0x42a <system_tick>
		ticksRemainingInSec = portTickRateHz;
    1ca6:	80 91 b8 16 	lds	r24, 0x16B8	; 0x8016b8 <portTickRateHz>
    1caa:	90 91 b9 16 	lds	r25, 0x16B9	; 0x8016b9 <portTickRateHz+0x1>
    1cae:	90 93 bb 16 	sts	0x16BB, r25	; 0x8016bb <ticksRemainingInSec+0x1>
    1cb2:	80 93 ba 16 	sts	0x16BA, r24	; 0x8016ba <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    1cb6:	0e 94 c5 18 	call	0x318a	; 0x318a <xTaskIncrementTick>
    1cba:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1cbc:	0e 94 9e 19 	call	0x333c	; 0x333c <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    1cc0:	a0 91 54 16 	lds	r26, 0x1654	; 0x801654 <pxCurrentTCB>
    1cc4:	b0 91 55 16 	lds	r27, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    1cc8:	cd 91       	ld	r28, X+
    1cca:	cd bf       	out	0x3d, r28	; 61
    1ccc:	dd 91       	ld	r29, X+
    1cce:	de bf       	out	0x3e, r29	; 62
    1cd0:	ff 91       	pop	r31
    1cd2:	ef 91       	pop	r30
    1cd4:	df 91       	pop	r29
    1cd6:	cf 91       	pop	r28
    1cd8:	bf 91       	pop	r27
    1cda:	af 91       	pop	r26
    1cdc:	9f 91       	pop	r25
    1cde:	8f 91       	pop	r24
    1ce0:	7f 91       	pop	r23
    1ce2:	6f 91       	pop	r22
    1ce4:	5f 91       	pop	r21
    1ce6:	4f 91       	pop	r20
    1ce8:	3f 91       	pop	r19
    1cea:	2f 91       	pop	r18
    1cec:	1f 91       	pop	r17
    1cee:	0f 91       	pop	r16
    1cf0:	ff 90       	pop	r15
    1cf2:	ef 90       	pop	r14
    1cf4:	df 90       	pop	r13
    1cf6:	cf 90       	pop	r12
    1cf8:	bf 90       	pop	r11
    1cfa:	af 90       	pop	r10
    1cfc:	9f 90       	pop	r9
    1cfe:	8f 90       	pop	r8
    1d00:	7f 90       	pop	r7
    1d02:	6f 90       	pop	r6
    1d04:	5f 90       	pop	r5
    1d06:	4f 90       	pop	r4
    1d08:	3f 90       	pop	r3
    1d0a:	2f 90       	pop	r2
    1d0c:	1f 90       	pop	r1
    1d0e:	0f 90       	pop	r0
    1d10:	0c be       	out	0x3c, r0	; 60
    1d12:	0f 90       	pop	r0
    1d14:	0b be       	out	0x3b, r0	; 59
    1d16:	0f 90       	pop	r0
    1d18:	0f be       	out	0x3f, r0	; 63
    1d1a:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1d1c:	08 95       	ret

00001d1e <__vector_17>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    1d1e:	85 df       	rcall	.-246    	; 0x1c2a <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1d20:	18 95       	reti

00001d22 <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1d22:	0f 93       	push	r16
    1d24:	1f 93       	push	r17
    1d26:	cf 93       	push	r28
    1d28:	df 93       	push	r29
    1d2a:	08 2f       	mov	r16, r24
    1d2c:	16 2f       	mov	r17, r22
    1d2e:	66 23       	and	r22, r22
    1d30:	09 f4       	brne	.+2      	; 0x1d34 <xQueueGenericCreate+0x12>
    1d32:	38 c0       	rjmp	.+112    	; 0x1da4 <xQueueGenericCreate+0x82>
    1d34:	86 9f       	mul	r24, r22
    1d36:	c0 01       	movw	r24, r0
    1d38:	11 24       	eor	r1, r1
    1d3a:	80 96       	adiw	r24, 0x20	; 32
    1d3c:	9a dd       	rcall	.-1228   	; 0x1872 <pvPortMalloc>
    1d3e:	ec 01       	movw	r28, r24
    1d40:	00 97       	sbiw	r24, 0x00	; 0
    1d42:	21 f4       	brne	.+8      	; 0x1d4c <xQueueGenericCreate+0x2a>
    1d44:	36 c0       	rjmp	.+108    	; 0x1db2 <xQueueGenericCreate+0x90>
    1d46:	d9 83       	std	Y+1, r29	; 0x01
    1d48:	c8 83       	st	Y, r28
    1d4a:	03 c0       	rjmp	.+6      	; 0x1d52 <xQueueGenericCreate+0x30>
    1d4c:	4f 96       	adiw	r24, 0x1f	; 31
    1d4e:	99 83       	std	Y+1, r25	; 0x01
    1d50:	88 83       	st	Y, r24
    1d52:	0b 8f       	std	Y+27, r16	; 0x1b
    1d54:	1c 8f       	std	Y+28, r17	; 0x1c
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	f8 94       	cli
    1d5a:	0f 92       	push	r0
    1d5c:	48 81       	ld	r20, Y
    1d5e:	59 81       	ldd	r21, Y+1	; 0x01
    1d60:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1d62:	30 e0       	ldi	r19, 0x00	; 0
    1d64:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1d66:	62 9f       	mul	r22, r18
    1d68:	c0 01       	movw	r24, r0
    1d6a:	63 9f       	mul	r22, r19
    1d6c:	90 0d       	add	r25, r0
    1d6e:	11 24       	eor	r1, r1
    1d70:	ba 01       	movw	r22, r20
    1d72:	68 0f       	add	r22, r24
    1d74:	79 1f       	adc	r23, r25
    1d76:	7b 83       	std	Y+3, r23	; 0x03
    1d78:	6a 83       	std	Y+2, r22	; 0x02
    1d7a:	1a 8e       	std	Y+26, r1	; 0x1a
    1d7c:	5d 83       	std	Y+5, r21	; 0x05
    1d7e:	4c 83       	std	Y+4, r20	; 0x04
    1d80:	82 1b       	sub	r24, r18
    1d82:	93 0b       	sbc	r25, r19
    1d84:	84 0f       	add	r24, r20
    1d86:	95 1f       	adc	r25, r21
    1d88:	9f 83       	std	Y+7, r25	; 0x07
    1d8a:	8e 83       	std	Y+6, r24	; 0x06
    1d8c:	8f ef       	ldi	r24, 0xFF	; 255
    1d8e:	8d 8f       	std	Y+29, r24	; 0x1d
    1d90:	8e 8f       	std	Y+30, r24	; 0x1e
    1d92:	ce 01       	movw	r24, r28
    1d94:	08 96       	adiw	r24, 0x08	; 8
    1d96:	a3 dd       	rcall	.-1210   	; 0x18de <vListInitialise>
    1d98:	ce 01       	movw	r24, r28
    1d9a:	41 96       	adiw	r24, 0x11	; 17
    1d9c:	a0 dd       	rcall	.-1216   	; 0x18de <vListInitialise>
    1d9e:	0f 90       	pop	r0
    1da0:	0f be       	out	0x3f, r0	; 63
    1da2:	07 c0       	rjmp	.+14     	; 0x1db2 <xQueueGenericCreate+0x90>
    1da4:	8f e1       	ldi	r24, 0x1F	; 31
    1da6:	90 e0       	ldi	r25, 0x00	; 0
    1da8:	64 dd       	rcall	.-1336   	; 0x1872 <pvPortMalloc>
    1daa:	ec 01       	movw	r28, r24
    1dac:	89 2b       	or	r24, r25
    1dae:	09 f0       	breq	.+2      	; 0x1db2 <xQueueGenericCreate+0x90>
    1db0:	ca cf       	rjmp	.-108    	; 0x1d46 <xQueueGenericCreate+0x24>
    1db2:	ce 01       	movw	r24, r28
    1db4:	df 91       	pop	r29
    1db6:	cf 91       	pop	r28
    1db8:	1f 91       	pop	r17
    1dba:	0f 91       	pop	r16
    1dbc:	08 95       	ret

00001dbe <xQueueGenericSend>:
    1dbe:	6f 92       	push	r6
    1dc0:	7f 92       	push	r7
    1dc2:	8f 92       	push	r8
    1dc4:	9f 92       	push	r9
    1dc6:	af 92       	push	r10
    1dc8:	bf 92       	push	r11
    1dca:	cf 92       	push	r12
    1dcc:	df 92       	push	r13
    1dce:	ef 92       	push	r14
    1dd0:	ff 92       	push	r15
    1dd2:	0f 93       	push	r16
    1dd4:	1f 93       	push	r17
    1dd6:	cf 93       	push	r28
    1dd8:	df 93       	push	r29
    1dda:	00 d0       	rcall	.+0      	; 0x1ddc <xQueueGenericSend+0x1e>
    1ddc:	1f 92       	push	r1
    1dde:	1f 92       	push	r1
    1de0:	cd b7       	in	r28, 0x3d	; 61
    1de2:	de b7       	in	r29, 0x3e	; 62
    1de4:	8c 01       	movw	r16, r24
    1de6:	5b 01       	movw	r10, r22
    1de8:	5d 83       	std	Y+5, r21	; 0x05
    1dea:	4c 83       	std	Y+4, r20	; 0x04
    1dec:	72 2e       	mov	r7, r18
    1dee:	81 2c       	mov	r8, r1
    1df0:	66 24       	eor	r6, r6
    1df2:	63 94       	inc	r6
    1df4:	99 24       	eor	r9, r9
    1df6:	9a 94       	dec	r9
    1df8:	7c 01       	movw	r14, r24
    1dfa:	88 e0       	ldi	r24, 0x08	; 8
    1dfc:	e8 0e       	add	r14, r24
    1dfe:	f1 1c       	adc	r15, r1
    1e00:	68 01       	movw	r12, r16
    1e02:	e1 e1       	ldi	r30, 0x11	; 17
    1e04:	ce 0e       	add	r12, r30
    1e06:	d1 1c       	adc	r13, r1
    1e08:	0f b6       	in	r0, 0x3f	; 63
    1e0a:	f8 94       	cli
    1e0c:	0f 92       	push	r0
    1e0e:	f8 01       	movw	r30, r16
    1e10:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e12:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e14:	98 17       	cp	r25, r24
    1e16:	20 f0       	brcs	.+8      	; 0x1e20 <xQueueGenericSend+0x62>
    1e18:	f2 e0       	ldi	r31, 0x02	; 2
    1e1a:	7f 12       	cpse	r7, r31
    1e1c:	6e c0       	rjmp	.+220    	; 0x1efa <xQueueGenericSend+0x13c>
    1e1e:	79 c1       	rjmp	.+754    	; 0x2112 <xQueueGenericSend+0x354>
    1e20:	f8 01       	movw	r30, r16
    1e22:	44 8d       	ldd	r20, Z+28	; 0x1c
    1e24:	41 11       	cpse	r20, r1
    1e26:	15 c0       	rjmp	.+42     	; 0x1e52 <xQueueGenericSend+0x94>
    1e28:	f8 01       	movw	r30, r16
    1e2a:	80 81       	ld	r24, Z
    1e2c:	91 81       	ldd	r25, Z+1	; 0x01
    1e2e:	89 2b       	or	r24, r25
    1e30:	09 f0       	breq	.+2      	; 0x1e34 <xQueueGenericSend+0x76>
    1e32:	75 c1       	rjmp	.+746    	; 0x211e <xQueueGenericSend+0x360>
    1e34:	82 81       	ldd	r24, Z+2	; 0x02
    1e36:	93 81       	ldd	r25, Z+3	; 0x03
    1e38:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <xTaskPriorityDisinherit>
    1e3c:	f8 01       	movw	r30, r16
    1e3e:	13 82       	std	Z+3, r1	; 0x03
    1e40:	12 82       	std	Z+2, r1	; 0x02
    1e42:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e44:	9f 5f       	subi	r25, 0xFF	; 255
    1e46:	92 8f       	std	Z+26, r25	; 0x1a
    1e48:	91 89       	ldd	r25, Z+17	; 0x11
    1e4a:	99 23       	and	r25, r25
    1e4c:	09 f4       	brne	.+2      	; 0x1e50 <xQueueGenericSend+0x92>
    1e4e:	4f c0       	rjmp	.+158    	; 0x1eee <xQueueGenericSend+0x130>
    1e50:	46 c0       	rjmp	.+140    	; 0x1ede <xQueueGenericSend+0x120>
    1e52:	71 10       	cpse	r7, r1
    1e54:	1a c0       	rjmp	.+52     	; 0x1e8a <xQueueGenericSend+0xcc>
    1e56:	50 e0       	ldi	r21, 0x00	; 0
    1e58:	b5 01       	movw	r22, r10
    1e5a:	f8 01       	movw	r30, r16
    1e5c:	84 81       	ldd	r24, Z+4	; 0x04
    1e5e:	95 81       	ldd	r25, Z+5	; 0x05
    1e60:	0e 94 27 22 	call	0x444e	; 0x444e <memcpy>
    1e64:	f8 01       	movw	r30, r16
    1e66:	24 8d       	ldd	r18, Z+28	; 0x1c
    1e68:	84 81       	ldd	r24, Z+4	; 0x04
    1e6a:	95 81       	ldd	r25, Z+5	; 0x05
    1e6c:	82 0f       	add	r24, r18
    1e6e:	91 1d       	adc	r25, r1
    1e70:	95 83       	std	Z+5, r25	; 0x05
    1e72:	84 83       	std	Z+4, r24	; 0x04
    1e74:	22 81       	ldd	r18, Z+2	; 0x02
    1e76:	33 81       	ldd	r19, Z+3	; 0x03
    1e78:	82 17       	cp	r24, r18
    1e7a:	93 07       	cpc	r25, r19
    1e7c:	08 f4       	brcc	.+2      	; 0x1e80 <xQueueGenericSend+0xc2>
    1e7e:	4f c1       	rjmp	.+670    	; 0x211e <xQueueGenericSend+0x360>
    1e80:	80 81       	ld	r24, Z
    1e82:	91 81       	ldd	r25, Z+1	; 0x01
    1e84:	95 83       	std	Z+5, r25	; 0x05
    1e86:	84 83       	std	Z+4, r24	; 0x04
    1e88:	4a c1       	rjmp	.+660    	; 0x211e <xQueueGenericSend+0x360>
    1e8a:	50 e0       	ldi	r21, 0x00	; 0
    1e8c:	b5 01       	movw	r22, r10
    1e8e:	f8 01       	movw	r30, r16
    1e90:	86 81       	ldd	r24, Z+6	; 0x06
    1e92:	97 81       	ldd	r25, Z+7	; 0x07
    1e94:	0e 94 27 22 	call	0x444e	; 0x444e <memcpy>
    1e98:	f8 01       	movw	r30, r16
    1e9a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	91 95       	neg	r25
    1ea0:	81 95       	neg	r24
    1ea2:	91 09       	sbc	r25, r1
    1ea4:	26 81       	ldd	r18, Z+6	; 0x06
    1ea6:	37 81       	ldd	r19, Z+7	; 0x07
    1ea8:	28 0f       	add	r18, r24
    1eaa:	39 1f       	adc	r19, r25
    1eac:	37 83       	std	Z+7, r19	; 0x07
    1eae:	26 83       	std	Z+6, r18	; 0x06
    1eb0:	40 81       	ld	r20, Z
    1eb2:	51 81       	ldd	r21, Z+1	; 0x01
    1eb4:	24 17       	cp	r18, r20
    1eb6:	35 07       	cpc	r19, r21
    1eb8:	30 f4       	brcc	.+12     	; 0x1ec6 <xQueueGenericSend+0x108>
    1eba:	22 81       	ldd	r18, Z+2	; 0x02
    1ebc:	33 81       	ldd	r19, Z+3	; 0x03
    1ebe:	82 0f       	add	r24, r18
    1ec0:	93 1f       	adc	r25, r19
    1ec2:	97 83       	std	Z+7, r25	; 0x07
    1ec4:	86 83       	std	Z+6, r24	; 0x06
    1ec6:	f2 e0       	ldi	r31, 0x02	; 2
    1ec8:	7f 12       	cpse	r7, r31
    1eca:	29 c1       	rjmp	.+594    	; 0x211e <xQueueGenericSend+0x360>
    1ecc:	f8 01       	movw	r30, r16
    1ece:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ed0:	88 23       	and	r24, r24
    1ed2:	09 f4       	brne	.+2      	; 0x1ed6 <xQueueGenericSend+0x118>
    1ed4:	24 c1       	rjmp	.+584    	; 0x211e <xQueueGenericSend+0x360>
    1ed6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ed8:	81 50       	subi	r24, 0x01	; 1
    1eda:	82 8f       	std	Z+26, r24	; 0x1a
    1edc:	20 c1       	rjmp	.+576    	; 0x211e <xQueueGenericSend+0x360>
    1ede:	c8 01       	movw	r24, r16
    1ee0:	41 96       	adiw	r24, 0x11	; 17
    1ee2:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    1ee6:	81 30       	cpi	r24, 0x01	; 1
    1ee8:	21 f4       	brne	.+8      	; 0x1ef2 <xQueueGenericSend+0x134>
    1eea:	3e de       	rcall	.-900    	; 0x1b68 <vPortYield>
    1eec:	02 c0       	rjmp	.+4      	; 0x1ef2 <xQueueGenericSend+0x134>
    1eee:	81 11       	cpse	r24, r1
    1ef0:	3b de       	rcall	.-906    	; 0x1b68 <vPortYield>
    1ef2:	0f 90       	pop	r0
    1ef4:	0f be       	out	0x3f, r0	; 63
    1ef6:	81 e0       	ldi	r24, 0x01	; 1
    1ef8:	1a c1       	rjmp	.+564    	; 0x212e <xQueueGenericSend+0x370>
    1efa:	8c 81       	ldd	r24, Y+4	; 0x04
    1efc:	9d 81       	ldd	r25, Y+5	; 0x05
    1efe:	89 2b       	or	r24, r25
    1f00:	21 f4       	brne	.+8      	; 0x1f0a <xQueueGenericSend+0x14c>
    1f02:	0f 90       	pop	r0
    1f04:	0f be       	out	0x3f, r0	; 63
    1f06:	80 e0       	ldi	r24, 0x00	; 0
    1f08:	12 c1       	rjmp	.+548    	; 0x212e <xQueueGenericSend+0x370>
    1f0a:	81 10       	cpse	r8, r1
    1f0c:	05 c0       	rjmp	.+10     	; 0x1f18 <xQueueGenericSend+0x15a>
    1f0e:	ce 01       	movw	r24, r28
    1f10:	01 96       	adiw	r24, 0x01	; 1
    1f12:	0e 94 ae 1a 	call	0x355c	; 0x355c <vTaskSetTimeOutState>
    1f16:	86 2c       	mov	r8, r6
    1f18:	0f 90       	pop	r0
    1f1a:	0f be       	out	0x3f, r0	; 63
    1f1c:	dc d7       	rcall	.+4024   	; 0x2ed6 <vTaskSuspendAll>
    1f1e:	0f b6       	in	r0, 0x3f	; 63
    1f20:	f8 94       	cli
    1f22:	0f 92       	push	r0
    1f24:	f8 01       	movw	r30, r16
    1f26:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f28:	8f 3f       	cpi	r24, 0xFF	; 255
    1f2a:	09 f4       	brne	.+2      	; 0x1f2e <xQueueGenericSend+0x170>
    1f2c:	15 8e       	std	Z+29, r1	; 0x1d
    1f2e:	f8 01       	movw	r30, r16
    1f30:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f32:	8f 3f       	cpi	r24, 0xFF	; 255
    1f34:	09 f4       	brne	.+2      	; 0x1f38 <xQueueGenericSend+0x17a>
    1f36:	16 8e       	std	Z+30, r1	; 0x1e
    1f38:	0f 90       	pop	r0
    1f3a:	0f be       	out	0x3f, r0	; 63
    1f3c:	be 01       	movw	r22, r28
    1f3e:	6c 5f       	subi	r22, 0xFC	; 252
    1f40:	7f 4f       	sbci	r23, 0xFF	; 255
    1f42:	ce 01       	movw	r24, r28
    1f44:	01 96       	adiw	r24, 0x01	; 1
    1f46:	0e 94 b9 1a 	call	0x3572	; 0x3572 <xTaskCheckForTimeOut>
    1f4a:	81 11       	cpse	r24, r1
    1f4c:	94 c0       	rjmp	.+296    	; 0x2076 <xQueueGenericSend+0x2b8>
    1f4e:	0f b6       	in	r0, 0x3f	; 63
    1f50:	f8 94       	cli
    1f52:	0f 92       	push	r0
    1f54:	f8 01       	movw	r30, r16
    1f56:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f58:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f5a:	0f 90       	pop	r0
    1f5c:	0f be       	out	0x3f, r0	; 63
    1f5e:	98 13       	cpse	r25, r24
    1f60:	49 c0       	rjmp	.+146    	; 0x1ff4 <xQueueGenericSend+0x236>
    1f62:	6c 81       	ldd	r22, Y+4	; 0x04
    1f64:	7d 81       	ldd	r23, Y+5	; 0x05
    1f66:	c7 01       	movw	r24, r14
    1f68:	0e 94 0b 1a 	call	0x3416	; 0x3416 <vTaskPlaceOnEventList>
    1f6c:	0f b6       	in	r0, 0x3f	; 63
    1f6e:	f8 94       	cli
    1f70:	0f 92       	push	r0
    1f72:	f8 01       	movw	r30, r16
    1f74:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f76:	18 16       	cp	r1, r24
    1f78:	ac f4       	brge	.+42     	; 0x1fa4 <xQueueGenericSend+0x1e6>
    1f7a:	81 89       	ldd	r24, Z+17	; 0x11
    1f7c:	81 11       	cpse	r24, r1
    1f7e:	05 c0       	rjmp	.+10     	; 0x1f8a <xQueueGenericSend+0x1cc>
    1f80:	11 c0       	rjmp	.+34     	; 0x1fa4 <xQueueGenericSend+0x1e6>
    1f82:	f8 01       	movw	r30, r16
    1f84:	81 89       	ldd	r24, Z+17	; 0x11
    1f86:	88 23       	and	r24, r24
    1f88:	69 f0       	breq	.+26     	; 0x1fa4 <xQueueGenericSend+0x1e6>
    1f8a:	c6 01       	movw	r24, r12
    1f8c:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    1f90:	81 11       	cpse	r24, r1
    1f92:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    1f96:	f8 01       	movw	r30, r16
    1f98:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f9a:	81 50       	subi	r24, 0x01	; 1
    1f9c:	86 8f       	std	Z+30, r24	; 0x1e
    1f9e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fa0:	18 16       	cp	r1, r24
    1fa2:	7c f3       	brlt	.-34     	; 0x1f82 <xQueueGenericSend+0x1c4>
    1fa4:	f8 01       	movw	r30, r16
    1fa6:	96 8e       	std	Z+30, r9	; 0x1e
    1fa8:	0f 90       	pop	r0
    1faa:	0f be       	out	0x3f, r0	; 63
    1fac:	0f b6       	in	r0, 0x3f	; 63
    1fae:	f8 94       	cli
    1fb0:	0f 92       	push	r0
    1fb2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fb4:	18 16       	cp	r1, r24
    1fb6:	ac f4       	brge	.+42     	; 0x1fe2 <xQueueGenericSend+0x224>
    1fb8:	80 85       	ldd	r24, Z+8	; 0x08
    1fba:	81 11       	cpse	r24, r1
    1fbc:	05 c0       	rjmp	.+10     	; 0x1fc8 <xQueueGenericSend+0x20a>
    1fbe:	11 c0       	rjmp	.+34     	; 0x1fe2 <xQueueGenericSend+0x224>
    1fc0:	f8 01       	movw	r30, r16
    1fc2:	80 85       	ldd	r24, Z+8	; 0x08
    1fc4:	88 23       	and	r24, r24
    1fc6:	69 f0       	breq	.+26     	; 0x1fe2 <xQueueGenericSend+0x224>
    1fc8:	c7 01       	movw	r24, r14
    1fca:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    1fce:	81 11       	cpse	r24, r1
    1fd0:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    1fd4:	f8 01       	movw	r30, r16
    1fd6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fd8:	81 50       	subi	r24, 0x01	; 1
    1fda:	85 8f       	std	Z+29, r24	; 0x1d
    1fdc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fde:	18 16       	cp	r1, r24
    1fe0:	7c f3       	brlt	.-34     	; 0x1fc0 <xQueueGenericSend+0x202>
    1fe2:	f8 01       	movw	r30, r16
    1fe4:	95 8e       	std	Z+29, r9	; 0x1d
    1fe6:	0f 90       	pop	r0
    1fe8:	0f be       	out	0x3f, r0	; 63
    1fea:	7b d7       	rcall	.+3830   	; 0x2ee2 <xTaskResumeAll>
    1fec:	81 11       	cpse	r24, r1
    1fee:	0c cf       	rjmp	.-488    	; 0x1e08 <xQueueGenericSend+0x4a>
    1ff0:	bb dd       	rcall	.-1162   	; 0x1b68 <vPortYield>
    1ff2:	0a cf       	rjmp	.-492    	; 0x1e08 <xQueueGenericSend+0x4a>
    1ff4:	0f b6       	in	r0, 0x3f	; 63
    1ff6:	f8 94       	cli
    1ff8:	0f 92       	push	r0
    1ffa:	f8 01       	movw	r30, r16
    1ffc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ffe:	18 16       	cp	r1, r24
    2000:	ac f4       	brge	.+42     	; 0x202c <xQueueGenericSend+0x26e>
    2002:	81 89       	ldd	r24, Z+17	; 0x11
    2004:	81 11       	cpse	r24, r1
    2006:	05 c0       	rjmp	.+10     	; 0x2012 <xQueueGenericSend+0x254>
    2008:	11 c0       	rjmp	.+34     	; 0x202c <xQueueGenericSend+0x26e>
    200a:	f8 01       	movw	r30, r16
    200c:	81 89       	ldd	r24, Z+17	; 0x11
    200e:	88 23       	and	r24, r24
    2010:	69 f0       	breq	.+26     	; 0x202c <xQueueGenericSend+0x26e>
    2012:	c6 01       	movw	r24, r12
    2014:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    2018:	81 11       	cpse	r24, r1
    201a:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    201e:	f8 01       	movw	r30, r16
    2020:	86 8d       	ldd	r24, Z+30	; 0x1e
    2022:	81 50       	subi	r24, 0x01	; 1
    2024:	86 8f       	std	Z+30, r24	; 0x1e
    2026:	86 8d       	ldd	r24, Z+30	; 0x1e
    2028:	18 16       	cp	r1, r24
    202a:	7c f3       	brlt	.-34     	; 0x200a <xQueueGenericSend+0x24c>
    202c:	f8 01       	movw	r30, r16
    202e:	96 8e       	std	Z+30, r9	; 0x1e
    2030:	0f 90       	pop	r0
    2032:	0f be       	out	0x3f, r0	; 63
    2034:	0f b6       	in	r0, 0x3f	; 63
    2036:	f8 94       	cli
    2038:	0f 92       	push	r0
    203a:	85 8d       	ldd	r24, Z+29	; 0x1d
    203c:	18 16       	cp	r1, r24
    203e:	ac f4       	brge	.+42     	; 0x206a <xQueueGenericSend+0x2ac>
    2040:	80 85       	ldd	r24, Z+8	; 0x08
    2042:	81 11       	cpse	r24, r1
    2044:	05 c0       	rjmp	.+10     	; 0x2050 <xQueueGenericSend+0x292>
    2046:	11 c0       	rjmp	.+34     	; 0x206a <xQueueGenericSend+0x2ac>
    2048:	f8 01       	movw	r30, r16
    204a:	80 85       	ldd	r24, Z+8	; 0x08
    204c:	88 23       	and	r24, r24
    204e:	69 f0       	breq	.+26     	; 0x206a <xQueueGenericSend+0x2ac>
    2050:	c7 01       	movw	r24, r14
    2052:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    2056:	81 11       	cpse	r24, r1
    2058:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    205c:	f8 01       	movw	r30, r16
    205e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2060:	81 50       	subi	r24, 0x01	; 1
    2062:	85 8f       	std	Z+29, r24	; 0x1d
    2064:	85 8d       	ldd	r24, Z+29	; 0x1d
    2066:	18 16       	cp	r1, r24
    2068:	7c f3       	brlt	.-34     	; 0x2048 <xQueueGenericSend+0x28a>
    206a:	f8 01       	movw	r30, r16
    206c:	95 8e       	std	Z+29, r9	; 0x1d
    206e:	0f 90       	pop	r0
    2070:	0f be       	out	0x3f, r0	; 63
    2072:	37 d7       	rcall	.+3694   	; 0x2ee2 <xTaskResumeAll>
    2074:	c9 ce       	rjmp	.-622    	; 0x1e08 <xQueueGenericSend+0x4a>
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	0f 92       	push	r0
    207c:	f8 01       	movw	r30, r16
    207e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2080:	18 16       	cp	r1, r24
    2082:	d4 f4       	brge	.+52     	; 0x20b8 <xQueueGenericSend+0x2fa>
    2084:	81 89       	ldd	r24, Z+17	; 0x11
    2086:	81 11       	cpse	r24, r1
    2088:	06 c0       	rjmp	.+12     	; 0x2096 <xQueueGenericSend+0x2d8>
    208a:	16 c0       	rjmp	.+44     	; 0x20b8 <xQueueGenericSend+0x2fa>
    208c:	f8 01       	movw	r30, r16
    208e:	81 89       	ldd	r24, Z+17	; 0x11
    2090:	81 11       	cpse	r24, r1
    2092:	05 c0       	rjmp	.+10     	; 0x209e <xQueueGenericSend+0x2e0>
    2094:	11 c0       	rjmp	.+34     	; 0x20b8 <xQueueGenericSend+0x2fa>
    2096:	78 01       	movw	r14, r16
    2098:	f1 e1       	ldi	r31, 0x11	; 17
    209a:	ef 0e       	add	r14, r31
    209c:	f1 1c       	adc	r15, r1
    209e:	c7 01       	movw	r24, r14
    20a0:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    20a4:	81 11       	cpse	r24, r1
    20a6:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    20aa:	f8 01       	movw	r30, r16
    20ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    20ae:	81 50       	subi	r24, 0x01	; 1
    20b0:	86 8f       	std	Z+30, r24	; 0x1e
    20b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    20b4:	18 16       	cp	r1, r24
    20b6:	54 f3       	brlt	.-44     	; 0x208c <xQueueGenericSend+0x2ce>
    20b8:	8f ef       	ldi	r24, 0xFF	; 255
    20ba:	f8 01       	movw	r30, r16
    20bc:	86 8f       	std	Z+30, r24	; 0x1e
    20be:	0f 90       	pop	r0
    20c0:	0f be       	out	0x3f, r0	; 63
    20c2:	0f b6       	in	r0, 0x3f	; 63
    20c4:	f8 94       	cli
    20c6:	0f 92       	push	r0
    20c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    20ca:	18 16       	cp	r1, r24
    20cc:	d4 f4       	brge	.+52     	; 0x2102 <xQueueGenericSend+0x344>
    20ce:	80 85       	ldd	r24, Z+8	; 0x08
    20d0:	81 11       	cpse	r24, r1
    20d2:	06 c0       	rjmp	.+12     	; 0x20e0 <xQueueGenericSend+0x322>
    20d4:	16 c0       	rjmp	.+44     	; 0x2102 <xQueueGenericSend+0x344>
    20d6:	f8 01       	movw	r30, r16
    20d8:	80 85       	ldd	r24, Z+8	; 0x08
    20da:	81 11       	cpse	r24, r1
    20dc:	05 c0       	rjmp	.+10     	; 0x20e8 <xQueueGenericSend+0x32a>
    20de:	11 c0       	rjmp	.+34     	; 0x2102 <xQueueGenericSend+0x344>
    20e0:	78 01       	movw	r14, r16
    20e2:	f8 e0       	ldi	r31, 0x08	; 8
    20e4:	ef 0e       	add	r14, r31
    20e6:	f1 1c       	adc	r15, r1
    20e8:	c7 01       	movw	r24, r14
    20ea:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    20ee:	81 11       	cpse	r24, r1
    20f0:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    20f4:	f8 01       	movw	r30, r16
    20f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    20f8:	81 50       	subi	r24, 0x01	; 1
    20fa:	85 8f       	std	Z+29, r24	; 0x1d
    20fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    20fe:	18 16       	cp	r1, r24
    2100:	54 f3       	brlt	.-44     	; 0x20d6 <xQueueGenericSend+0x318>
    2102:	8f ef       	ldi	r24, 0xFF	; 255
    2104:	f8 01       	movw	r30, r16
    2106:	85 8f       	std	Z+29, r24	; 0x1d
    2108:	0f 90       	pop	r0
    210a:	0f be       	out	0x3f, r0	; 63
    210c:	ea d6       	rcall	.+3540   	; 0x2ee2 <xTaskResumeAll>
    210e:	80 e0       	ldi	r24, 0x00	; 0
    2110:	0e c0       	rjmp	.+28     	; 0x212e <xQueueGenericSend+0x370>
    2112:	f8 01       	movw	r30, r16
    2114:	44 8d       	ldd	r20, Z+28	; 0x1c
    2116:	44 23       	and	r20, r20
    2118:	09 f4       	brne	.+2      	; 0x211c <xQueueGenericSend+0x35e>
    211a:	86 ce       	rjmp	.-756    	; 0x1e28 <xQueueGenericSend+0x6a>
    211c:	b6 ce       	rjmp	.-660    	; 0x1e8a <xQueueGenericSend+0xcc>
    211e:	f8 01       	movw	r30, r16
    2120:	82 8d       	ldd	r24, Z+26	; 0x1a
    2122:	8f 5f       	subi	r24, 0xFF	; 255
    2124:	82 8f       	std	Z+26, r24	; 0x1a
    2126:	81 89       	ldd	r24, Z+17	; 0x11
    2128:	81 11       	cpse	r24, r1
    212a:	d9 ce       	rjmp	.-590    	; 0x1ede <xQueueGenericSend+0x120>
    212c:	e2 ce       	rjmp	.-572    	; 0x1ef2 <xQueueGenericSend+0x134>
    212e:	0f 90       	pop	r0
    2130:	0f 90       	pop	r0
    2132:	0f 90       	pop	r0
    2134:	0f 90       	pop	r0
    2136:	0f 90       	pop	r0
    2138:	df 91       	pop	r29
    213a:	cf 91       	pop	r28
    213c:	1f 91       	pop	r17
    213e:	0f 91       	pop	r16
    2140:	ff 90       	pop	r15
    2142:	ef 90       	pop	r14
    2144:	df 90       	pop	r13
    2146:	cf 90       	pop	r12
    2148:	bf 90       	pop	r11
    214a:	af 90       	pop	r10
    214c:	9f 90       	pop	r9
    214e:	8f 90       	pop	r8
    2150:	7f 90       	pop	r7
    2152:	6f 90       	pop	r6
    2154:	08 95       	ret

00002156 <xQueueGive>:
    2156:	9f 92       	push	r9
    2158:	af 92       	push	r10
    215a:	bf 92       	push	r11
    215c:	cf 92       	push	r12
    215e:	df 92       	push	r13
    2160:	ef 92       	push	r14
    2162:	ff 92       	push	r15
    2164:	0f 93       	push	r16
    2166:	1f 93       	push	r17
    2168:	cf 93       	push	r28
    216a:	df 93       	push	r29
    216c:	00 d0       	rcall	.+0      	; 0x216e <xQueueGive+0x18>
    216e:	1f 92       	push	r1
    2170:	1f 92       	push	r1
    2172:	cd b7       	in	r28, 0x3d	; 61
    2174:	de b7       	in	r29, 0x3e	; 62
    2176:	8c 01       	movw	r16, r24
    2178:	7d 83       	std	Y+5, r23	; 0x05
    217a:	6c 83       	std	Y+4, r22	; 0x04
    217c:	a1 2c       	mov	r10, r1
    217e:	99 24       	eor	r9, r9
    2180:	93 94       	inc	r9
    2182:	bb 24       	eor	r11, r11
    2184:	ba 94       	dec	r11
    2186:	7c 01       	movw	r14, r24
    2188:	88 e0       	ldi	r24, 0x08	; 8
    218a:	e8 0e       	add	r14, r24
    218c:	f1 1c       	adc	r15, r1
    218e:	68 01       	movw	r12, r16
    2190:	e1 e1       	ldi	r30, 0x11	; 17
    2192:	ce 0e       	add	r12, r30
    2194:	d1 1c       	adc	r13, r1
    2196:	0f b6       	in	r0, 0x3f	; 63
    2198:	f8 94       	cli
    219a:	0f 92       	push	r0
    219c:	f8 01       	movw	r30, r16
    219e:	92 8d       	ldd	r25, Z+26	; 0x1a
    21a0:	83 8d       	ldd	r24, Z+27	; 0x1b
    21a2:	98 17       	cp	r25, r24
    21a4:	00 f5       	brcc	.+64     	; 0x21e6 <xQueueGive+0x90>
    21a6:	80 81       	ld	r24, Z
    21a8:	91 81       	ldd	r25, Z+1	; 0x01
    21aa:	89 2b       	or	r24, r25
    21ac:	09 f0       	breq	.+2      	; 0x21b0 <xQueueGive+0x5a>
    21ae:	27 c1       	rjmp	.+590    	; 0x23fe <__stack+0x1ff>
    21b0:	82 81       	ldd	r24, Z+2	; 0x02
    21b2:	93 81       	ldd	r25, Z+3	; 0x03
    21b4:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <xTaskPriorityDisinherit>
    21b8:	f8 01       	movw	r30, r16
    21ba:	13 82       	std	Z+3, r1	; 0x03
    21bc:	12 82       	std	Z+2, r1	; 0x02
    21be:	92 8d       	ldd	r25, Z+26	; 0x1a
    21c0:	9f 5f       	subi	r25, 0xFF	; 255
    21c2:	92 8f       	std	Z+26, r25	; 0x1a
    21c4:	91 89       	ldd	r25, Z+17	; 0x11
    21c6:	99 23       	and	r25, r25
    21c8:	41 f0       	breq	.+16     	; 0x21da <xQueueGive+0x84>
    21ca:	c8 01       	movw	r24, r16
    21cc:	41 96       	adiw	r24, 0x11	; 17
    21ce:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    21d2:	81 30       	cpi	r24, 0x01	; 1
    21d4:	21 f4       	brne	.+8      	; 0x21de <xQueueGive+0x88>
    21d6:	c8 dc       	rcall	.-1648   	; 0x1b68 <vPortYield>
    21d8:	02 c0       	rjmp	.+4      	; 0x21de <xQueueGive+0x88>
    21da:	81 11       	cpse	r24, r1
    21dc:	c5 dc       	rcall	.-1654   	; 0x1b68 <vPortYield>
    21de:	0f 90       	pop	r0
    21e0:	0f be       	out	0x3f, r0	; 63
    21e2:	81 e0       	ldi	r24, 0x01	; 1
    21e4:	14 c1       	rjmp	.+552    	; 0x240e <__stack+0x20f>
    21e6:	8c 81       	ldd	r24, Y+4	; 0x04
    21e8:	9d 81       	ldd	r25, Y+5	; 0x05
    21ea:	89 2b       	or	r24, r25
    21ec:	21 f4       	brne	.+8      	; 0x21f6 <xQueueGive+0xa0>
    21ee:	0f 90       	pop	r0
    21f0:	0f be       	out	0x3f, r0	; 63
    21f2:	80 e0       	ldi	r24, 0x00	; 0
    21f4:	0c c1       	rjmp	.+536    	; 0x240e <__stack+0x20f>
    21f6:	a1 10       	cpse	r10, r1
    21f8:	05 c0       	rjmp	.+10     	; 0x2204 <__stack+0x5>
    21fa:	ce 01       	movw	r24, r28
    21fc:	01 96       	adiw	r24, 0x01	; 1
    21fe:	0e 94 ae 1a 	call	0x355c	; 0x355c <vTaskSetTimeOutState>
    2202:	a9 2c       	mov	r10, r9
    2204:	0f 90       	pop	r0
    2206:	0f be       	out	0x3f, r0	; 63
    2208:	66 d6       	rcall	.+3276   	; 0x2ed6 <vTaskSuspendAll>
    220a:	0f b6       	in	r0, 0x3f	; 63
    220c:	f8 94       	cli
    220e:	0f 92       	push	r0
    2210:	f8 01       	movw	r30, r16
    2212:	85 8d       	ldd	r24, Z+29	; 0x1d
    2214:	8f 3f       	cpi	r24, 0xFF	; 255
    2216:	09 f4       	brne	.+2      	; 0x221a <__stack+0x1b>
    2218:	15 8e       	std	Z+29, r1	; 0x1d
    221a:	f8 01       	movw	r30, r16
    221c:	86 8d       	ldd	r24, Z+30	; 0x1e
    221e:	8f 3f       	cpi	r24, 0xFF	; 255
    2220:	09 f4       	brne	.+2      	; 0x2224 <__stack+0x25>
    2222:	16 8e       	std	Z+30, r1	; 0x1e
    2224:	0f 90       	pop	r0
    2226:	0f be       	out	0x3f, r0	; 63
    2228:	be 01       	movw	r22, r28
    222a:	6c 5f       	subi	r22, 0xFC	; 252
    222c:	7f 4f       	sbci	r23, 0xFF	; 255
    222e:	ce 01       	movw	r24, r28
    2230:	01 96       	adiw	r24, 0x01	; 1
    2232:	0e 94 b9 1a 	call	0x3572	; 0x3572 <xTaskCheckForTimeOut>
    2236:	81 11       	cpse	r24, r1
    2238:	94 c0       	rjmp	.+296    	; 0x2362 <__stack+0x163>
    223a:	0f b6       	in	r0, 0x3f	; 63
    223c:	f8 94       	cli
    223e:	0f 92       	push	r0
    2240:	f8 01       	movw	r30, r16
    2242:	92 8d       	ldd	r25, Z+26	; 0x1a
    2244:	83 8d       	ldd	r24, Z+27	; 0x1b
    2246:	0f 90       	pop	r0
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	98 13       	cpse	r25, r24
    224c:	49 c0       	rjmp	.+146    	; 0x22e0 <__stack+0xe1>
    224e:	6c 81       	ldd	r22, Y+4	; 0x04
    2250:	7d 81       	ldd	r23, Y+5	; 0x05
    2252:	c7 01       	movw	r24, r14
    2254:	0e 94 0b 1a 	call	0x3416	; 0x3416 <vTaskPlaceOnEventList>
    2258:	0f b6       	in	r0, 0x3f	; 63
    225a:	f8 94       	cli
    225c:	0f 92       	push	r0
    225e:	f8 01       	movw	r30, r16
    2260:	86 8d       	ldd	r24, Z+30	; 0x1e
    2262:	18 16       	cp	r1, r24
    2264:	ac f4       	brge	.+42     	; 0x2290 <__stack+0x91>
    2266:	81 89       	ldd	r24, Z+17	; 0x11
    2268:	81 11       	cpse	r24, r1
    226a:	05 c0       	rjmp	.+10     	; 0x2276 <__stack+0x77>
    226c:	11 c0       	rjmp	.+34     	; 0x2290 <__stack+0x91>
    226e:	f8 01       	movw	r30, r16
    2270:	81 89       	ldd	r24, Z+17	; 0x11
    2272:	88 23       	and	r24, r24
    2274:	69 f0       	breq	.+26     	; 0x2290 <__stack+0x91>
    2276:	c6 01       	movw	r24, r12
    2278:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    227c:	81 11       	cpse	r24, r1
    227e:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    2282:	f8 01       	movw	r30, r16
    2284:	86 8d       	ldd	r24, Z+30	; 0x1e
    2286:	81 50       	subi	r24, 0x01	; 1
    2288:	86 8f       	std	Z+30, r24	; 0x1e
    228a:	86 8d       	ldd	r24, Z+30	; 0x1e
    228c:	18 16       	cp	r1, r24
    228e:	7c f3       	brlt	.-34     	; 0x226e <__stack+0x6f>
    2290:	f8 01       	movw	r30, r16
    2292:	b6 8e       	std	Z+30, r11	; 0x1e
    2294:	0f 90       	pop	r0
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	0f b6       	in	r0, 0x3f	; 63
    229a:	f8 94       	cli
    229c:	0f 92       	push	r0
    229e:	85 8d       	ldd	r24, Z+29	; 0x1d
    22a0:	18 16       	cp	r1, r24
    22a2:	ac f4       	brge	.+42     	; 0x22ce <__stack+0xcf>
    22a4:	80 85       	ldd	r24, Z+8	; 0x08
    22a6:	81 11       	cpse	r24, r1
    22a8:	05 c0       	rjmp	.+10     	; 0x22b4 <__stack+0xb5>
    22aa:	11 c0       	rjmp	.+34     	; 0x22ce <__stack+0xcf>
    22ac:	f8 01       	movw	r30, r16
    22ae:	80 85       	ldd	r24, Z+8	; 0x08
    22b0:	88 23       	and	r24, r24
    22b2:	69 f0       	breq	.+26     	; 0x22ce <__stack+0xcf>
    22b4:	c7 01       	movw	r24, r14
    22b6:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    22ba:	81 11       	cpse	r24, r1
    22bc:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    22c0:	f8 01       	movw	r30, r16
    22c2:	85 8d       	ldd	r24, Z+29	; 0x1d
    22c4:	81 50       	subi	r24, 0x01	; 1
    22c6:	85 8f       	std	Z+29, r24	; 0x1d
    22c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    22ca:	18 16       	cp	r1, r24
    22cc:	7c f3       	brlt	.-34     	; 0x22ac <__stack+0xad>
    22ce:	f8 01       	movw	r30, r16
    22d0:	b5 8e       	std	Z+29, r11	; 0x1d
    22d2:	0f 90       	pop	r0
    22d4:	0f be       	out	0x3f, r0	; 63
    22d6:	05 d6       	rcall	.+3082   	; 0x2ee2 <xTaskResumeAll>
    22d8:	81 11       	cpse	r24, r1
    22da:	5d cf       	rjmp	.-326    	; 0x2196 <xQueueGive+0x40>
    22dc:	45 dc       	rcall	.-1910   	; 0x1b68 <vPortYield>
    22de:	5b cf       	rjmp	.-330    	; 0x2196 <xQueueGive+0x40>
    22e0:	0f b6       	in	r0, 0x3f	; 63
    22e2:	f8 94       	cli
    22e4:	0f 92       	push	r0
    22e6:	f8 01       	movw	r30, r16
    22e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    22ea:	18 16       	cp	r1, r24
    22ec:	ac f4       	brge	.+42     	; 0x2318 <__stack+0x119>
    22ee:	81 89       	ldd	r24, Z+17	; 0x11
    22f0:	81 11       	cpse	r24, r1
    22f2:	05 c0       	rjmp	.+10     	; 0x22fe <__stack+0xff>
    22f4:	11 c0       	rjmp	.+34     	; 0x2318 <__stack+0x119>
    22f6:	f8 01       	movw	r30, r16
    22f8:	81 89       	ldd	r24, Z+17	; 0x11
    22fa:	88 23       	and	r24, r24
    22fc:	69 f0       	breq	.+26     	; 0x2318 <__stack+0x119>
    22fe:	c6 01       	movw	r24, r12
    2300:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    2304:	81 11       	cpse	r24, r1
    2306:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    230a:	f8 01       	movw	r30, r16
    230c:	86 8d       	ldd	r24, Z+30	; 0x1e
    230e:	81 50       	subi	r24, 0x01	; 1
    2310:	86 8f       	std	Z+30, r24	; 0x1e
    2312:	86 8d       	ldd	r24, Z+30	; 0x1e
    2314:	18 16       	cp	r1, r24
    2316:	7c f3       	brlt	.-34     	; 0x22f6 <__stack+0xf7>
    2318:	f8 01       	movw	r30, r16
    231a:	b6 8e       	std	Z+30, r11	; 0x1e
    231c:	0f 90       	pop	r0
    231e:	0f be       	out	0x3f, r0	; 63
    2320:	0f b6       	in	r0, 0x3f	; 63
    2322:	f8 94       	cli
    2324:	0f 92       	push	r0
    2326:	85 8d       	ldd	r24, Z+29	; 0x1d
    2328:	18 16       	cp	r1, r24
    232a:	ac f4       	brge	.+42     	; 0x2356 <__stack+0x157>
    232c:	80 85       	ldd	r24, Z+8	; 0x08
    232e:	81 11       	cpse	r24, r1
    2330:	05 c0       	rjmp	.+10     	; 0x233c <__stack+0x13d>
    2332:	11 c0       	rjmp	.+34     	; 0x2356 <__stack+0x157>
    2334:	f8 01       	movw	r30, r16
    2336:	80 85       	ldd	r24, Z+8	; 0x08
    2338:	88 23       	and	r24, r24
    233a:	69 f0       	breq	.+26     	; 0x2356 <__stack+0x157>
    233c:	c7 01       	movw	r24, r14
    233e:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    2342:	81 11       	cpse	r24, r1
    2344:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    2348:	f8 01       	movw	r30, r16
    234a:	85 8d       	ldd	r24, Z+29	; 0x1d
    234c:	81 50       	subi	r24, 0x01	; 1
    234e:	85 8f       	std	Z+29, r24	; 0x1d
    2350:	85 8d       	ldd	r24, Z+29	; 0x1d
    2352:	18 16       	cp	r1, r24
    2354:	7c f3       	brlt	.-34     	; 0x2334 <__stack+0x135>
    2356:	f8 01       	movw	r30, r16
    2358:	b5 8e       	std	Z+29, r11	; 0x1d
    235a:	0f 90       	pop	r0
    235c:	0f be       	out	0x3f, r0	; 63
    235e:	c1 d5       	rcall	.+2946   	; 0x2ee2 <xTaskResumeAll>
    2360:	1a cf       	rjmp	.-460    	; 0x2196 <xQueueGive+0x40>
    2362:	0f b6       	in	r0, 0x3f	; 63
    2364:	f8 94       	cli
    2366:	0f 92       	push	r0
    2368:	f8 01       	movw	r30, r16
    236a:	86 8d       	ldd	r24, Z+30	; 0x1e
    236c:	18 16       	cp	r1, r24
    236e:	d4 f4       	brge	.+52     	; 0x23a4 <__stack+0x1a5>
    2370:	81 89       	ldd	r24, Z+17	; 0x11
    2372:	81 11       	cpse	r24, r1
    2374:	06 c0       	rjmp	.+12     	; 0x2382 <__stack+0x183>
    2376:	16 c0       	rjmp	.+44     	; 0x23a4 <__stack+0x1a5>
    2378:	f8 01       	movw	r30, r16
    237a:	81 89       	ldd	r24, Z+17	; 0x11
    237c:	81 11       	cpse	r24, r1
    237e:	05 c0       	rjmp	.+10     	; 0x238a <__stack+0x18b>
    2380:	11 c0       	rjmp	.+34     	; 0x23a4 <__stack+0x1a5>
    2382:	78 01       	movw	r14, r16
    2384:	f1 e1       	ldi	r31, 0x11	; 17
    2386:	ef 0e       	add	r14, r31
    2388:	f1 1c       	adc	r15, r1
    238a:	c7 01       	movw	r24, r14
    238c:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    2390:	81 11       	cpse	r24, r1
    2392:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    2396:	f8 01       	movw	r30, r16
    2398:	86 8d       	ldd	r24, Z+30	; 0x1e
    239a:	81 50       	subi	r24, 0x01	; 1
    239c:	86 8f       	std	Z+30, r24	; 0x1e
    239e:	86 8d       	ldd	r24, Z+30	; 0x1e
    23a0:	18 16       	cp	r1, r24
    23a2:	54 f3       	brlt	.-44     	; 0x2378 <__stack+0x179>
    23a4:	8f ef       	ldi	r24, 0xFF	; 255
    23a6:	f8 01       	movw	r30, r16
    23a8:	86 8f       	std	Z+30, r24	; 0x1e
    23aa:	0f 90       	pop	r0
    23ac:	0f be       	out	0x3f, r0	; 63
    23ae:	0f b6       	in	r0, 0x3f	; 63
    23b0:	f8 94       	cli
    23b2:	0f 92       	push	r0
    23b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    23b6:	18 16       	cp	r1, r24
    23b8:	d4 f4       	brge	.+52     	; 0x23ee <__stack+0x1ef>
    23ba:	80 85       	ldd	r24, Z+8	; 0x08
    23bc:	81 11       	cpse	r24, r1
    23be:	06 c0       	rjmp	.+12     	; 0x23cc <__stack+0x1cd>
    23c0:	16 c0       	rjmp	.+44     	; 0x23ee <__stack+0x1ef>
    23c2:	f8 01       	movw	r30, r16
    23c4:	80 85       	ldd	r24, Z+8	; 0x08
    23c6:	81 11       	cpse	r24, r1
    23c8:	05 c0       	rjmp	.+10     	; 0x23d4 <__stack+0x1d5>
    23ca:	11 c0       	rjmp	.+34     	; 0x23ee <__stack+0x1ef>
    23cc:	78 01       	movw	r14, r16
    23ce:	f8 e0       	ldi	r31, 0x08	; 8
    23d0:	ef 0e       	add	r14, r31
    23d2:	f1 1c       	adc	r15, r1
    23d4:	c7 01       	movw	r24, r14
    23d6:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    23da:	81 11       	cpse	r24, r1
    23dc:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <vTaskMissedYield>
    23e0:	f8 01       	movw	r30, r16
    23e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    23e4:	81 50       	subi	r24, 0x01	; 1
    23e6:	85 8f       	std	Z+29, r24	; 0x1d
    23e8:	85 8d       	ldd	r24, Z+29	; 0x1d
    23ea:	18 16       	cp	r1, r24
    23ec:	54 f3       	brlt	.-44     	; 0x23c2 <__stack+0x1c3>
    23ee:	8f ef       	ldi	r24, 0xFF	; 255
    23f0:	f8 01       	movw	r30, r16
    23f2:	85 8f       	std	Z+29, r24	; 0x1d
    23f4:	0f 90       	pop	r0
    23f6:	0f be       	out	0x3f, r0	; 63
    23f8:	74 d5       	rcall	.+2792   	; 0x2ee2 <xTaskResumeAll>
    23fa:	80 e0       	ldi	r24, 0x00	; 0
    23fc:	08 c0       	rjmp	.+16     	; 0x240e <__stack+0x20f>
    23fe:	f8 01       	movw	r30, r16
    2400:	82 8d       	ldd	r24, Z+26	; 0x1a
    2402:	8f 5f       	subi	r24, 0xFF	; 255
    2404:	82 8f       	std	Z+26, r24	; 0x1a
    2406:	81 89       	ldd	r24, Z+17	; 0x11
    2408:	81 11       	cpse	r24, r1
    240a:	df ce       	rjmp	.-578    	; 0x21ca <xQueueGive+0x74>
    240c:	e8 ce       	rjmp	.-560    	; 0x21de <xQueueGive+0x88>
    240e:	0f 90       	pop	r0
    2410:	0f 90       	pop	r0
    2412:	0f 90       	pop	r0
    2414:	0f 90       	pop	r0
    2416:	0f 90       	pop	r0
    2418:	df 91       	pop	r29
    241a:	cf 91       	pop	r28
    241c:	1f 91       	pop	r17
    241e:	0f 91       	pop	r16
    2420:	ff 90       	pop	r15
    2422:	ef 90       	pop	r14
    2424:	df 90       	pop	r13
    2426:	cf 90       	pop	r12
    2428:	bf 90       	pop	r11
    242a:	af 90       	pop	r10
    242c:	9f 90       	pop	r9
    242e:	08 95       	ret

00002430 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2430:	cf 93       	push	r28
    2432:	df 93       	push	r29
    2434:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2436:	92 8d       	ldd	r25, Z+26	; 0x1a
    2438:	83 8d       	ldd	r24, Z+27	; 0x1b
    243a:	98 17       	cp	r25, r24
    243c:	d0 f4       	brcc	.+52     	; 0x2472 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    243e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2440:	8f 5f       	subi	r24, 0xFF	; 255
    2442:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2444:	86 8d       	ldd	r24, Z+30	; 0x1e
    2446:	8f 3f       	cpi	r24, 0xFF	; 255
    2448:	79 f4       	brne	.+30     	; 0x2468 <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    244a:	81 89       	ldd	r24, Z+17	; 0x11
    244c:	88 23       	and	r24, r24
    244e:	99 f0       	breq	.+38     	; 0x2476 <xQueueGiveFromISR+0x46>
    2450:	eb 01       	movw	r28, r22
    2452:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2454:	41 96       	adiw	r24, 0x11	; 17
    2456:	0e 94 66 1a 	call	0x34cc	; 0x34cc <xTaskRemoveFromEventList>
    245a:	88 23       	and	r24, r24
    245c:	71 f0       	breq	.+28     	; 0x247a <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    245e:	20 97       	sbiw	r28, 0x00	; 0
    2460:	71 f0       	breq	.+28     	; 0x247e <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2462:	81 e0       	ldi	r24, 0x01	; 1
    2464:	88 83       	st	Y, r24
    2466:	0c c0       	rjmp	.+24     	; 0x2480 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2468:	86 8d       	ldd	r24, Z+30	; 0x1e
    246a:	8f 5f       	subi	r24, 0xFF	; 255
    246c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    246e:	81 e0       	ldi	r24, 0x01	; 1
    2470:	07 c0       	rjmp	.+14     	; 0x2480 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2472:	80 e0       	ldi	r24, 0x00	; 0
    2474:	05 c0       	rjmp	.+10     	; 0x2480 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2476:	81 e0       	ldi	r24, 0x01	; 1
    2478:	03 c0       	rjmp	.+6      	; 0x2480 <xQueueGiveFromISR+0x50>
    247a:	81 e0       	ldi	r24, 0x01	; 1
    247c:	01 c0       	rjmp	.+2      	; 0x2480 <xQueueGiveFromISR+0x50>
    247e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2480:	df 91       	pop	r29
    2482:	cf 91       	pop	r28
    2484:	08 95       	ret

00002486 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2486:	6f 92       	push	r6
    2488:	7f 92       	push	r7
    248a:	8f 92       	push	r8
    248c:	9f 92       	push	r9
    248e:	af 92       	push	r10
    2490:	bf 92       	push	r11
    2492:	cf 92       	push	r12
    2494:	df 92       	push	r13
    2496:	ef 92       	push	r14
    2498:	ff 92       	push	r15
    249a:	0f 93       	push	r16
    249c:	1f 93       	push	r17
    249e:	cf 93       	push	r28
    24a0:	df 93       	push	r29
    24a2:	00 d0       	rcall	.+0      	; 0x24a4 <xQueueGenericReceive+0x1e>
    24a4:	1f 92       	push	r1
    24a6:	1f 92       	push	r1
    24a8:	cd b7       	in	r28, 0x3d	; 61
    24aa:	de b7       	in	r29, 0x3e	; 62
    24ac:	8c 01       	movw	r16, r24
    24ae:	5b 01       	movw	r10, r22
    24b0:	5d 83       	std	Y+5, r21	; 0x05
    24b2:	4c 83       	std	Y+4, r20	; 0x04
    24b4:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    24b6:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    24b8:	77 24       	eor	r7, r7
    24ba:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    24bc:	99 24       	eor	r9, r9
    24be:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24c0:	6c 01       	movw	r12, r24
    24c2:	88 e0       	ldi	r24, 0x08	; 8
    24c4:	c8 0e       	add	r12, r24
    24c6:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24c8:	78 01       	movw	r14, r16
    24ca:	e1 e1       	ldi	r30, 0x11	; 17
    24cc:	ee 0e       	add	r14, r30
    24ce:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    24d0:	0f b6       	in	r0, 0x3f	; 63
    24d2:	f8 94       	cli
    24d4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    24d6:	f8 01       	movw	r30, r16
    24d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    24da:	88 23       	and	r24, r24
    24dc:	09 f4       	brne	.+2      	; 0x24e0 <xQueueGenericReceive+0x5a>
    24de:	43 c0       	rjmp	.+134    	; 0x2566 <xQueueGenericReceive+0xe0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    24e0:	e6 80       	ldd	r14, Z+6	; 0x06
    24e2:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    24e4:	44 8d       	ldd	r20, Z+28	; 0x1c
    24e6:	44 23       	and	r20, r20
    24e8:	a9 f0       	breq	.+42     	; 0x2514 <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    24ea:	50 e0       	ldi	r21, 0x00	; 0
    24ec:	c7 01       	movw	r24, r14
    24ee:	84 0f       	add	r24, r20
    24f0:	95 1f       	adc	r25, r21
    24f2:	97 83       	std	Z+7, r25	; 0x07
    24f4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    24f6:	22 81       	ldd	r18, Z+2	; 0x02
    24f8:	33 81       	ldd	r19, Z+3	; 0x03
    24fa:	82 17       	cp	r24, r18
    24fc:	93 07       	cpc	r25, r19
    24fe:	20 f0       	brcs	.+8      	; 0x2508 <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2500:	80 81       	ld	r24, Z
    2502:	91 81       	ldd	r25, Z+1	; 0x01
    2504:	97 83       	std	Z+7, r25	; 0x07
    2506:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2508:	f8 01       	movw	r30, r16
    250a:	66 81       	ldd	r22, Z+6	; 0x06
    250c:	77 81       	ldd	r23, Z+7	; 0x07
    250e:	c5 01       	movw	r24, r10
    2510:	0e 94 27 22 	call	0x444e	; 0x444e <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    2514:	61 10       	cpse	r6, r1
    2516:	18 c0       	rjmp	.+48     	; 0x2548 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    2518:	f8 01       	movw	r30, r16
    251a:	82 8d       	ldd	r24, Z+26	; 0x1a
    251c:	81 50       	subi	r24, 0x01	; 1
    251e:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2520:	80 81       	ld	r24, Z
    2522:	91 81       	ldd	r25, Z+1	; 0x01
    2524:	89 2b       	or	r24, r25
    2526:	29 f4       	brne	.+10     	; 0x2532 <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2528:	0e 94 9a 1b 	call	0x3734	; 0x3734 <pvTaskIncrementMutexHeldCount>
    252c:	f8 01       	movw	r30, r16
    252e:	93 83       	std	Z+3, r25	; 0x03
    2530:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2532:	f8 01       	movw	r30, r16
    2534:	80 85       	ldd	r24, Z+8	; 0x08
    2536:	88 23       	and	r24, r24
    2538:	91 f0       	breq	.+36     	; 0x255e <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    253a:	c8 01       	movw	r24, r16
    253c:	08 96       	adiw	r24, 0x08	; 8
    253e:	c6 d7       	rcall	.+3980   	; 0x34cc <xTaskRemoveFromEventList>
    2540:	81 30       	cpi	r24, 0x01	; 1
    2542:	69 f4       	brne	.+26     	; 0x255e <xQueueGenericReceive+0xd8>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2544:	11 db       	rcall	.-2526   	; 0x1b68 <vPortYield>
    2546:	0b c0       	rjmp	.+22     	; 0x255e <xQueueGenericReceive+0xd8>
    2548:	f8 01       	movw	r30, r16
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    254a:	f7 82       	std	Z+7, r15	; 0x07
    254c:	e6 82       	std	Z+6, r14	; 0x06
    254e:	81 89       	ldd	r24, Z+17	; 0x11

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2550:	88 23       	and	r24, r24
    2552:	29 f0       	breq	.+10     	; 0x255e <xQueueGenericReceive+0xd8>
    2554:	c8 01       	movw	r24, r16
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2556:	41 96       	adiw	r24, 0x11	; 17
    2558:	b9 d7       	rcall	.+3954   	; 0x34cc <xTaskRemoveFromEventList>
    255a:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    255c:	05 db       	rcall	.-2550   	; 0x1b68 <vPortYield>
    255e:	0f 90       	pop	r0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2560:	0f be       	out	0x3f, r0	; 63
    2562:	81 e0       	ldi	r24, 0x01	; 1
				return pdPASS;
    2564:	08 c1       	rjmp	.+528    	; 0x2776 <xQueueGenericReceive+0x2f0>
    2566:	8c 81       	ldd	r24, Y+4	; 0x04
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2568:	9d 81       	ldd	r25, Y+5	; 0x05
    256a:	89 2b       	or	r24, r25
    256c:	21 f4       	brne	.+8      	; 0x2576 <xQueueGenericReceive+0xf0>
    256e:	0f 90       	pop	r0
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2570:	0f be       	out	0x3f, r0	; 63
    2572:	80 e0       	ldi	r24, 0x00	; 0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2574:	00 c1       	rjmp	.+512    	; 0x2776 <xQueueGenericReceive+0x2f0>
    2576:	81 10       	cpse	r8, r1
				}
				else if( xEntryTimeSet == pdFALSE )
    2578:	04 c0       	rjmp	.+8      	; 0x2582 <xQueueGenericReceive+0xfc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    257a:	ce 01       	movw	r24, r28
    257c:	01 96       	adiw	r24, 0x01	; 1
    257e:	ee d7       	rcall	.+4060   	; 0x355c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2580:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2582:	0f 90       	pop	r0
    2584:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2586:	a7 d4       	rcall	.+2382   	; 0x2ed6 <vTaskSuspendAll>
    2588:	0f b6       	in	r0, 0x3f	; 63
		prvLockQueue( pxQueue );
    258a:	f8 94       	cli
    258c:	0f 92       	push	r0
    258e:	f8 01       	movw	r30, r16
    2590:	85 8d       	ldd	r24, Z+29	; 0x1d
    2592:	8f 3f       	cpi	r24, 0xFF	; 255
    2594:	09 f4       	brne	.+2      	; 0x2598 <xQueueGenericReceive+0x112>
    2596:	15 8e       	std	Z+29, r1	; 0x1d
    2598:	f8 01       	movw	r30, r16
    259a:	86 8d       	ldd	r24, Z+30	; 0x1e
    259c:	8f 3f       	cpi	r24, 0xFF	; 255
    259e:	09 f4       	brne	.+2      	; 0x25a2 <xQueueGenericReceive+0x11c>
    25a0:	16 8e       	std	Z+30, r1	; 0x1e
    25a2:	0f 90       	pop	r0
    25a4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    25a6:	be 01       	movw	r22, r28
    25a8:	6c 5f       	subi	r22, 0xFC	; 252
    25aa:	7f 4f       	sbci	r23, 0xFF	; 255
    25ac:	ce 01       	movw	r24, r28
    25ae:	01 96       	adiw	r24, 0x01	; 1
    25b0:	e0 d7       	rcall	.+4032   	; 0x3572 <xTaskCheckForTimeOut>
    25b2:	81 11       	cpse	r24, r1
    25b4:	97 c0       	rjmp	.+302    	; 0x26e4 <xQueueGenericReceive+0x25e>
    25b6:	0f b6       	in	r0, 0x3f	; 63

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    25b8:	f8 94       	cli
    25ba:	0f 92       	push	r0
    25bc:	f8 01       	movw	r30, r16
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    25be:	82 8d       	ldd	r24, Z+26	; 0x1a
    25c0:	0f 90       	pop	r0
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    25c2:	0f be       	out	0x3f, r0	; 63
    25c4:	81 11       	cpse	r24, r1
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    25c6:	51 c0       	rjmp	.+162    	; 0x266a <xQueueGenericReceive+0x1e4>
    25c8:	80 81       	ld	r24, Z
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    25ca:	91 81       	ldd	r25, Z+1	; 0x01
    25cc:	89 2b       	or	r24, r25
    25ce:	49 f4       	brne	.+18     	; 0x25e2 <xQueueGenericReceive+0x15c>
    25d0:	0f b6       	in	r0, 0x3f	; 63
					{
						taskENTER_CRITICAL();
    25d2:	f8 94       	cli
    25d4:	0f 92       	push	r0
    25d6:	82 81       	ldd	r24, Z+2	; 0x02
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    25d8:	93 81       	ldd	r25, Z+3	; 0x03
    25da:	0e 94 f8 1a 	call	0x35f0	; 0x35f0 <vTaskPriorityInherit>
    25de:	0f 90       	pop	r0
						}
						taskEXIT_CRITICAL();
    25e0:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    25e2:	6c 81       	ldd	r22, Y+4	; 0x04
    25e4:	7d 81       	ldd	r23, Y+5	; 0x05
    25e6:	c7 01       	movw	r24, r14
    25e8:	16 d7       	rcall	.+3628   	; 0x3416 <vTaskPlaceOnEventList>
    25ea:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    25ec:	f8 94       	cli
    25ee:	0f 92       	push	r0
    25f0:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    25f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    25f4:	18 16       	cp	r1, r24
    25f6:	9c f4       	brge	.+38     	; 0x261e <xQueueGenericReceive+0x198>
    25f8:	81 89       	ldd	r24, Z+17	; 0x11
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25fa:	81 11       	cpse	r24, r1
    25fc:	05 c0       	rjmp	.+10     	; 0x2608 <xQueueGenericReceive+0x182>
    25fe:	0f c0       	rjmp	.+30     	; 0x261e <xQueueGenericReceive+0x198>
    2600:	f8 01       	movw	r30, r16
    2602:	81 89       	ldd	r24, Z+17	; 0x11
    2604:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2606:	59 f0       	breq	.+22     	; 0x261e <xQueueGenericReceive+0x198>
    2608:	c7 01       	movw	r24, r14
    260a:	60 d7       	rcall	.+3776   	; 0x34cc <xTaskRemoveFromEventList>
    260c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    260e:	ec d7       	rcall	.+4056   	; 0x35e8 <vTaskMissedYield>
    2610:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2612:	86 8d       	ldd	r24, Z+30	; 0x1e
    2614:	81 50       	subi	r24, 0x01	; 1
    2616:	86 8f       	std	Z+30, r24	; 0x1e
    2618:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    261a:	18 16       	cp	r1, r24
    261c:	8c f3       	brlt	.-30     	; 0x2600 <xQueueGenericReceive+0x17a>
    261e:	f8 01       	movw	r30, r16
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2620:	96 8e       	std	Z+30, r9	; 0x1e
    2622:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    2624:	0f be       	out	0x3f, r0	; 63
    2626:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2628:	f8 94       	cli
    262a:	0f 92       	push	r0
    262c:	85 8d       	ldd	r24, Z+29	; 0x1d
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    262e:	18 16       	cp	r1, r24
    2630:	9c f4       	brge	.+38     	; 0x2658 <xQueueGenericReceive+0x1d2>
    2632:	80 85       	ldd	r24, Z+8	; 0x08
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2634:	81 11       	cpse	r24, r1
    2636:	05 c0       	rjmp	.+10     	; 0x2642 <xQueueGenericReceive+0x1bc>
    2638:	0f c0       	rjmp	.+30     	; 0x2658 <xQueueGenericReceive+0x1d2>
    263a:	f8 01       	movw	r30, r16
    263c:	80 85       	ldd	r24, Z+8	; 0x08
    263e:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2640:	59 f0       	breq	.+22     	; 0x2658 <xQueueGenericReceive+0x1d2>
    2642:	c6 01       	movw	r24, r12
    2644:	43 d7       	rcall	.+3718   	; 0x34cc <xTaskRemoveFromEventList>
    2646:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    2648:	cf d7       	rcall	.+3998   	; 0x35e8 <vTaskMissedYield>
    264a:	f8 01       	movw	r30, r16
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    264c:	85 8d       	ldd	r24, Z+29	; 0x1d
    264e:	81 50       	subi	r24, 0x01	; 1
    2650:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2652:	85 8d       	ldd	r24, Z+29	; 0x1d
    2654:	18 16       	cp	r1, r24
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2656:	8c f3       	brlt	.-30     	; 0x263a <xQueueGenericReceive+0x1b4>
    2658:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    265a:	95 8e       	std	Z+29, r9	; 0x1d
    265c:	0f 90       	pop	r0
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    265e:	0f be       	out	0x3f, r0	; 63
    2660:	40 d4       	rcall	.+2176   	; 0x2ee2 <xTaskResumeAll>
    2662:	81 11       	cpse	r24, r1
    2664:	35 cf       	rjmp	.-406    	; 0x24d0 <xQueueGenericReceive+0x4a>
				{
					portYIELD_WITHIN_API();
    2666:	80 da       	rcall	.-2816   	; 0x1b68 <vPortYield>
    2668:	33 cf       	rjmp	.-410    	; 0x24d0 <xQueueGenericReceive+0x4a>
    266a:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    266c:	f8 94       	cli
    266e:	0f 92       	push	r0
    2670:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2672:	86 8d       	ldd	r24, Z+30	; 0x1e
    2674:	18 16       	cp	r1, r24
    2676:	9c f4       	brge	.+38     	; 0x269e <xQueueGenericReceive+0x218>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2678:	81 89       	ldd	r24, Z+17	; 0x11
    267a:	81 11       	cpse	r24, r1
    267c:	05 c0       	rjmp	.+10     	; 0x2688 <xQueueGenericReceive+0x202>
    267e:	0f c0       	rjmp	.+30     	; 0x269e <xQueueGenericReceive+0x218>
    2680:	f8 01       	movw	r30, r16
    2682:	81 89       	ldd	r24, Z+17	; 0x11
    2684:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2686:	59 f0       	breq	.+22     	; 0x269e <xQueueGenericReceive+0x218>
    2688:	c7 01       	movw	r24, r14
    268a:	20 d7       	rcall	.+3648   	; 0x34cc <xTaskRemoveFromEventList>
    268c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    268e:	ac d7       	rcall	.+3928   	; 0x35e8 <vTaskMissedYield>
    2690:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2692:	86 8d       	ldd	r24, Z+30	; 0x1e
    2694:	81 50       	subi	r24, 0x01	; 1
    2696:	86 8f       	std	Z+30, r24	; 0x1e
    2698:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    269a:	18 16       	cp	r1, r24
    269c:	8c f3       	brlt	.-30     	; 0x2680 <xQueueGenericReceive+0x1fa>
    269e:	f8 01       	movw	r30, r16
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    26a0:	96 8e       	std	Z+30, r9	; 0x1e
    26a2:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    26a4:	0f be       	out	0x3f, r0	; 63
    26a6:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    26a8:	f8 94       	cli
    26aa:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    26ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    26ae:	18 16       	cp	r1, r24
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    26b0:	9c f4       	brge	.+38     	; 0x26d8 <xQueueGenericReceive+0x252>
    26b2:	80 85       	ldd	r24, Z+8	; 0x08
    26b4:	81 11       	cpse	r24, r1
    26b6:	05 c0       	rjmp	.+10     	; 0x26c2 <xQueueGenericReceive+0x23c>
    26b8:	0f c0       	rjmp	.+30     	; 0x26d8 <xQueueGenericReceive+0x252>
    26ba:	f8 01       	movw	r30, r16
    26bc:	80 85       	ldd	r24, Z+8	; 0x08
    26be:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    26c0:	59 f0       	breq	.+22     	; 0x26d8 <xQueueGenericReceive+0x252>
    26c2:	c6 01       	movw	r24, r12
    26c4:	03 d7       	rcall	.+3590   	; 0x34cc <xTaskRemoveFromEventList>
				{
					vTaskMissedYield();
    26c6:	81 11       	cpse	r24, r1
    26c8:	8f d7       	rcall	.+3870   	; 0x35e8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    26ca:	f8 01       	movw	r30, r16
    26cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    26ce:	81 50       	subi	r24, 0x01	; 1
    26d0:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    26d2:	85 8d       	ldd	r24, Z+29	; 0x1d
    26d4:	18 16       	cp	r1, r24
    26d6:	8c f3       	brlt	.-30     	; 0x26ba <xQueueGenericReceive+0x234>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    26d8:	f8 01       	movw	r30, r16
    26da:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    26dc:	0f 90       	pop	r0
    26de:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    26e0:	00 d4       	rcall	.+2048   	; 0x2ee2 <xTaskResumeAll>
    26e2:	f6 ce       	rjmp	.-532    	; 0x24d0 <xQueueGenericReceive+0x4a>
    26e4:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    26e6:	f8 94       	cli
    26e8:	0f 92       	push	r0
    26ea:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    26ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    26ee:	18 16       	cp	r1, r24
    26f0:	c4 f4       	brge	.+48     	; 0x2722 <xQueueGenericReceive+0x29c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26f2:	81 89       	ldd	r24, Z+17	; 0x11
    26f4:	81 11       	cpse	r24, r1
    26f6:	06 c0       	rjmp	.+12     	; 0x2704 <xQueueGenericReceive+0x27e>
    26f8:	14 c0       	rjmp	.+40     	; 0x2722 <xQueueGenericReceive+0x29c>
    26fa:	f8 01       	movw	r30, r16
    26fc:	81 89       	ldd	r24, Z+17	; 0x11
    26fe:	81 11       	cpse	r24, r1
    2700:	05 c0       	rjmp	.+10     	; 0x270c <xQueueGenericReceive+0x286>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2702:	0f c0       	rjmp	.+30     	; 0x2722 <xQueueGenericReceive+0x29c>
    2704:	78 01       	movw	r14, r16
    2706:	f1 e1       	ldi	r31, 0x11	; 17
    2708:	ef 0e       	add	r14, r31
    270a:	f1 1c       	adc	r15, r1
    270c:	c7 01       	movw	r24, r14
    270e:	de d6       	rcall	.+3516   	; 0x34cc <xTaskRemoveFromEventList>
    2710:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2712:	6a d7       	rcall	.+3796   	; 0x35e8 <vTaskMissedYield>
    2714:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2716:	86 8d       	ldd	r24, Z+30	; 0x1e
    2718:	81 50       	subi	r24, 0x01	; 1
    271a:	86 8f       	std	Z+30, r24	; 0x1e
    271c:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    271e:	18 16       	cp	r1, r24
    2720:	64 f3       	brlt	.-40     	; 0x26fa <xQueueGenericReceive+0x274>
    2722:	8f ef       	ldi	r24, 0xFF	; 255
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2724:	f8 01       	movw	r30, r16
    2726:	86 8f       	std	Z+30, r24	; 0x1e
    2728:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    272a:	0f be       	out	0x3f, r0	; 63
    272c:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    272e:	f8 94       	cli
    2730:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2732:	85 8d       	ldd	r24, Z+29	; 0x1d
    2734:	18 16       	cp	r1, r24
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2736:	c4 f4       	brge	.+48     	; 0x2768 <xQueueGenericReceive+0x2e2>
    2738:	80 85       	ldd	r24, Z+8	; 0x08
    273a:	81 11       	cpse	r24, r1
    273c:	06 c0       	rjmp	.+12     	; 0x274a <xQueueGenericReceive+0x2c4>
    273e:	14 c0       	rjmp	.+40     	; 0x2768 <xQueueGenericReceive+0x2e2>
    2740:	f8 01       	movw	r30, r16
    2742:	80 85       	ldd	r24, Z+8	; 0x08
    2744:	81 11       	cpse	r24, r1
    2746:	05 c0       	rjmp	.+10     	; 0x2752 <xQueueGenericReceive+0x2cc>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2748:	0f c0       	rjmp	.+30     	; 0x2768 <xQueueGenericReceive+0x2e2>
    274a:	78 01       	movw	r14, r16
    274c:	f8 e0       	ldi	r31, 0x08	; 8
    274e:	ef 0e       	add	r14, r31
    2750:	f1 1c       	adc	r15, r1
    2752:	c7 01       	movw	r24, r14
    2754:	bb d6       	rcall	.+3446   	; 0x34cc <xTaskRemoveFromEventList>
				{
					vTaskMissedYield();
    2756:	81 11       	cpse	r24, r1
    2758:	47 d7       	rcall	.+3726   	; 0x35e8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    275a:	f8 01       	movw	r30, r16
    275c:	85 8d       	ldd	r24, Z+29	; 0x1d
    275e:	81 50       	subi	r24, 0x01	; 1
    2760:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2762:	85 8d       	ldd	r24, Z+29	; 0x1d
    2764:	18 16       	cp	r1, r24
    2766:	64 f3       	brlt	.-40     	; 0x2740 <xQueueGenericReceive+0x2ba>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2768:	8f ef       	ldi	r24, 0xFF	; 255
    276a:	f8 01       	movw	r30, r16
    276c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    276e:	0f 90       	pop	r0
    2770:	0f be       	out	0x3f, r0	; 63
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    2772:	b7 d3       	rcall	.+1902   	; 0x2ee2 <xTaskResumeAll>
    2774:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2776:	0f 90       	pop	r0
		}
	}
}
    2778:	0f 90       	pop	r0
    277a:	0f 90       	pop	r0
    277c:	0f 90       	pop	r0
    277e:	0f 90       	pop	r0
    2780:	df 91       	pop	r29
    2782:	cf 91       	pop	r28
    2784:	1f 91       	pop	r17
    2786:	0f 91       	pop	r16
    2788:	ff 90       	pop	r15
    278a:	ef 90       	pop	r14
    278c:	df 90       	pop	r13
    278e:	cf 90       	pop	r12
    2790:	bf 90       	pop	r11
    2792:	af 90       	pop	r10
    2794:	9f 90       	pop	r9
    2796:	8f 90       	pop	r8
    2798:	7f 90       	pop	r7
    279a:	6f 90       	pop	r6
    279c:	08 95       	ret

0000279e <xTaskGenericCreate>:
    279e:	4f 92       	push	r4
    27a0:	5f 92       	push	r5
    27a2:	6f 92       	push	r6
    27a4:	7f 92       	push	r7
    27a6:	8f 92       	push	r8
    27a8:	9f 92       	push	r9
    27aa:	af 92       	push	r10
    27ac:	bf 92       	push	r11
    27ae:	cf 92       	push	r12
    27b0:	df 92       	push	r13
    27b2:	ef 92       	push	r14
    27b4:	ff 92       	push	r15
    27b6:	0f 93       	push	r16
    27b8:	1f 93       	push	r17
    27ba:	cf 93       	push	r28
    27bc:	df 93       	push	r29
    27be:	4c 01       	movw	r8, r24
    27c0:	eb 01       	movw	r28, r22
    27c2:	5a 01       	movw	r10, r20
    27c4:	29 01       	movw	r4, r18
    27c6:	c1 14       	cp	r12, r1
    27c8:	d1 04       	cpc	r13, r1
    27ca:	31 f4       	brne	.+12     	; 0x27d8 <xTaskGenericCreate+0x3a>
    27cc:	ca 01       	movw	r24, r20
    27ce:	51 d8       	rcall	.-3934   	; 0x1872 <pvPortMalloc>
    27d0:	6c 01       	movw	r12, r24
    27d2:	89 2b       	or	r24, r25
    27d4:	09 f4       	brne	.+2      	; 0x27d8 <xTaskGenericCreate+0x3a>
    27d6:	e1 c0       	rjmp	.+450    	; 0x299a <xTaskGenericCreate+0x1fc>
    27d8:	88 e2       	ldi	r24, 0x28	; 40
    27da:	90 e0       	ldi	r25, 0x00	; 0
    27dc:	4a d8       	rcall	.-3948   	; 0x1872 <pvPortMalloc>
    27de:	3c 01       	movw	r6, r24
    27e0:	00 97       	sbiw	r24, 0x00	; 0
    27e2:	b9 f0       	breq	.+46     	; 0x2812 <xTaskGenericCreate+0x74>
    27e4:	fc 01       	movw	r30, r24
    27e6:	d0 8e       	std	Z+24, r13	; 0x18
    27e8:	c7 8a       	std	Z+23, r12	; 0x17
    27ea:	a5 01       	movw	r20, r10
    27ec:	65 ea       	ldi	r22, 0xA5	; 165
    27ee:	70 e0       	ldi	r23, 0x00	; 0
    27f0:	c6 01       	movw	r24, r12
    27f2:	0e 94 30 22 	call	0x4460	; 0x4460 <memset>
    27f6:	f1 e0       	ldi	r31, 0x01	; 1
    27f8:	af 1a       	sub	r10, r31
    27fa:	b1 08       	sbc	r11, r1
    27fc:	f3 01       	movw	r30, r6
    27fe:	87 89       	ldd	r24, Z+23	; 0x17
    2800:	90 8d       	ldd	r25, Z+24	; 0x18
    2802:	a8 0e       	add	r10, r24
    2804:	b9 1e       	adc	r11, r25
    2806:	88 81       	ld	r24, Y
    2808:	81 8f       	std	Z+25, r24	; 0x19
    280a:	88 81       	ld	r24, Y
    280c:	81 11       	cpse	r24, r1
    280e:	04 c0       	rjmp	.+8      	; 0x2818 <xTaskGenericCreate+0x7a>
    2810:	13 c0       	rjmp	.+38     	; 0x2838 <xTaskGenericCreate+0x9a>
    2812:	c6 01       	movw	r24, r12
    2814:	63 d8       	rcall	.-3898   	; 0x18dc <vPortFree>
    2816:	c1 c0       	rjmp	.+386    	; 0x299a <xTaskGenericCreate+0x1fc>
    2818:	d3 01       	movw	r26, r6
    281a:	5a 96       	adiw	r26, 0x1a	; 26
    281c:	fe 01       	movw	r30, r28
    281e:	31 96       	adiw	r30, 0x01	; 1
    2820:	9e 01       	movw	r18, r28
    2822:	28 5f       	subi	r18, 0xF8	; 248
    2824:	3f 4f       	sbci	r19, 0xFF	; 255
    2826:	ef 01       	movw	r28, r30
    2828:	81 91       	ld	r24, Z+
    282a:	8d 93       	st	X+, r24
    282c:	88 81       	ld	r24, Y
    282e:	88 23       	and	r24, r24
    2830:	19 f0       	breq	.+6      	; 0x2838 <xTaskGenericCreate+0x9a>
    2832:	2e 17       	cp	r18, r30
    2834:	3f 07       	cpc	r19, r31
    2836:	b9 f7       	brne	.-18     	; 0x2826 <xTaskGenericCreate+0x88>
    2838:	f3 01       	movw	r30, r6
    283a:	10 a2       	std	Z+32, r1	; 0x20
    283c:	10 2f       	mov	r17, r16
    283e:	04 30       	cpi	r16, 0x04	; 4
    2840:	08 f0       	brcs	.+2      	; 0x2844 <xTaskGenericCreate+0xa6>
    2842:	13 e0       	ldi	r17, 0x03	; 3
    2844:	f3 01       	movw	r30, r6
    2846:	16 8b       	std	Z+22, r17	; 0x16
    2848:	11 a3       	std	Z+33, r17	; 0x21
    284a:	12 a2       	std	Z+34, r1	; 0x22
    284c:	e3 01       	movw	r28, r6
    284e:	22 96       	adiw	r28, 0x02	; 2
    2850:	ce 01       	movw	r24, r28
    2852:	53 d8       	rcall	.-3930   	; 0x18fa <vListInitialiseItem>
    2854:	c3 01       	movw	r24, r6
    2856:	0c 96       	adiw	r24, 0x0c	; 12
    2858:	50 d8       	rcall	.-3936   	; 0x18fa <vListInitialiseItem>
    285a:	f3 01       	movw	r30, r6
    285c:	71 86       	std	Z+9, r7	; 0x09
    285e:	60 86       	std	Z+8, r6	; 0x08
    2860:	84 e0       	ldi	r24, 0x04	; 4
    2862:	90 e0       	ldi	r25, 0x00	; 0
    2864:	81 1b       	sub	r24, r17
    2866:	91 09       	sbc	r25, r1
    2868:	95 87       	std	Z+13, r25	; 0x0d
    286a:	84 87       	std	Z+12, r24	; 0x0c
    286c:	73 8a       	std	Z+19, r7	; 0x13
    286e:	62 8a       	std	Z+18, r6	; 0x12
    2870:	13 a2       	std	Z+35, r1	; 0x23
    2872:	14 a2       	std	Z+36, r1	; 0x24
    2874:	15 a2       	std	Z+37, r1	; 0x25
    2876:	16 a2       	std	Z+38, r1	; 0x26
    2878:	17 a2       	std	Z+39, r1	; 0x27
    287a:	a2 01       	movw	r20, r4
    287c:	b4 01       	movw	r22, r8
    287e:	c5 01       	movw	r24, r10
    2880:	b8 d8       	rcall	.-3728   	; 0x19f2 <pxPortInitialiseStack>
    2882:	f3 01       	movw	r30, r6
    2884:	91 83       	std	Z+1, r25	; 0x01
    2886:	80 83       	st	Z, r24
    2888:	e1 14       	cp	r14, r1
    288a:	f1 04       	cpc	r15, r1
    288c:	19 f0       	breq	.+6      	; 0x2894 <xTaskGenericCreate+0xf6>
    288e:	f7 01       	movw	r30, r14
    2890:	71 82       	std	Z+1, r7	; 0x01
    2892:	60 82       	st	Z, r6
    2894:	0f b6       	in	r0, 0x3f	; 63
    2896:	f8 94       	cli
    2898:	0f 92       	push	r0
    289a:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <uxCurrentNumberOfTasks>
    289e:	8f 5f       	subi	r24, 0xFF	; 255
    28a0:	80 93 fd 15 	sts	0x15FD, r24	; 0x8015fd <uxCurrentNumberOfTasks>
    28a4:	80 91 54 16 	lds	r24, 0x1654	; 0x801654 <pxCurrentTCB>
    28a8:	90 91 55 16 	lds	r25, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    28ac:	89 2b       	or	r24, r25
    28ae:	b1 f5       	brne	.+108    	; 0x291c <xTaskGenericCreate+0x17e>
    28b0:	70 92 55 16 	sts	0x1655, r7	; 0x801655 <pxCurrentTCB+0x1>
    28b4:	60 92 54 16 	sts	0x1654, r6	; 0x801654 <pxCurrentTCB>
    28b8:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <uxCurrentNumberOfTasks>
    28bc:	81 30       	cpi	r24, 0x01	; 1
    28be:	09 f0       	breq	.+2      	; 0x28c2 <xTaskGenericCreate+0x124>
    28c0:	3c c0       	rjmp	.+120    	; 0x293a <xTaskGenericCreate+0x19c>
    28c2:	80 e3       	ldi	r24, 0x30	; 48
    28c4:	96 e1       	ldi	r25, 0x16	; 22
    28c6:	0b d8       	rcall	.-4074   	; 0x18de <vListInitialise>
    28c8:	89 e3       	ldi	r24, 0x39	; 57
    28ca:	96 e1       	ldi	r25, 0x16	; 22
    28cc:	08 d8       	rcall	.-4080   	; 0x18de <vListInitialise>
    28ce:	82 e4       	ldi	r24, 0x42	; 66
    28d0:	96 e1       	ldi	r25, 0x16	; 22
    28d2:	05 d8       	rcall	.-4086   	; 0x18de <vListInitialise>
    28d4:	8b e4       	ldi	r24, 0x4B	; 75
    28d6:	96 e1       	ldi	r25, 0x16	; 22
    28d8:	02 d8       	rcall	.-4092   	; 0x18de <vListInitialise>
    28da:	87 e2       	ldi	r24, 0x27	; 39
    28dc:	96 e1       	ldi	r25, 0x16	; 22
    28de:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    28e2:	8e e1       	ldi	r24, 0x1E	; 30
    28e4:	96 e1       	ldi	r25, 0x16	; 22
    28e6:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    28ea:	81 e1       	ldi	r24, 0x11	; 17
    28ec:	96 e1       	ldi	r25, 0x16	; 22
    28ee:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    28f2:	88 e0       	ldi	r24, 0x08	; 8
    28f4:	96 e1       	ldi	r25, 0x16	; 22
    28f6:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    28fa:	8e ef       	ldi	r24, 0xFE	; 254
    28fc:	95 e1       	ldi	r25, 0x15	; 21
    28fe:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2902:	87 e2       	ldi	r24, 0x27	; 39
    2904:	96 e1       	ldi	r25, 0x16	; 22
    2906:	90 93 1d 16 	sts	0x161D, r25	; 0x80161d <pxDelayedTaskList+0x1>
    290a:	80 93 1c 16 	sts	0x161C, r24	; 0x80161c <pxDelayedTaskList>
    290e:	8e e1       	ldi	r24, 0x1E	; 30
    2910:	96 e1       	ldi	r25, 0x16	; 22
    2912:	90 93 1b 16 	sts	0x161B, r25	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    2916:	80 93 1a 16 	sts	0x161A, r24	; 0x80161a <pxOverflowDelayedTaskList>
    291a:	0f c0       	rjmp	.+30     	; 0x293a <xTaskGenericCreate+0x19c>
    291c:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xSchedulerRunning>
    2920:	81 11       	cpse	r24, r1
    2922:	0b c0       	rjmp	.+22     	; 0x293a <xTaskGenericCreate+0x19c>
    2924:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    2928:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    292c:	86 89       	ldd	r24, Z+22	; 0x16
    292e:	08 17       	cp	r16, r24
    2930:	20 f0       	brcs	.+8      	; 0x293a <xTaskGenericCreate+0x19c>
    2932:	70 92 55 16 	sts	0x1655, r7	; 0x801655 <pxCurrentTCB+0x1>
    2936:	60 92 54 16 	sts	0x1654, r6	; 0x801654 <pxCurrentTCB>
    293a:	80 91 f5 15 	lds	r24, 0x15F5	; 0x8015f5 <uxTaskNumber>
    293e:	8f 5f       	subi	r24, 0xFF	; 255
    2940:	80 93 f5 15 	sts	0x15F5, r24	; 0x8015f5 <uxTaskNumber>
    2944:	f3 01       	movw	r30, r6
    2946:	86 89       	ldd	r24, Z+22	; 0x16
    2948:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    294c:	98 17       	cp	r25, r24
    294e:	10 f4       	brcc	.+4      	; 0x2954 <xTaskGenericCreate+0x1b6>
    2950:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    2954:	90 e0       	ldi	r25, 0x00	; 0
    2956:	9c 01       	movw	r18, r24
    2958:	22 0f       	add	r18, r18
    295a:	33 1f       	adc	r19, r19
    295c:	22 0f       	add	r18, r18
    295e:	33 1f       	adc	r19, r19
    2960:	22 0f       	add	r18, r18
    2962:	33 1f       	adc	r19, r19
    2964:	82 0f       	add	r24, r18
    2966:	93 1f       	adc	r25, r19
    2968:	be 01       	movw	r22, r28
    296a:	80 5d       	subi	r24, 0xD0	; 208
    296c:	99 4e       	sbci	r25, 0xE9	; 233
    296e:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    2972:	0f 90       	pop	r0
    2974:	0f be       	out	0x3f, r0	; 63
    2976:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xSchedulerRunning>
    297a:	88 23       	and	r24, r24
    297c:	51 f0       	breq	.+20     	; 0x2992 <xTaskGenericCreate+0x1f4>
    297e:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    2982:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2986:	86 89       	ldd	r24, Z+22	; 0x16
    2988:	80 17       	cp	r24, r16
    298a:	28 f4       	brcc	.+10     	; 0x2996 <xTaskGenericCreate+0x1f8>
    298c:	ed d8       	rcall	.-3622   	; 0x1b68 <vPortYield>
    298e:	81 e0       	ldi	r24, 0x01	; 1
    2990:	05 c0       	rjmp	.+10     	; 0x299c <xTaskGenericCreate+0x1fe>
    2992:	81 e0       	ldi	r24, 0x01	; 1
    2994:	03 c0       	rjmp	.+6      	; 0x299c <xTaskGenericCreate+0x1fe>
    2996:	81 e0       	ldi	r24, 0x01	; 1
    2998:	01 c0       	rjmp	.+2      	; 0x299c <xTaskGenericCreate+0x1fe>
    299a:	8f ef       	ldi	r24, 0xFF	; 255
    299c:	df 91       	pop	r29
    299e:	cf 91       	pop	r28
    29a0:	1f 91       	pop	r17
    29a2:	0f 91       	pop	r16
    29a4:	ff 90       	pop	r15
    29a6:	ef 90       	pop	r14
    29a8:	df 90       	pop	r13
    29aa:	cf 90       	pop	r12
    29ac:	bf 90       	pop	r11
    29ae:	af 90       	pop	r10
    29b0:	9f 90       	pop	r9
    29b2:	8f 90       	pop	r8
    29b4:	7f 90       	pop	r7
    29b6:	6f 90       	pop	r6
    29b8:	5f 90       	pop	r5
    29ba:	4f 90       	pop	r4
    29bc:	08 95       	ret

000029be <vTaskDelay>:
    29be:	9f 92       	push	r9
    29c0:	af 92       	push	r10
    29c2:	bf 92       	push	r11
    29c4:	cf 92       	push	r12
    29c6:	df 92       	push	r13
    29c8:	ef 92       	push	r14
    29ca:	ff 92       	push	r15
    29cc:	0f 93       	push	r16
    29ce:	1f 93       	push	r17
    29d0:	cf 93       	push	r28
    29d2:	df 93       	push	r29
    29d4:	00 97       	sbiw	r24, 0x00	; 0
    29d6:	09 f4       	brne	.+2      	; 0x29da <vTaskDelay+0x1c>
    29d8:	7e c1       	rjmp	.+764    	; 0x2cd6 <vTaskDelay+0x318>
    29da:	20 91 f2 15 	lds	r18, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    29de:	2f 5f       	subi	r18, 0xFF	; 255
    29e0:	20 93 f2 15 	sts	0x15F2, r18	; 0x8015f2 <uxSchedulerSuspended>
    29e4:	c0 91 fb 15 	lds	r28, 0x15FB	; 0x8015fb <xTickCount>
    29e8:	d0 91 fc 15 	lds	r29, 0x15FC	; 0x8015fc <xTickCount+0x1>
    29ec:	c8 0f       	add	r28, r24
    29ee:	d9 1f       	adc	r29, r25
    29f0:	80 91 54 16 	lds	r24, 0x1654	; 0x801654 <pxCurrentTCB>
    29f4:	90 91 55 16 	lds	r25, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    29f8:	02 96       	adiw	r24, 0x02	; 2
    29fa:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    29fe:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    2a02:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2a06:	d3 83       	std	Z+3, r29	; 0x03
    2a08:	c2 83       	std	Z+2, r28	; 0x02
    2a0a:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <xTickCount>
    2a0e:	90 91 fc 15 	lds	r25, 0x15FC	; 0x8015fc <xTickCount+0x1>
    2a12:	c8 17       	cp	r28, r24
    2a14:	d9 07       	cpc	r29, r25
    2a16:	68 f4       	brcc	.+26     	; 0x2a32 <vTaskDelay+0x74>
    2a18:	60 91 54 16 	lds	r22, 0x1654	; 0x801654 <pxCurrentTCB>
    2a1c:	70 91 55 16 	lds	r23, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2a20:	80 91 1a 16 	lds	r24, 0x161A	; 0x80161a <pxOverflowDelayedTaskList>
    2a24:	90 91 1b 16 	lds	r25, 0x161B	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    2a28:	6e 5f       	subi	r22, 0xFE	; 254
    2a2a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a2c:	0e 94 a2 0c 	call	0x1944	; 0x1944 <vListInsert>
    2a30:	17 c0       	rjmp	.+46     	; 0x2a60 <vTaskDelay+0xa2>
    2a32:	60 91 54 16 	lds	r22, 0x1654	; 0x801654 <pxCurrentTCB>
    2a36:	70 91 55 16 	lds	r23, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2a3a:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <pxDelayedTaskList>
    2a3e:	90 91 1d 16 	lds	r25, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    2a42:	6e 5f       	subi	r22, 0xFE	; 254
    2a44:	7f 4f       	sbci	r23, 0xFF	; 255
    2a46:	0e 94 a2 0c 	call	0x1944	; 0x1944 <vListInsert>
    2a4a:	80 91 f3 15 	lds	r24, 0x15F3	; 0x8015f3 <xNextTaskUnblockTime>
    2a4e:	90 91 f4 15 	lds	r25, 0x15F4	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    2a52:	c8 17       	cp	r28, r24
    2a54:	d9 07       	cpc	r29, r25
    2a56:	20 f4       	brcc	.+8      	; 0x2a60 <vTaskDelay+0xa2>
    2a58:	d0 93 f4 15 	sts	0x15F4, r29	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    2a5c:	c0 93 f3 15 	sts	0x15F3, r28	; 0x8015f3 <xNextTaskUnblockTime>
    2a60:	0f b6       	in	r0, 0x3f	; 63
    2a62:	f8 94       	cli
    2a64:	0f 92       	push	r0
    2a66:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    2a6a:	81 50       	subi	r24, 0x01	; 1
    2a6c:	80 93 f2 15 	sts	0x15F2, r24	; 0x8015f2 <uxSchedulerSuspended>
    2a70:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    2a74:	81 11       	cpse	r24, r1
    2a76:	28 c1       	rjmp	.+592    	; 0x2cc8 <vTaskDelay+0x30a>
    2a78:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <uxCurrentNumberOfTasks>
    2a7c:	81 11       	cpse	r24, r1
    2a7e:	33 c0       	rjmp	.+102    	; 0x2ae6 <vTaskDelay+0x128>
    2a80:	26 c1       	rjmp	.+588    	; 0x2cce <vTaskDelay+0x310>
    2a82:	d7 01       	movw	r26, r14
    2a84:	15 96       	adiw	r26, 0x05	; 5
    2a86:	ed 91       	ld	r30, X+
    2a88:	fc 91       	ld	r31, X
    2a8a:	16 97       	sbiw	r26, 0x06	; 6
    2a8c:	c6 81       	ldd	r28, Z+6	; 0x06
    2a8e:	d7 81       	ldd	r29, Z+7	; 0x07
    2a90:	ce 01       	movw	r24, r28
    2a92:	0c 96       	adiw	r24, 0x0c	; 12
    2a94:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    2a98:	8e 01       	movw	r16, r28
    2a9a:	0e 5f       	subi	r16, 0xFE	; 254
    2a9c:	1f 4f       	sbci	r17, 0xFF	; 255
    2a9e:	c8 01       	movw	r24, r16
    2aa0:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    2aa4:	8e 89       	ldd	r24, Y+22	; 0x16
    2aa6:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    2aaa:	98 17       	cp	r25, r24
    2aac:	10 f4       	brcc	.+4      	; 0x2ab2 <vTaskDelay+0xf4>
    2aae:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    2ab2:	90 e0       	ldi	r25, 0x00	; 0
    2ab4:	9c 01       	movw	r18, r24
    2ab6:	22 0f       	add	r18, r18
    2ab8:	33 1f       	adc	r19, r19
    2aba:	22 0f       	add	r18, r18
    2abc:	33 1f       	adc	r19, r19
    2abe:	22 0f       	add	r18, r18
    2ac0:	33 1f       	adc	r19, r19
    2ac2:	82 0f       	add	r24, r18
    2ac4:	93 1f       	adc	r25, r19
    2ac6:	b8 01       	movw	r22, r16
    2ac8:	80 5d       	subi	r24, 0xD0	; 208
    2aca:	99 4e       	sbci	r25, 0xE9	; 233
    2acc:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    2ad0:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    2ad4:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2ad8:	9e 89       	ldd	r25, Y+22	; 0x16
    2ada:	86 89       	ldd	r24, Z+22	; 0x16
    2adc:	98 17       	cp	r25, r24
    2ade:	58 f0       	brcs	.+22     	; 0x2af6 <vTaskDelay+0x138>
    2ae0:	d0 92 f7 15 	sts	0x15F7, r13	; 0x8015f7 <xYieldPending>
    2ae4:	08 c0       	rjmp	.+16     	; 0x2af6 <vTaskDelay+0x138>
    2ae6:	0f 2e       	mov	r0, r31
    2ae8:	f1 e1       	ldi	r31, 0x11	; 17
    2aea:	ef 2e       	mov	r14, r31
    2aec:	f6 e1       	ldi	r31, 0x16	; 22
    2aee:	ff 2e       	mov	r15, r31
    2af0:	f0 2d       	mov	r31, r0
    2af2:	dd 24       	eor	r13, r13
    2af4:	d3 94       	inc	r13
    2af6:	f7 01       	movw	r30, r14
    2af8:	80 81       	ld	r24, Z
    2afa:	81 11       	cpse	r24, r1
    2afc:	c2 cf       	rjmp	.-124    	; 0x2a82 <vTaskDelay+0xc4>
    2afe:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    2b02:	88 23       	and	r24, r24
    2b04:	09 f4       	brne	.+2      	; 0x2b08 <vTaskDelay+0x14a>
    2b06:	d8 c0       	rjmp	.+432    	; 0x2cb8 <vTaskDelay+0x2fa>
    2b08:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    2b0c:	88 23       	and	r24, r24
    2b0e:	09 f4       	brne	.+2      	; 0x2b12 <vTaskDelay+0x154>
    2b10:	d3 c0       	rjmp	.+422    	; 0x2cb8 <vTaskDelay+0x2fa>
    2b12:	91 2c       	mov	r9, r1
    2b14:	bb 24       	eor	r11, r11
    2b16:	b3 94       	inc	r11
    2b18:	cc 24       	eor	r12, r12
    2b1a:	ca 94       	dec	r12
    2b1c:	dc 2c       	mov	r13, r12
    2b1e:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    2b22:	81 11       	cpse	r24, r1
    2b24:	af c0       	rjmp	.+350    	; 0x2c84 <vTaskDelay+0x2c6>
    2b26:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <xTickCount>
    2b2a:	90 91 fc 15 	lds	r25, 0x15FC	; 0x8015fc <xTickCount+0x1>
    2b2e:	01 96       	adiw	r24, 0x01	; 1
    2b30:	90 93 fc 15 	sts	0x15FC, r25	; 0x8015fc <xTickCount+0x1>
    2b34:	80 93 fb 15 	sts	0x15FB, r24	; 0x8015fb <xTickCount>
    2b38:	e0 90 fb 15 	lds	r14, 0x15FB	; 0x8015fb <xTickCount>
    2b3c:	f0 90 fc 15 	lds	r15, 0x15FC	; 0x8015fc <xTickCount+0x1>
    2b40:	e1 14       	cp	r14, r1
    2b42:	f1 04       	cpc	r15, r1
    2b44:	89 f5       	brne	.+98     	; 0x2ba8 <vTaskDelay+0x1ea>
    2b46:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <pxDelayedTaskList>
    2b4a:	90 91 1d 16 	lds	r25, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    2b4e:	20 91 1a 16 	lds	r18, 0x161A	; 0x80161a <pxOverflowDelayedTaskList>
    2b52:	30 91 1b 16 	lds	r19, 0x161B	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    2b56:	30 93 1d 16 	sts	0x161D, r19	; 0x80161d <pxDelayedTaskList+0x1>
    2b5a:	20 93 1c 16 	sts	0x161C, r18	; 0x80161c <pxDelayedTaskList>
    2b5e:	90 93 1b 16 	sts	0x161B, r25	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    2b62:	80 93 1a 16 	sts	0x161A, r24	; 0x80161a <pxOverflowDelayedTaskList>
    2b66:	80 91 f6 15 	lds	r24, 0x15F6	; 0x8015f6 <xNumOfOverflows>
    2b6a:	8f 5f       	subi	r24, 0xFF	; 255
    2b6c:	80 93 f6 15 	sts	0x15F6, r24	; 0x8015f6 <xNumOfOverflows>
    2b70:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    2b74:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    2b78:	80 81       	ld	r24, Z
    2b7a:	81 11       	cpse	r24, r1
    2b7c:	05 c0       	rjmp	.+10     	; 0x2b88 <vTaskDelay+0x1ca>
    2b7e:	d0 92 f4 15 	sts	0x15F4, r13	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    2b82:	c0 92 f3 15 	sts	0x15F3, r12	; 0x8015f3 <xNextTaskUnblockTime>
    2b86:	10 c0       	rjmp	.+32     	; 0x2ba8 <vTaskDelay+0x1ea>
    2b88:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    2b8c:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    2b90:	05 80       	ldd	r0, Z+5	; 0x05
    2b92:	f6 81       	ldd	r31, Z+6	; 0x06
    2b94:	e0 2d       	mov	r30, r0
    2b96:	06 80       	ldd	r0, Z+6	; 0x06
    2b98:	f7 81       	ldd	r31, Z+7	; 0x07
    2b9a:	e0 2d       	mov	r30, r0
    2b9c:	82 81       	ldd	r24, Z+2	; 0x02
    2b9e:	93 81       	ldd	r25, Z+3	; 0x03
    2ba0:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    2ba4:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    2ba8:	80 91 f3 15 	lds	r24, 0x15F3	; 0x8015f3 <xNextTaskUnblockTime>
    2bac:	90 91 f4 15 	lds	r25, 0x15F4	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    2bb0:	e8 16       	cp	r14, r24
    2bb2:	f9 06       	cpc	r15, r25
    2bb4:	10 f4       	brcc	.+4      	; 0x2bba <vTaskDelay+0x1fc>
    2bb6:	a9 2c       	mov	r10, r9
    2bb8:	4f c0       	rjmp	.+158    	; 0x2c58 <vTaskDelay+0x29a>
    2bba:	a9 2c       	mov	r10, r9
    2bbc:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    2bc0:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    2bc4:	80 81       	ld	r24, Z
    2bc6:	81 11       	cpse	r24, r1
    2bc8:	05 c0       	rjmp	.+10     	; 0x2bd4 <vTaskDelay+0x216>
    2bca:	d0 92 f4 15 	sts	0x15F4, r13	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    2bce:	c0 92 f3 15 	sts	0x15F3, r12	; 0x8015f3 <xNextTaskUnblockTime>
    2bd2:	42 c0       	rjmp	.+132    	; 0x2c58 <vTaskDelay+0x29a>
    2bd4:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    2bd8:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    2bdc:	05 80       	ldd	r0, Z+5	; 0x05
    2bde:	f6 81       	ldd	r31, Z+6	; 0x06
    2be0:	e0 2d       	mov	r30, r0
    2be2:	c6 81       	ldd	r28, Z+6	; 0x06
    2be4:	d7 81       	ldd	r29, Z+7	; 0x07
    2be6:	8a 81       	ldd	r24, Y+2	; 0x02
    2be8:	9b 81       	ldd	r25, Y+3	; 0x03
    2bea:	e8 16       	cp	r14, r24
    2bec:	f9 06       	cpc	r15, r25
    2bee:	28 f4       	brcc	.+10     	; 0x2bfa <vTaskDelay+0x23c>
    2bf0:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    2bf4:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    2bf8:	2f c0       	rjmp	.+94     	; 0x2c58 <vTaskDelay+0x29a>
    2bfa:	8e 01       	movw	r16, r28
    2bfc:	0e 5f       	subi	r16, 0xFE	; 254
    2bfe:	1f 4f       	sbci	r17, 0xFF	; 255
    2c00:	c8 01       	movw	r24, r16
    2c02:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    2c06:	8c 89       	ldd	r24, Y+20	; 0x14
    2c08:	9d 89       	ldd	r25, Y+21	; 0x15
    2c0a:	89 2b       	or	r24, r25
    2c0c:	21 f0       	breq	.+8      	; 0x2c16 <vTaskDelay+0x258>
    2c0e:	ce 01       	movw	r24, r28
    2c10:	0c 96       	adiw	r24, 0x0c	; 12
    2c12:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    2c16:	8e 89       	ldd	r24, Y+22	; 0x16
    2c18:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    2c1c:	98 17       	cp	r25, r24
    2c1e:	10 f4       	brcc	.+4      	; 0x2c24 <vTaskDelay+0x266>
    2c20:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    2c24:	90 e0       	ldi	r25, 0x00	; 0
    2c26:	9c 01       	movw	r18, r24
    2c28:	22 0f       	add	r18, r18
    2c2a:	33 1f       	adc	r19, r19
    2c2c:	22 0f       	add	r18, r18
    2c2e:	33 1f       	adc	r19, r19
    2c30:	22 0f       	add	r18, r18
    2c32:	33 1f       	adc	r19, r19
    2c34:	82 0f       	add	r24, r18
    2c36:	93 1f       	adc	r25, r19
    2c38:	b8 01       	movw	r22, r16
    2c3a:	80 5d       	subi	r24, 0xD0	; 208
    2c3c:	99 4e       	sbci	r25, 0xE9	; 233
    2c3e:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    2c42:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    2c46:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2c4a:	9e 89       	ldd	r25, Y+22	; 0x16
    2c4c:	86 89       	ldd	r24, Z+22	; 0x16
    2c4e:	98 17       	cp	r25, r24
    2c50:	08 f4       	brcc	.+2      	; 0x2c54 <vTaskDelay+0x296>
    2c52:	b4 cf       	rjmp	.-152    	; 0x2bbc <vTaskDelay+0x1fe>
    2c54:	ab 2c       	mov	r10, r11
    2c56:	b2 cf       	rjmp	.-156    	; 0x2bbc <vTaskDelay+0x1fe>
    2c58:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    2c5c:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2c60:	86 89       	ldd	r24, Z+22	; 0x16
    2c62:	90 e0       	ldi	r25, 0x00	; 0
    2c64:	fc 01       	movw	r30, r24
    2c66:	ee 0f       	add	r30, r30
    2c68:	ff 1f       	adc	r31, r31
    2c6a:	ee 0f       	add	r30, r30
    2c6c:	ff 1f       	adc	r31, r31
    2c6e:	ee 0f       	add	r30, r30
    2c70:	ff 1f       	adc	r31, r31
    2c72:	8e 0f       	add	r24, r30
    2c74:	9f 1f       	adc	r25, r31
    2c76:	fc 01       	movw	r30, r24
    2c78:	e0 5d       	subi	r30, 0xD0	; 208
    2c7a:	f9 4e       	sbci	r31, 0xE9	; 233
    2c7c:	80 81       	ld	r24, Z
    2c7e:	82 30       	cpi	r24, 0x02	; 2
    2c80:	68 f5       	brcc	.+90     	; 0x2cdc <vTaskDelay+0x31e>
    2c82:	0a c0       	rjmp	.+20     	; 0x2c98 <vTaskDelay+0x2da>
    2c84:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    2c88:	8f 5f       	subi	r24, 0xFF	; 255
    2c8a:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxPendedTicks>
    2c8e:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    2c92:	88 23       	and	r24, r24
    2c94:	41 f0       	breq	.+16     	; 0x2ca6 <vTaskDelay+0x2e8>
    2c96:	05 c0       	rjmp	.+10     	; 0x2ca2 <vTaskDelay+0x2e4>
    2c98:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    2c9c:	81 11       	cpse	r24, r1
    2c9e:	01 c0       	rjmp	.+2      	; 0x2ca2 <vTaskDelay+0x2e4>
    2ca0:	a1 10       	cpse	r10, r1
    2ca2:	b0 92 f7 15 	sts	0x15F7, r11	; 0x8015f7 <xYieldPending>
    2ca6:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    2caa:	81 50       	subi	r24, 0x01	; 1
    2cac:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxPendedTicks>
    2cb0:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    2cb4:	81 11       	cpse	r24, r1
    2cb6:	33 cf       	rjmp	.-410    	; 0x2b1e <vTaskDelay+0x160>
    2cb8:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    2cbc:	81 30       	cpi	r24, 0x01	; 1
    2cbe:	31 f4       	brne	.+12     	; 0x2ccc <vTaskDelay+0x30e>
    2cc0:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <vPortYield>
    2cc4:	81 e0       	ldi	r24, 0x01	; 1
    2cc6:	03 c0       	rjmp	.+6      	; 0x2cce <vTaskDelay+0x310>
    2cc8:	80 e0       	ldi	r24, 0x00	; 0
    2cca:	01 c0       	rjmp	.+2      	; 0x2cce <vTaskDelay+0x310>
    2ccc:	80 e0       	ldi	r24, 0x00	; 0
    2cce:	0f 90       	pop	r0
    2cd0:	0f be       	out	0x3f, r0	; 63
    2cd2:	81 11       	cpse	r24, r1
    2cd4:	06 c0       	rjmp	.+12     	; 0x2ce2 <vTaskDelay+0x324>
    2cd6:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <vPortYield>
    2cda:	03 c0       	rjmp	.+6      	; 0x2ce2 <vTaskDelay+0x324>
    2cdc:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    2ce0:	e0 cf       	rjmp	.-64     	; 0x2ca2 <vTaskDelay+0x2e4>
    2ce2:	df 91       	pop	r29
    2ce4:	cf 91       	pop	r28
    2ce6:	1f 91       	pop	r17
    2ce8:	0f 91       	pop	r16
    2cea:	ff 90       	pop	r15
    2cec:	ef 90       	pop	r14
    2cee:	df 90       	pop	r13
    2cf0:	cf 90       	pop	r12
    2cf2:	bf 90       	pop	r11
    2cf4:	af 90       	pop	r10
    2cf6:	9f 90       	pop	r9
    2cf8:	08 95       	ret

00002cfa <vTaskStartScheduler>:
    2cfa:	ef 92       	push	r14
    2cfc:	ff 92       	push	r15
    2cfe:	0f 93       	push	r16
    2d00:	1f 93       	push	r17
    2d02:	cf 93       	push	r28
    2d04:	df 93       	push	r29
    2d06:	84 e6       	ldi	r24, 0x64	; 100
    2d08:	90 e0       	ldi	r25, 0x00	; 0
    2d0a:	0e 94 39 0c 	call	0x1872	; 0x1872 <pvPortMalloc>
    2d0e:	8c 01       	movw	r16, r24
    2d10:	89 2b       	or	r24, r25
    2d12:	09 f4       	brne	.+2      	; 0x2d16 <vTaskStartScheduler+0x1c>
    2d14:	d9 c0       	rjmp	.+434    	; 0x2ec8 <vTaskStartScheduler+0x1ce>
    2d16:	88 e2       	ldi	r24, 0x28	; 40
    2d18:	90 e0       	ldi	r25, 0x00	; 0
    2d1a:	0e 94 39 0c 	call	0x1872	; 0x1872 <pvPortMalloc>
    2d1e:	ec 01       	movw	r28, r24
    2d20:	89 2b       	or	r24, r25
    2d22:	b1 f0       	breq	.+44     	; 0x2d50 <vTaskStartScheduler+0x56>
    2d24:	18 8f       	std	Y+24, r17	; 0x18
    2d26:	0f 8b       	std	Y+23, r16	; 0x17
    2d28:	44 e6       	ldi	r20, 0x64	; 100
    2d2a:	50 e0       	ldi	r21, 0x00	; 0
    2d2c:	65 ea       	ldi	r22, 0xA5	; 165
    2d2e:	70 e0       	ldi	r23, 0x00	; 0
    2d30:	c8 01       	movw	r24, r16
    2d32:	0e 94 30 22 	call	0x4460	; 0x4460 <memset>
    2d36:	0f 89       	ldd	r16, Y+23	; 0x17
    2d38:	18 8d       	ldd	r17, Y+24	; 0x18
    2d3a:	0d 59       	subi	r16, 0x9D	; 157
    2d3c:	1f 4f       	sbci	r17, 0xFF	; 255
    2d3e:	89 e4       	ldi	r24, 0x49	; 73
    2d40:	89 8f       	std	Y+25, r24	; 0x19
    2d42:	e7 eb       	ldi	r30, 0xB7	; 183
    2d44:	f3 e0       	ldi	r31, 0x03	; 3
    2d46:	de 01       	movw	r26, r28
    2d48:	5a 96       	adiw	r26, 0x1a	; 26
    2d4a:	2e eb       	ldi	r18, 0xBE	; 190
    2d4c:	33 e0       	ldi	r19, 0x03	; 3
    2d4e:	04 c0       	rjmp	.+8      	; 0x2d58 <vTaskStartScheduler+0x5e>
    2d50:	c8 01       	movw	r24, r16
    2d52:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <vPortFree>
    2d56:	b8 c0       	rjmp	.+368    	; 0x2ec8 <vTaskStartScheduler+0x1ce>
    2d58:	81 91       	ld	r24, Z+
    2d5a:	8d 93       	st	X+, r24
    2d5c:	88 23       	and	r24, r24
    2d5e:	19 f0       	breq	.+6      	; 0x2d66 <vTaskStartScheduler+0x6c>
    2d60:	e2 17       	cp	r30, r18
    2d62:	f3 07       	cpc	r31, r19
    2d64:	c9 f7       	brne	.-14     	; 0x2d58 <vTaskStartScheduler+0x5e>
    2d66:	18 a2       	std	Y+32, r1	; 0x20
    2d68:	1e 8a       	std	Y+22, r1	; 0x16
    2d6a:	19 a2       	std	Y+33, r1	; 0x21
    2d6c:	1a a2       	std	Y+34, r1	; 0x22
    2d6e:	7e 01       	movw	r14, r28
    2d70:	82 e0       	ldi	r24, 0x02	; 2
    2d72:	e8 0e       	add	r14, r24
    2d74:	f1 1c       	adc	r15, r1
    2d76:	c7 01       	movw	r24, r14
    2d78:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <vListInitialiseItem>
    2d7c:	ce 01       	movw	r24, r28
    2d7e:	0c 96       	adiw	r24, 0x0c	; 12
    2d80:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <vListInitialiseItem>
    2d84:	d9 87       	std	Y+9, r29	; 0x09
    2d86:	c8 87       	std	Y+8, r28	; 0x08
    2d88:	84 e0       	ldi	r24, 0x04	; 4
    2d8a:	90 e0       	ldi	r25, 0x00	; 0
    2d8c:	9d 87       	std	Y+13, r25	; 0x0d
    2d8e:	8c 87       	std	Y+12, r24	; 0x0c
    2d90:	db 8b       	std	Y+19, r29	; 0x13
    2d92:	ca 8b       	std	Y+18, r28	; 0x12
    2d94:	1b a2       	std	Y+35, r1	; 0x23
    2d96:	1c a2       	std	Y+36, r1	; 0x24
    2d98:	1d a2       	std	Y+37, r1	; 0x25
    2d9a:	1e a2       	std	Y+38, r1	; 0x26
    2d9c:	1f a2       	std	Y+39, r1	; 0x27
    2d9e:	40 e0       	ldi	r20, 0x00	; 0
    2da0:	50 e0       	ldi	r21, 0x00	; 0
    2da2:	62 e8       	ldi	r22, 0x82	; 130
    2da4:	70 e0       	ldi	r23, 0x00	; 0
    2da6:	c8 01       	movw	r24, r16
    2da8:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <pxPortInitialiseStack>
    2dac:	99 83       	std	Y+1, r25	; 0x01
    2dae:	88 83       	st	Y, r24
    2db0:	0f b6       	in	r0, 0x3f	; 63
    2db2:	f8 94       	cli
    2db4:	0f 92       	push	r0
    2db6:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <uxCurrentNumberOfTasks>
    2dba:	8f 5f       	subi	r24, 0xFF	; 255
    2dbc:	80 93 fd 15 	sts	0x15FD, r24	; 0x8015fd <uxCurrentNumberOfTasks>
    2dc0:	80 91 54 16 	lds	r24, 0x1654	; 0x801654 <pxCurrentTCB>
    2dc4:	90 91 55 16 	lds	r25, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2dc8:	89 2b       	or	r24, r25
    2dca:	d1 f5       	brne	.+116    	; 0x2e40 <vTaskStartScheduler+0x146>
    2dcc:	d0 93 55 16 	sts	0x1655, r29	; 0x801655 <pxCurrentTCB+0x1>
    2dd0:	c0 93 54 16 	sts	0x1654, r28	; 0x801654 <pxCurrentTCB>
    2dd4:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <uxCurrentNumberOfTasks>
    2dd8:	81 30       	cpi	r24, 0x01	; 1
    2dda:	09 f0       	breq	.+2      	; 0x2dde <vTaskStartScheduler+0xe4>
    2ddc:	40 c0       	rjmp	.+128    	; 0x2e5e <vTaskStartScheduler+0x164>
    2dde:	80 e3       	ldi	r24, 0x30	; 48
    2de0:	96 e1       	ldi	r25, 0x16	; 22
    2de2:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2de6:	89 e3       	ldi	r24, 0x39	; 57
    2de8:	96 e1       	ldi	r25, 0x16	; 22
    2dea:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2dee:	82 e4       	ldi	r24, 0x42	; 66
    2df0:	96 e1       	ldi	r25, 0x16	; 22
    2df2:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2df6:	8b e4       	ldi	r24, 0x4B	; 75
    2df8:	96 e1       	ldi	r25, 0x16	; 22
    2dfa:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2dfe:	87 e2       	ldi	r24, 0x27	; 39
    2e00:	96 e1       	ldi	r25, 0x16	; 22
    2e02:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2e06:	8e e1       	ldi	r24, 0x1E	; 30
    2e08:	96 e1       	ldi	r25, 0x16	; 22
    2e0a:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2e0e:	81 e1       	ldi	r24, 0x11	; 17
    2e10:	96 e1       	ldi	r25, 0x16	; 22
    2e12:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2e16:	88 e0       	ldi	r24, 0x08	; 8
    2e18:	96 e1       	ldi	r25, 0x16	; 22
    2e1a:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2e1e:	8e ef       	ldi	r24, 0xFE	; 254
    2e20:	95 e1       	ldi	r25, 0x15	; 21
    2e22:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInitialise>
    2e26:	87 e2       	ldi	r24, 0x27	; 39
    2e28:	96 e1       	ldi	r25, 0x16	; 22
    2e2a:	90 93 1d 16 	sts	0x161D, r25	; 0x80161d <pxDelayedTaskList+0x1>
    2e2e:	80 93 1c 16 	sts	0x161C, r24	; 0x80161c <pxDelayedTaskList>
    2e32:	8e e1       	ldi	r24, 0x1E	; 30
    2e34:	96 e1       	ldi	r25, 0x16	; 22
    2e36:	90 93 1b 16 	sts	0x161B, r25	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    2e3a:	80 93 1a 16 	sts	0x161A, r24	; 0x80161a <pxOverflowDelayedTaskList>
    2e3e:	0f c0       	rjmp	.+30     	; 0x2e5e <vTaskStartScheduler+0x164>
    2e40:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xSchedulerRunning>
    2e44:	81 11       	cpse	r24, r1
    2e46:	0b c0       	rjmp	.+22     	; 0x2e5e <vTaskStartScheduler+0x164>
    2e48:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    2e4c:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2e50:	86 89       	ldd	r24, Z+22	; 0x16
    2e52:	81 11       	cpse	r24, r1
    2e54:	04 c0       	rjmp	.+8      	; 0x2e5e <vTaskStartScheduler+0x164>
    2e56:	d0 93 55 16 	sts	0x1655, r29	; 0x801655 <pxCurrentTCB+0x1>
    2e5a:	c0 93 54 16 	sts	0x1654, r28	; 0x801654 <pxCurrentTCB>
    2e5e:	80 91 f5 15 	lds	r24, 0x15F5	; 0x8015f5 <uxTaskNumber>
    2e62:	8f 5f       	subi	r24, 0xFF	; 255
    2e64:	80 93 f5 15 	sts	0x15F5, r24	; 0x8015f5 <uxTaskNumber>
    2e68:	8e 89       	ldd	r24, Y+22	; 0x16
    2e6a:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    2e6e:	98 17       	cp	r25, r24
    2e70:	10 f4       	brcc	.+4      	; 0x2e76 <vTaskStartScheduler+0x17c>
    2e72:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	9c 01       	movw	r18, r24
    2e7a:	22 0f       	add	r18, r18
    2e7c:	33 1f       	adc	r19, r19
    2e7e:	22 0f       	add	r18, r18
    2e80:	33 1f       	adc	r19, r19
    2e82:	22 0f       	add	r18, r18
    2e84:	33 1f       	adc	r19, r19
    2e86:	82 0f       	add	r24, r18
    2e88:	93 1f       	adc	r25, r19
    2e8a:	b7 01       	movw	r22, r14
    2e8c:	80 5d       	subi	r24, 0xD0	; 208
    2e8e:	99 4e       	sbci	r25, 0xE9	; 233
    2e90:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    2e94:	0f 90       	pop	r0
    2e96:	0f be       	out	0x3f, r0	; 63
    2e98:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xSchedulerRunning>
    2e9c:	88 23       	and	r24, r24
    2e9e:	21 f0       	breq	.+8      	; 0x2ea8 <vTaskStartScheduler+0x1ae>
    2ea0:	80 91 54 16 	lds	r24, 0x1654	; 0x801654 <pxCurrentTCB>
    2ea4:	90 91 55 16 	lds	r25, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2ea8:	f8 94       	cli
    2eaa:	8f ef       	ldi	r24, 0xFF	; 255
    2eac:	9f ef       	ldi	r25, 0xFF	; 255
    2eae:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    2eb2:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    2eb6:	81 e0       	ldi	r24, 0x01	; 1
    2eb8:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xSchedulerRunning>
    2ebc:	10 92 fc 15 	sts	0x15FC, r1	; 0x8015fc <xTickCount+0x1>
    2ec0:	10 92 fb 15 	sts	0x15FB, r1	; 0x8015fb <xTickCount>
    2ec4:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xPortStartScheduler>
    2ec8:	df 91       	pop	r29
    2eca:	cf 91       	pop	r28
    2ecc:	1f 91       	pop	r17
    2ece:	0f 91       	pop	r16
    2ed0:	ff 90       	pop	r15
    2ed2:	ef 90       	pop	r14
    2ed4:	08 95       	ret

00002ed6 <vTaskSuspendAll>:
    2ed6:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    2eda:	8f 5f       	subi	r24, 0xFF	; 255
    2edc:	80 93 f2 15 	sts	0x15F2, r24	; 0x8015f2 <uxSchedulerSuspended>
    2ee0:	08 95       	ret

00002ee2 <xTaskResumeAll>:
    2ee2:	9f 92       	push	r9
    2ee4:	af 92       	push	r10
    2ee6:	bf 92       	push	r11
    2ee8:	cf 92       	push	r12
    2eea:	df 92       	push	r13
    2eec:	ef 92       	push	r14
    2eee:	ff 92       	push	r15
    2ef0:	0f 93       	push	r16
    2ef2:	1f 93       	push	r17
    2ef4:	cf 93       	push	r28
    2ef6:	df 93       	push	r29
    2ef8:	0f b6       	in	r0, 0x3f	; 63
    2efa:	f8 94       	cli
    2efc:	0f 92       	push	r0
    2efe:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    2f02:	81 50       	subi	r24, 0x01	; 1
    2f04:	80 93 f2 15 	sts	0x15F2, r24	; 0x8015f2 <uxSchedulerSuspended>
    2f08:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    2f0c:	81 11       	cpse	r24, r1
    2f0e:	28 c1       	rjmp	.+592    	; 0x3160 <xTaskResumeAll+0x27e>
    2f10:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <uxCurrentNumberOfTasks>
    2f14:	81 11       	cpse	r24, r1
    2f16:	33 c0       	rjmp	.+102    	; 0x2f7e <xTaskResumeAll+0x9c>
    2f18:	26 c1       	rjmp	.+588    	; 0x3166 <xTaskResumeAll+0x284>
    2f1a:	d7 01       	movw	r26, r14
    2f1c:	15 96       	adiw	r26, 0x05	; 5
    2f1e:	ed 91       	ld	r30, X+
    2f20:	fc 91       	ld	r31, X
    2f22:	16 97       	sbiw	r26, 0x06	; 6
    2f24:	c6 81       	ldd	r28, Z+6	; 0x06
    2f26:	d7 81       	ldd	r29, Z+7	; 0x07
    2f28:	ce 01       	movw	r24, r28
    2f2a:	0c 96       	adiw	r24, 0x0c	; 12
    2f2c:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    2f30:	8e 01       	movw	r16, r28
    2f32:	0e 5f       	subi	r16, 0xFE	; 254
    2f34:	1f 4f       	sbci	r17, 0xFF	; 255
    2f36:	c8 01       	movw	r24, r16
    2f38:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    2f3c:	8e 89       	ldd	r24, Y+22	; 0x16
    2f3e:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    2f42:	98 17       	cp	r25, r24
    2f44:	10 f4       	brcc	.+4      	; 0x2f4a <xTaskResumeAll+0x68>
    2f46:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	9c 01       	movw	r18, r24
    2f4e:	22 0f       	add	r18, r18
    2f50:	33 1f       	adc	r19, r19
    2f52:	22 0f       	add	r18, r18
    2f54:	33 1f       	adc	r19, r19
    2f56:	22 0f       	add	r18, r18
    2f58:	33 1f       	adc	r19, r19
    2f5a:	82 0f       	add	r24, r18
    2f5c:	93 1f       	adc	r25, r19
    2f5e:	b8 01       	movw	r22, r16
    2f60:	80 5d       	subi	r24, 0xD0	; 208
    2f62:	99 4e       	sbci	r25, 0xE9	; 233
    2f64:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    2f68:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    2f6c:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    2f70:	9e 89       	ldd	r25, Y+22	; 0x16
    2f72:	86 89       	ldd	r24, Z+22	; 0x16
    2f74:	98 17       	cp	r25, r24
    2f76:	58 f0       	brcs	.+22     	; 0x2f8e <xTaskResumeAll+0xac>
    2f78:	d0 92 f7 15 	sts	0x15F7, r13	; 0x8015f7 <xYieldPending>
    2f7c:	08 c0       	rjmp	.+16     	; 0x2f8e <xTaskResumeAll+0xac>
    2f7e:	0f 2e       	mov	r0, r31
    2f80:	f1 e1       	ldi	r31, 0x11	; 17
    2f82:	ef 2e       	mov	r14, r31
    2f84:	f6 e1       	ldi	r31, 0x16	; 22
    2f86:	ff 2e       	mov	r15, r31
    2f88:	f0 2d       	mov	r31, r0
    2f8a:	dd 24       	eor	r13, r13
    2f8c:	d3 94       	inc	r13
    2f8e:	f7 01       	movw	r30, r14
    2f90:	80 81       	ld	r24, Z
    2f92:	81 11       	cpse	r24, r1
    2f94:	c2 cf       	rjmp	.-124    	; 0x2f1a <xTaskResumeAll+0x38>
    2f96:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    2f9a:	88 23       	and	r24, r24
    2f9c:	09 f4       	brne	.+2      	; 0x2fa0 <xTaskResumeAll+0xbe>
    2f9e:	d8 c0       	rjmp	.+432    	; 0x3150 <xTaskResumeAll+0x26e>
    2fa0:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    2fa4:	88 23       	and	r24, r24
    2fa6:	09 f4       	brne	.+2      	; 0x2faa <xTaskResumeAll+0xc8>
    2fa8:	d3 c0       	rjmp	.+422    	; 0x3150 <xTaskResumeAll+0x26e>
    2faa:	91 2c       	mov	r9, r1
    2fac:	bb 24       	eor	r11, r11
    2fae:	b3 94       	inc	r11
    2fb0:	cc 24       	eor	r12, r12
    2fb2:	ca 94       	dec	r12
    2fb4:	dc 2c       	mov	r13, r12
    2fb6:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    2fba:	81 11       	cpse	r24, r1
    2fbc:	af c0       	rjmp	.+350    	; 0x311c <xTaskResumeAll+0x23a>
    2fbe:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <xTickCount>
    2fc2:	90 91 fc 15 	lds	r25, 0x15FC	; 0x8015fc <xTickCount+0x1>
    2fc6:	01 96       	adiw	r24, 0x01	; 1
    2fc8:	90 93 fc 15 	sts	0x15FC, r25	; 0x8015fc <xTickCount+0x1>
    2fcc:	80 93 fb 15 	sts	0x15FB, r24	; 0x8015fb <xTickCount>
    2fd0:	e0 90 fb 15 	lds	r14, 0x15FB	; 0x8015fb <xTickCount>
    2fd4:	f0 90 fc 15 	lds	r15, 0x15FC	; 0x8015fc <xTickCount+0x1>
    2fd8:	e1 14       	cp	r14, r1
    2fda:	f1 04       	cpc	r15, r1
    2fdc:	89 f5       	brne	.+98     	; 0x3040 <xTaskResumeAll+0x15e>
    2fde:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <pxDelayedTaskList>
    2fe2:	90 91 1d 16 	lds	r25, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    2fe6:	20 91 1a 16 	lds	r18, 0x161A	; 0x80161a <pxOverflowDelayedTaskList>
    2fea:	30 91 1b 16 	lds	r19, 0x161B	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    2fee:	30 93 1d 16 	sts	0x161D, r19	; 0x80161d <pxDelayedTaskList+0x1>
    2ff2:	20 93 1c 16 	sts	0x161C, r18	; 0x80161c <pxDelayedTaskList>
    2ff6:	90 93 1b 16 	sts	0x161B, r25	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    2ffa:	80 93 1a 16 	sts	0x161A, r24	; 0x80161a <pxOverflowDelayedTaskList>
    2ffe:	80 91 f6 15 	lds	r24, 0x15F6	; 0x8015f6 <xNumOfOverflows>
    3002:	8f 5f       	subi	r24, 0xFF	; 255
    3004:	80 93 f6 15 	sts	0x15F6, r24	; 0x8015f6 <xNumOfOverflows>
    3008:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    300c:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    3010:	80 81       	ld	r24, Z
    3012:	81 11       	cpse	r24, r1
    3014:	05 c0       	rjmp	.+10     	; 0x3020 <xTaskResumeAll+0x13e>
    3016:	d0 92 f4 15 	sts	0x15F4, r13	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    301a:	c0 92 f3 15 	sts	0x15F3, r12	; 0x8015f3 <xNextTaskUnblockTime>
    301e:	10 c0       	rjmp	.+32     	; 0x3040 <xTaskResumeAll+0x15e>
    3020:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    3024:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    3028:	05 80       	ldd	r0, Z+5	; 0x05
    302a:	f6 81       	ldd	r31, Z+6	; 0x06
    302c:	e0 2d       	mov	r30, r0
    302e:	06 80       	ldd	r0, Z+6	; 0x06
    3030:	f7 81       	ldd	r31, Z+7	; 0x07
    3032:	e0 2d       	mov	r30, r0
    3034:	82 81       	ldd	r24, Z+2	; 0x02
    3036:	93 81       	ldd	r25, Z+3	; 0x03
    3038:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    303c:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    3040:	80 91 f3 15 	lds	r24, 0x15F3	; 0x8015f3 <xNextTaskUnblockTime>
    3044:	90 91 f4 15 	lds	r25, 0x15F4	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    3048:	e8 16       	cp	r14, r24
    304a:	f9 06       	cpc	r15, r25
    304c:	10 f4       	brcc	.+4      	; 0x3052 <xTaskResumeAll+0x170>
    304e:	a9 2c       	mov	r10, r9
    3050:	4f c0       	rjmp	.+158    	; 0x30f0 <xTaskResumeAll+0x20e>
    3052:	a9 2c       	mov	r10, r9
    3054:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    3058:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    305c:	80 81       	ld	r24, Z
    305e:	81 11       	cpse	r24, r1
    3060:	05 c0       	rjmp	.+10     	; 0x306c <xTaskResumeAll+0x18a>
    3062:	d0 92 f4 15 	sts	0x15F4, r13	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    3066:	c0 92 f3 15 	sts	0x15F3, r12	; 0x8015f3 <xNextTaskUnblockTime>
    306a:	42 c0       	rjmp	.+132    	; 0x30f0 <xTaskResumeAll+0x20e>
    306c:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    3070:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    3074:	05 80       	ldd	r0, Z+5	; 0x05
    3076:	f6 81       	ldd	r31, Z+6	; 0x06
    3078:	e0 2d       	mov	r30, r0
    307a:	c6 81       	ldd	r28, Z+6	; 0x06
    307c:	d7 81       	ldd	r29, Z+7	; 0x07
    307e:	8a 81       	ldd	r24, Y+2	; 0x02
    3080:	9b 81       	ldd	r25, Y+3	; 0x03
    3082:	e8 16       	cp	r14, r24
    3084:	f9 06       	cpc	r15, r25
    3086:	28 f4       	brcc	.+10     	; 0x3092 <xTaskResumeAll+0x1b0>
    3088:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    308c:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    3090:	2f c0       	rjmp	.+94     	; 0x30f0 <xTaskResumeAll+0x20e>
    3092:	8e 01       	movw	r16, r28
    3094:	0e 5f       	subi	r16, 0xFE	; 254
    3096:	1f 4f       	sbci	r17, 0xFF	; 255
    3098:	c8 01       	movw	r24, r16
    309a:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    309e:	8c 89       	ldd	r24, Y+20	; 0x14
    30a0:	9d 89       	ldd	r25, Y+21	; 0x15
    30a2:	89 2b       	or	r24, r25
    30a4:	21 f0       	breq	.+8      	; 0x30ae <xTaskResumeAll+0x1cc>
    30a6:	ce 01       	movw	r24, r28
    30a8:	0c 96       	adiw	r24, 0x0c	; 12
    30aa:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    30ae:	8e 89       	ldd	r24, Y+22	; 0x16
    30b0:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    30b4:	98 17       	cp	r25, r24
    30b6:	10 f4       	brcc	.+4      	; 0x30bc <xTaskResumeAll+0x1da>
    30b8:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    30bc:	90 e0       	ldi	r25, 0x00	; 0
    30be:	9c 01       	movw	r18, r24
    30c0:	22 0f       	add	r18, r18
    30c2:	33 1f       	adc	r19, r19
    30c4:	22 0f       	add	r18, r18
    30c6:	33 1f       	adc	r19, r19
    30c8:	22 0f       	add	r18, r18
    30ca:	33 1f       	adc	r19, r19
    30cc:	82 0f       	add	r24, r18
    30ce:	93 1f       	adc	r25, r19
    30d0:	b8 01       	movw	r22, r16
    30d2:	80 5d       	subi	r24, 0xD0	; 208
    30d4:	99 4e       	sbci	r25, 0xE9	; 233
    30d6:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    30da:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    30de:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    30e2:	9e 89       	ldd	r25, Y+22	; 0x16
    30e4:	86 89       	ldd	r24, Z+22	; 0x16
    30e6:	98 17       	cp	r25, r24
    30e8:	08 f4       	brcc	.+2      	; 0x30ec <xTaskResumeAll+0x20a>
    30ea:	b4 cf       	rjmp	.-152    	; 0x3054 <xTaskResumeAll+0x172>
    30ec:	ab 2c       	mov	r10, r11
    30ee:	b2 cf       	rjmp	.-156    	; 0x3054 <xTaskResumeAll+0x172>
    30f0:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    30f4:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    30f8:	86 89       	ldd	r24, Z+22	; 0x16
    30fa:	90 e0       	ldi	r25, 0x00	; 0
    30fc:	fc 01       	movw	r30, r24
    30fe:	ee 0f       	add	r30, r30
    3100:	ff 1f       	adc	r31, r31
    3102:	ee 0f       	add	r30, r30
    3104:	ff 1f       	adc	r31, r31
    3106:	ee 0f       	add	r30, r30
    3108:	ff 1f       	adc	r31, r31
    310a:	8e 0f       	add	r24, r30
    310c:	9f 1f       	adc	r25, r31
    310e:	fc 01       	movw	r30, r24
    3110:	e0 5d       	subi	r30, 0xD0	; 208
    3112:	f9 4e       	sbci	r31, 0xE9	; 233
    3114:	80 81       	ld	r24, Z
    3116:	82 30       	cpi	r24, 0x02	; 2
    3118:	48 f5       	brcc	.+82     	; 0x316c <xTaskResumeAll+0x28a>
    311a:	0a c0       	rjmp	.+20     	; 0x3130 <xTaskResumeAll+0x24e>
    311c:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    3120:	8f 5f       	subi	r24, 0xFF	; 255
    3122:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxPendedTicks>
    3126:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    312a:	81 11       	cpse	r24, r1
    312c:	06 c0       	rjmp	.+12     	; 0x313a <xTaskResumeAll+0x258>
    312e:	07 c0       	rjmp	.+14     	; 0x313e <xTaskResumeAll+0x25c>
    3130:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    3134:	81 11       	cpse	r24, r1
    3136:	01 c0       	rjmp	.+2      	; 0x313a <xTaskResumeAll+0x258>
    3138:	a1 10       	cpse	r10, r1
    313a:	b0 92 f7 15 	sts	0x15F7, r11	; 0x8015f7 <xYieldPending>
    313e:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    3142:	81 50       	subi	r24, 0x01	; 1
    3144:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxPendedTicks>
    3148:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    314c:	81 11       	cpse	r24, r1
    314e:	33 cf       	rjmp	.-410    	; 0x2fb6 <xTaskResumeAll+0xd4>
    3150:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    3154:	81 30       	cpi	r24, 0x01	; 1
    3156:	31 f4       	brne	.+12     	; 0x3164 <xTaskResumeAll+0x282>
    3158:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <vPortYield>
    315c:	81 e0       	ldi	r24, 0x01	; 1
    315e:	03 c0       	rjmp	.+6      	; 0x3166 <xTaskResumeAll+0x284>
    3160:	80 e0       	ldi	r24, 0x00	; 0
    3162:	01 c0       	rjmp	.+2      	; 0x3166 <xTaskResumeAll+0x284>
    3164:	80 e0       	ldi	r24, 0x00	; 0
    3166:	0f 90       	pop	r0
    3168:	0f be       	out	0x3f, r0	; 63
    316a:	03 c0       	rjmp	.+6      	; 0x3172 <xTaskResumeAll+0x290>
    316c:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    3170:	e4 cf       	rjmp	.-56     	; 0x313a <xTaskResumeAll+0x258>
    3172:	df 91       	pop	r29
    3174:	cf 91       	pop	r28
    3176:	1f 91       	pop	r17
    3178:	0f 91       	pop	r16
    317a:	ff 90       	pop	r15
    317c:	ef 90       	pop	r14
    317e:	df 90       	pop	r13
    3180:	cf 90       	pop	r12
    3182:	bf 90       	pop	r11
    3184:	af 90       	pop	r10
    3186:	9f 90       	pop	r9
    3188:	08 95       	ret

0000318a <xTaskIncrementTick>:
    318a:	cf 92       	push	r12
    318c:	df 92       	push	r13
    318e:	ef 92       	push	r14
    3190:	ff 92       	push	r15
    3192:	0f 93       	push	r16
    3194:	1f 93       	push	r17
    3196:	cf 93       	push	r28
    3198:	df 93       	push	r29
    319a:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    319e:	81 11       	cpse	r24, r1
    31a0:	b7 c0       	rjmp	.+366    	; 0x3310 <xTaskIncrementTick+0x186>
    31a2:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <xTickCount>
    31a6:	90 91 fc 15 	lds	r25, 0x15FC	; 0x8015fc <xTickCount+0x1>
    31aa:	01 96       	adiw	r24, 0x01	; 1
    31ac:	90 93 fc 15 	sts	0x15FC, r25	; 0x8015fc <xTickCount+0x1>
    31b0:	80 93 fb 15 	sts	0x15FB, r24	; 0x8015fb <xTickCount>
    31b4:	e0 90 fb 15 	lds	r14, 0x15FB	; 0x8015fb <xTickCount>
    31b8:	f0 90 fc 15 	lds	r15, 0x15FC	; 0x8015fc <xTickCount+0x1>
    31bc:	e1 14       	cp	r14, r1
    31be:	f1 04       	cpc	r15, r1
    31c0:	99 f5       	brne	.+102    	; 0x3228 <xTaskIncrementTick+0x9e>
    31c2:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <pxDelayedTaskList>
    31c6:	90 91 1d 16 	lds	r25, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    31ca:	20 91 1a 16 	lds	r18, 0x161A	; 0x80161a <pxOverflowDelayedTaskList>
    31ce:	30 91 1b 16 	lds	r19, 0x161B	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    31d2:	30 93 1d 16 	sts	0x161D, r19	; 0x80161d <pxDelayedTaskList+0x1>
    31d6:	20 93 1c 16 	sts	0x161C, r18	; 0x80161c <pxDelayedTaskList>
    31da:	90 93 1b 16 	sts	0x161B, r25	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    31de:	80 93 1a 16 	sts	0x161A, r24	; 0x80161a <pxOverflowDelayedTaskList>
    31e2:	80 91 f6 15 	lds	r24, 0x15F6	; 0x8015f6 <xNumOfOverflows>
    31e6:	8f 5f       	subi	r24, 0xFF	; 255
    31e8:	80 93 f6 15 	sts	0x15F6, r24	; 0x8015f6 <xNumOfOverflows>
    31ec:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    31f0:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    31f4:	80 81       	ld	r24, Z
    31f6:	81 11       	cpse	r24, r1
    31f8:	07 c0       	rjmp	.+14     	; 0x3208 <xTaskIncrementTick+0x7e>
    31fa:	8f ef       	ldi	r24, 0xFF	; 255
    31fc:	9f ef       	ldi	r25, 0xFF	; 255
    31fe:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    3202:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    3206:	10 c0       	rjmp	.+32     	; 0x3228 <xTaskIncrementTick+0x9e>
    3208:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    320c:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    3210:	05 80       	ldd	r0, Z+5	; 0x05
    3212:	f6 81       	ldd	r31, Z+6	; 0x06
    3214:	e0 2d       	mov	r30, r0
    3216:	06 80       	ldd	r0, Z+6	; 0x06
    3218:	f7 81       	ldd	r31, Z+7	; 0x07
    321a:	e0 2d       	mov	r30, r0
    321c:	82 81       	ldd	r24, Z+2	; 0x02
    321e:	93 81       	ldd	r25, Z+3	; 0x03
    3220:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    3224:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    3228:	80 91 f3 15 	lds	r24, 0x15F3	; 0x8015f3 <xNextTaskUnblockTime>
    322c:	90 91 f4 15 	lds	r25, 0x15F4	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    3230:	e8 16       	cp	r14, r24
    3232:	f9 06       	cpc	r15, r25
    3234:	10 f4       	brcc	.+4      	; 0x323a <xTaskIncrementTick+0xb0>
    3236:	d1 2c       	mov	r13, r1
    3238:	53 c0       	rjmp	.+166    	; 0x32e0 <xTaskIncrementTick+0x156>
    323a:	d1 2c       	mov	r13, r1
    323c:	cc 24       	eor	r12, r12
    323e:	c3 94       	inc	r12
    3240:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    3244:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    3248:	80 81       	ld	r24, Z
    324a:	81 11       	cpse	r24, r1
    324c:	07 c0       	rjmp	.+14     	; 0x325c <xTaskIncrementTick+0xd2>
    324e:	8f ef       	ldi	r24, 0xFF	; 255
    3250:	9f ef       	ldi	r25, 0xFF	; 255
    3252:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    3256:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    325a:	42 c0       	rjmp	.+132    	; 0x32e0 <xTaskIncrementTick+0x156>
    325c:	e0 91 1c 16 	lds	r30, 0x161C	; 0x80161c <pxDelayedTaskList>
    3260:	f0 91 1d 16 	lds	r31, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    3264:	05 80       	ldd	r0, Z+5	; 0x05
    3266:	f6 81       	ldd	r31, Z+6	; 0x06
    3268:	e0 2d       	mov	r30, r0
    326a:	c6 81       	ldd	r28, Z+6	; 0x06
    326c:	d7 81       	ldd	r29, Z+7	; 0x07
    326e:	8a 81       	ldd	r24, Y+2	; 0x02
    3270:	9b 81       	ldd	r25, Y+3	; 0x03
    3272:	e8 16       	cp	r14, r24
    3274:	f9 06       	cpc	r15, r25
    3276:	28 f4       	brcc	.+10     	; 0x3282 <xTaskIncrementTick+0xf8>
    3278:	90 93 f4 15 	sts	0x15F4, r25	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    327c:	80 93 f3 15 	sts	0x15F3, r24	; 0x8015f3 <xNextTaskUnblockTime>
    3280:	2f c0       	rjmp	.+94     	; 0x32e0 <xTaskIncrementTick+0x156>
    3282:	8e 01       	movw	r16, r28
    3284:	0e 5f       	subi	r16, 0xFE	; 254
    3286:	1f 4f       	sbci	r17, 0xFF	; 255
    3288:	c8 01       	movw	r24, r16
    328a:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    328e:	8c 89       	ldd	r24, Y+20	; 0x14
    3290:	9d 89       	ldd	r25, Y+21	; 0x15
    3292:	89 2b       	or	r24, r25
    3294:	21 f0       	breq	.+8      	; 0x329e <xTaskIncrementTick+0x114>
    3296:	ce 01       	movw	r24, r28
    3298:	0c 96       	adiw	r24, 0x0c	; 12
    329a:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    329e:	8e 89       	ldd	r24, Y+22	; 0x16
    32a0:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    32a4:	98 17       	cp	r25, r24
    32a6:	10 f4       	brcc	.+4      	; 0x32ac <xTaskIncrementTick+0x122>
    32a8:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    32ac:	90 e0       	ldi	r25, 0x00	; 0
    32ae:	9c 01       	movw	r18, r24
    32b0:	22 0f       	add	r18, r18
    32b2:	33 1f       	adc	r19, r19
    32b4:	22 0f       	add	r18, r18
    32b6:	33 1f       	adc	r19, r19
    32b8:	22 0f       	add	r18, r18
    32ba:	33 1f       	adc	r19, r19
    32bc:	82 0f       	add	r24, r18
    32be:	93 1f       	adc	r25, r19
    32c0:	b8 01       	movw	r22, r16
    32c2:	80 5d       	subi	r24, 0xD0	; 208
    32c4:	99 4e       	sbci	r25, 0xE9	; 233
    32c6:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    32ca:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    32ce:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    32d2:	9e 89       	ldd	r25, Y+22	; 0x16
    32d4:	86 89       	ldd	r24, Z+22	; 0x16
    32d6:	98 17       	cp	r25, r24
    32d8:	08 f4       	brcc	.+2      	; 0x32dc <xTaskIncrementTick+0x152>
    32da:	b2 cf       	rjmp	.-156    	; 0x3240 <xTaskIncrementTick+0xb6>
    32dc:	dc 2c       	mov	r13, r12
    32de:	b0 cf       	rjmp	.-160    	; 0x3240 <xTaskIncrementTick+0xb6>
    32e0:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    32e4:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    32e8:	86 89       	ldd	r24, Z+22	; 0x16
    32ea:	90 e0       	ldi	r25, 0x00	; 0
    32ec:	fc 01       	movw	r30, r24
    32ee:	ee 0f       	add	r30, r30
    32f0:	ff 1f       	adc	r31, r31
    32f2:	ee 0f       	add	r30, r30
    32f4:	ff 1f       	adc	r31, r31
    32f6:	ee 0f       	add	r30, r30
    32f8:	ff 1f       	adc	r31, r31
    32fa:	8e 0f       	add	r24, r30
    32fc:	9f 1f       	adc	r25, r31
    32fe:	fc 01       	movw	r30, r24
    3300:	e0 5d       	subi	r30, 0xD0	; 208
    3302:	f9 4e       	sbci	r31, 0xE9	; 233
    3304:	80 81       	ld	r24, Z
    3306:	82 30       	cpi	r24, 0x02	; 2
    3308:	48 f0       	brcs	.+18     	; 0x331c <xTaskIncrementTick+0x192>
    330a:	dd 24       	eor	r13, r13
    330c:	d3 94       	inc	r13
    330e:	06 c0       	rjmp	.+12     	; 0x331c <xTaskIncrementTick+0x192>
    3310:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxPendedTicks>
    3314:	8f 5f       	subi	r24, 0xFF	; 255
    3316:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxPendedTicks>
    331a:	d1 2c       	mov	r13, r1
    331c:	80 91 f7 15 	lds	r24, 0x15F7	; 0x8015f7 <xYieldPending>
    3320:	88 23       	and	r24, r24
    3322:	11 f0       	breq	.+4      	; 0x3328 <xTaskIncrementTick+0x19e>
    3324:	dd 24       	eor	r13, r13
    3326:	d3 94       	inc	r13
    3328:	8d 2d       	mov	r24, r13
    332a:	df 91       	pop	r29
    332c:	cf 91       	pop	r28
    332e:	1f 91       	pop	r17
    3330:	0f 91       	pop	r16
    3332:	ff 90       	pop	r15
    3334:	ef 90       	pop	r14
    3336:	df 90       	pop	r13
    3338:	cf 90       	pop	r12
    333a:	08 95       	ret

0000333c <vTaskSwitchContext>:
    333c:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    3340:	88 23       	and	r24, r24
    3342:	21 f0       	breq	.+8      	; 0x334c <vTaskSwitchContext+0x10>
    3344:	81 e0       	ldi	r24, 0x01	; 1
    3346:	80 93 f7 15 	sts	0x15F7, r24	; 0x8015f7 <xYieldPending>
    334a:	08 95       	ret
    334c:	10 92 f7 15 	sts	0x15F7, r1	; 0x8015f7 <xYieldPending>
    3350:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    3354:	90 e0       	ldi	r25, 0x00	; 0
    3356:	fc 01       	movw	r30, r24
    3358:	ee 0f       	add	r30, r30
    335a:	ff 1f       	adc	r31, r31
    335c:	ee 0f       	add	r30, r30
    335e:	ff 1f       	adc	r31, r31
    3360:	ee 0f       	add	r30, r30
    3362:	ff 1f       	adc	r31, r31
    3364:	8e 0f       	add	r24, r30
    3366:	9f 1f       	adc	r25, r31
    3368:	fc 01       	movw	r30, r24
    336a:	e0 5d       	subi	r30, 0xD0	; 208
    336c:	f9 4e       	sbci	r31, 0xE9	; 233
    336e:	80 81       	ld	r24, Z
    3370:	81 11       	cpse	r24, r1
    3372:	17 c0       	rjmp	.+46     	; 0x33a2 <vTaskSwitchContext+0x66>
    3374:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    3378:	81 50       	subi	r24, 0x01	; 1
    337a:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    337e:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    3382:	90 e0       	ldi	r25, 0x00	; 0
    3384:	fc 01       	movw	r30, r24
    3386:	ee 0f       	add	r30, r30
    3388:	ff 1f       	adc	r31, r31
    338a:	ee 0f       	add	r30, r30
    338c:	ff 1f       	adc	r31, r31
    338e:	ee 0f       	add	r30, r30
    3390:	ff 1f       	adc	r31, r31
    3392:	8e 0f       	add	r24, r30
    3394:	9f 1f       	adc	r25, r31
    3396:	fc 01       	movw	r30, r24
    3398:	e0 5d       	subi	r30, 0xD0	; 208
    339a:	f9 4e       	sbci	r31, 0xE9	; 233
    339c:	80 81       	ld	r24, Z
    339e:	88 23       	and	r24, r24
    33a0:	49 f3       	breq	.-46     	; 0x3374 <vTaskSwitchContext+0x38>
    33a2:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	9c 01       	movw	r18, r24
    33aa:	22 0f       	add	r18, r18
    33ac:	33 1f       	adc	r19, r19
    33ae:	22 0f       	add	r18, r18
    33b0:	33 1f       	adc	r19, r19
    33b2:	22 0f       	add	r18, r18
    33b4:	33 1f       	adc	r19, r19
    33b6:	28 0f       	add	r18, r24
    33b8:	39 1f       	adc	r19, r25
    33ba:	d9 01       	movw	r26, r18
    33bc:	a0 5d       	subi	r26, 0xD0	; 208
    33be:	b9 4e       	sbci	r27, 0xE9	; 233
    33c0:	11 96       	adiw	r26, 0x01	; 1
    33c2:	ed 91       	ld	r30, X+
    33c4:	fc 91       	ld	r31, X
    33c6:	12 97       	sbiw	r26, 0x02	; 2
    33c8:	02 80       	ldd	r0, Z+2	; 0x02
    33ca:	f3 81       	ldd	r31, Z+3	; 0x03
    33cc:	e0 2d       	mov	r30, r0
    33ce:	12 96       	adiw	r26, 0x02	; 2
    33d0:	fc 93       	st	X, r31
    33d2:	ee 93       	st	-X, r30
    33d4:	11 97       	sbiw	r26, 0x01	; 1
    33d6:	2d 5c       	subi	r18, 0xCD	; 205
    33d8:	39 4e       	sbci	r19, 0xE9	; 233
    33da:	e2 17       	cp	r30, r18
    33dc:	f3 07       	cpc	r31, r19
    33de:	29 f4       	brne	.+10     	; 0x33ea <vTaskSwitchContext+0xae>
    33e0:	22 81       	ldd	r18, Z+2	; 0x02
    33e2:	33 81       	ldd	r19, Z+3	; 0x03
    33e4:	fd 01       	movw	r30, r26
    33e6:	32 83       	std	Z+2, r19	; 0x02
    33e8:	21 83       	std	Z+1, r18	; 0x01
    33ea:	fc 01       	movw	r30, r24
    33ec:	ee 0f       	add	r30, r30
    33ee:	ff 1f       	adc	r31, r31
    33f0:	ee 0f       	add	r30, r30
    33f2:	ff 1f       	adc	r31, r31
    33f4:	ee 0f       	add	r30, r30
    33f6:	ff 1f       	adc	r31, r31
    33f8:	8e 0f       	add	r24, r30
    33fa:	9f 1f       	adc	r25, r31
    33fc:	fc 01       	movw	r30, r24
    33fe:	e0 5d       	subi	r30, 0xD0	; 208
    3400:	f9 4e       	sbci	r31, 0xE9	; 233
    3402:	01 80       	ldd	r0, Z+1	; 0x01
    3404:	f2 81       	ldd	r31, Z+2	; 0x02
    3406:	e0 2d       	mov	r30, r0
    3408:	86 81       	ldd	r24, Z+6	; 0x06
    340a:	97 81       	ldd	r25, Z+7	; 0x07
    340c:	90 93 55 16 	sts	0x1655, r25	; 0x801655 <pxCurrentTCB+0x1>
    3410:	80 93 54 16 	sts	0x1654, r24	; 0x801654 <pxCurrentTCB>
    3414:	08 95       	ret

00003416 <vTaskPlaceOnEventList>:
    3416:	cf 93       	push	r28
    3418:	df 93       	push	r29
    341a:	eb 01       	movw	r28, r22
    341c:	60 91 54 16 	lds	r22, 0x1654	; 0x801654 <pxCurrentTCB>
    3420:	70 91 55 16 	lds	r23, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    3424:	64 5f       	subi	r22, 0xF4	; 244
    3426:	7f 4f       	sbci	r23, 0xFF	; 255
    3428:	0e 94 a2 0c 	call	0x1944	; 0x1944 <vListInsert>
    342c:	80 91 54 16 	lds	r24, 0x1654	; 0x801654 <pxCurrentTCB>
    3430:	90 91 55 16 	lds	r25, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    3434:	02 96       	adiw	r24, 0x02	; 2
    3436:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    343a:	cf 3f       	cpi	r28, 0xFF	; 255
    343c:	8f ef       	ldi	r24, 0xFF	; 255
    343e:	d8 07       	cpc	r29, r24
    3440:	59 f4       	brne	.+22     	; 0x3458 <vTaskPlaceOnEventList+0x42>
    3442:	60 91 54 16 	lds	r22, 0x1654	; 0x801654 <pxCurrentTCB>
    3446:	70 91 55 16 	lds	r23, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    344a:	6e 5f       	subi	r22, 0xFE	; 254
    344c:	7f 4f       	sbci	r23, 0xFF	; 255
    344e:	8e ef       	ldi	r24, 0xFE	; 254
    3450:	95 e1       	ldi	r25, 0x15	; 21
    3452:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    3456:	37 c0       	rjmp	.+110    	; 0x34c6 <vTaskPlaceOnEventList+0xb0>
    3458:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <xTickCount>
    345c:	90 91 fc 15 	lds	r25, 0x15FC	; 0x8015fc <xTickCount+0x1>
    3460:	c8 0f       	add	r28, r24
    3462:	d9 1f       	adc	r29, r25
    3464:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    3468:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    346c:	d3 83       	std	Z+3, r29	; 0x03
    346e:	c2 83       	std	Z+2, r28	; 0x02
    3470:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <xTickCount>
    3474:	90 91 fc 15 	lds	r25, 0x15FC	; 0x8015fc <xTickCount+0x1>
    3478:	c8 17       	cp	r28, r24
    347a:	d9 07       	cpc	r29, r25
    347c:	68 f4       	brcc	.+26     	; 0x3498 <vTaskPlaceOnEventList+0x82>
    347e:	60 91 54 16 	lds	r22, 0x1654	; 0x801654 <pxCurrentTCB>
    3482:	70 91 55 16 	lds	r23, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    3486:	80 91 1a 16 	lds	r24, 0x161A	; 0x80161a <pxOverflowDelayedTaskList>
    348a:	90 91 1b 16 	lds	r25, 0x161B	; 0x80161b <pxOverflowDelayedTaskList+0x1>
    348e:	6e 5f       	subi	r22, 0xFE	; 254
    3490:	7f 4f       	sbci	r23, 0xFF	; 255
    3492:	0e 94 a2 0c 	call	0x1944	; 0x1944 <vListInsert>
    3496:	17 c0       	rjmp	.+46     	; 0x34c6 <vTaskPlaceOnEventList+0xb0>
    3498:	60 91 54 16 	lds	r22, 0x1654	; 0x801654 <pxCurrentTCB>
    349c:	70 91 55 16 	lds	r23, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    34a0:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <pxDelayedTaskList>
    34a4:	90 91 1d 16 	lds	r25, 0x161D	; 0x80161d <pxDelayedTaskList+0x1>
    34a8:	6e 5f       	subi	r22, 0xFE	; 254
    34aa:	7f 4f       	sbci	r23, 0xFF	; 255
    34ac:	0e 94 a2 0c 	call	0x1944	; 0x1944 <vListInsert>
    34b0:	80 91 f3 15 	lds	r24, 0x15F3	; 0x8015f3 <xNextTaskUnblockTime>
    34b4:	90 91 f4 15 	lds	r25, 0x15F4	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    34b8:	c8 17       	cp	r28, r24
    34ba:	d9 07       	cpc	r29, r25
    34bc:	20 f4       	brcc	.+8      	; 0x34c6 <vTaskPlaceOnEventList+0xb0>
    34be:	d0 93 f4 15 	sts	0x15F4, r29	; 0x8015f4 <xNextTaskUnblockTime+0x1>
    34c2:	c0 93 f3 15 	sts	0x15F3, r28	; 0x8015f3 <xNextTaskUnblockTime>
    34c6:	df 91       	pop	r29
    34c8:	cf 91       	pop	r28
    34ca:	08 95       	ret

000034cc <xTaskRemoveFromEventList>:
    34cc:	0f 93       	push	r16
    34ce:	1f 93       	push	r17
    34d0:	cf 93       	push	r28
    34d2:	df 93       	push	r29
    34d4:	dc 01       	movw	r26, r24
    34d6:	15 96       	adiw	r26, 0x05	; 5
    34d8:	ed 91       	ld	r30, X+
    34da:	fc 91       	ld	r31, X
    34dc:	16 97       	sbiw	r26, 0x06	; 6
    34de:	c6 81       	ldd	r28, Z+6	; 0x06
    34e0:	d7 81       	ldd	r29, Z+7	; 0x07
    34e2:	8e 01       	movw	r16, r28
    34e4:	04 5f       	subi	r16, 0xF4	; 244
    34e6:	1f 4f       	sbci	r17, 0xFF	; 255
    34e8:	c8 01       	movw	r24, r16
    34ea:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    34ee:	80 91 f2 15 	lds	r24, 0x15F2	; 0x8015f2 <uxSchedulerSuspended>
    34f2:	81 11       	cpse	r24, r1
    34f4:	1c c0       	rjmp	.+56     	; 0x352e <xTaskRemoveFromEventList+0x62>
    34f6:	0a 50       	subi	r16, 0x0A	; 10
    34f8:	11 09       	sbc	r17, r1
    34fa:	c8 01       	movw	r24, r16
    34fc:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    3500:	8e 89       	ldd	r24, Y+22	; 0x16
    3502:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    3506:	98 17       	cp	r25, r24
    3508:	10 f4       	brcc	.+4      	; 0x350e <xTaskRemoveFromEventList+0x42>
    350a:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    350e:	90 e0       	ldi	r25, 0x00	; 0
    3510:	9c 01       	movw	r18, r24
    3512:	22 0f       	add	r18, r18
    3514:	33 1f       	adc	r19, r19
    3516:	22 0f       	add	r18, r18
    3518:	33 1f       	adc	r19, r19
    351a:	22 0f       	add	r18, r18
    351c:	33 1f       	adc	r19, r19
    351e:	82 0f       	add	r24, r18
    3520:	93 1f       	adc	r25, r19
    3522:	b8 01       	movw	r22, r16
    3524:	80 5d       	subi	r24, 0xD0	; 208
    3526:	99 4e       	sbci	r25, 0xE9	; 233
    3528:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    352c:	05 c0       	rjmp	.+10     	; 0x3538 <xTaskRemoveFromEventList+0x6c>
    352e:	b8 01       	movw	r22, r16
    3530:	81 e1       	ldi	r24, 0x11	; 17
    3532:	96 e1       	ldi	r25, 0x16	; 22
    3534:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    3538:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    353c:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    3540:	9e 89       	ldd	r25, Y+22	; 0x16
    3542:	86 89       	ldd	r24, Z+22	; 0x16
    3544:	89 17       	cp	r24, r25
    3546:	20 f4       	brcc	.+8      	; 0x3550 <xTaskRemoveFromEventList+0x84>
    3548:	81 e0       	ldi	r24, 0x01	; 1
    354a:	80 93 f7 15 	sts	0x15F7, r24	; 0x8015f7 <xYieldPending>
    354e:	01 c0       	rjmp	.+2      	; 0x3552 <xTaskRemoveFromEventList+0x86>
    3550:	80 e0       	ldi	r24, 0x00	; 0
    3552:	df 91       	pop	r29
    3554:	cf 91       	pop	r28
    3556:	1f 91       	pop	r17
    3558:	0f 91       	pop	r16
    355a:	08 95       	ret

0000355c <vTaskSetTimeOutState>:
    355c:	20 91 f6 15 	lds	r18, 0x15F6	; 0x8015f6 <xNumOfOverflows>
    3560:	fc 01       	movw	r30, r24
    3562:	20 83       	st	Z, r18
    3564:	20 91 fb 15 	lds	r18, 0x15FB	; 0x8015fb <xTickCount>
    3568:	30 91 fc 15 	lds	r19, 0x15FC	; 0x8015fc <xTickCount+0x1>
    356c:	32 83       	std	Z+2, r19	; 0x02
    356e:	21 83       	std	Z+1, r18	; 0x01
    3570:	08 95       	ret

00003572 <xTaskCheckForTimeOut>:
    3572:	fc 01       	movw	r30, r24
    3574:	0f b6       	in	r0, 0x3f	; 63
    3576:	f8 94       	cli
    3578:	0f 92       	push	r0
    357a:	20 91 fb 15 	lds	r18, 0x15FB	; 0x8015fb <xTickCount>
    357e:	30 91 fc 15 	lds	r19, 0x15FC	; 0x8015fc <xTickCount+0x1>
    3582:	db 01       	movw	r26, r22
    3584:	8d 91       	ld	r24, X+
    3586:	9c 91       	ld	r25, X
    3588:	8f 3f       	cpi	r24, 0xFF	; 255
    358a:	bf ef       	ldi	r27, 0xFF	; 255
    358c:	9b 07       	cpc	r25, r27
    358e:	21 f1       	breq	.+72     	; 0x35d8 <xTaskCheckForTimeOut+0x66>
    3590:	40 91 f6 15 	lds	r20, 0x15F6	; 0x8015f6 <xNumOfOverflows>
    3594:	50 81       	ld	r21, Z
    3596:	54 17       	cp	r21, r20
    3598:	29 f0       	breq	.+10     	; 0x35a4 <xTaskCheckForTimeOut+0x32>
    359a:	41 81       	ldd	r20, Z+1	; 0x01
    359c:	52 81       	ldd	r21, Z+2	; 0x02
    359e:	24 17       	cp	r18, r20
    35a0:	35 07       	cpc	r19, r21
    35a2:	e0 f4       	brcc	.+56     	; 0x35dc <xTaskCheckForTimeOut+0x6a>
    35a4:	41 81       	ldd	r20, Z+1	; 0x01
    35a6:	52 81       	ldd	r21, Z+2	; 0x02
    35a8:	d9 01       	movw	r26, r18
    35aa:	a4 1b       	sub	r26, r20
    35ac:	b5 0b       	sbc	r27, r21
    35ae:	a8 17       	cp	r26, r24
    35b0:	b9 07       	cpc	r27, r25
    35b2:	b0 f4       	brcc	.+44     	; 0x35e0 <xTaskCheckForTimeOut+0x6e>
    35b4:	42 1b       	sub	r20, r18
    35b6:	53 0b       	sbc	r21, r19
    35b8:	84 0f       	add	r24, r20
    35ba:	95 1f       	adc	r25, r21
    35bc:	db 01       	movw	r26, r22
    35be:	8d 93       	st	X+, r24
    35c0:	9c 93       	st	X, r25
    35c2:	80 91 f6 15 	lds	r24, 0x15F6	; 0x8015f6 <xNumOfOverflows>
    35c6:	80 83       	st	Z, r24
    35c8:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <xTickCount>
    35cc:	90 91 fc 15 	lds	r25, 0x15FC	; 0x8015fc <xTickCount+0x1>
    35d0:	92 83       	std	Z+2, r25	; 0x02
    35d2:	81 83       	std	Z+1, r24	; 0x01
    35d4:	80 e0       	ldi	r24, 0x00	; 0
    35d6:	05 c0       	rjmp	.+10     	; 0x35e2 <xTaskCheckForTimeOut+0x70>
    35d8:	80 e0       	ldi	r24, 0x00	; 0
    35da:	03 c0       	rjmp	.+6      	; 0x35e2 <xTaskCheckForTimeOut+0x70>
    35dc:	81 e0       	ldi	r24, 0x01	; 1
    35de:	01 c0       	rjmp	.+2      	; 0x35e2 <xTaskCheckForTimeOut+0x70>
    35e0:	81 e0       	ldi	r24, 0x01	; 1
    35e2:	0f 90       	pop	r0
    35e4:	0f be       	out	0x3f, r0	; 63
    35e6:	08 95       	ret

000035e8 <vTaskMissedYield>:
    35e8:	81 e0       	ldi	r24, 0x01	; 1
    35ea:	80 93 f7 15 	sts	0x15F7, r24	; 0x8015f7 <xYieldPending>
    35ee:	08 95       	ret

000035f0 <vTaskPriorityInherit>:
    35f0:	0f 93       	push	r16
    35f2:	1f 93       	push	r17
    35f4:	cf 93       	push	r28
    35f6:	df 93       	push	r29
    35f8:	fc 01       	movw	r30, r24
    35fa:	89 2b       	or	r24, r25
    35fc:	09 f4       	brne	.+2      	; 0x3600 <vTaskPriorityInherit+0x10>
    35fe:	55 c0       	rjmp	.+170    	; 0x36aa <vTaskPriorityInherit+0xba>
    3600:	26 89       	ldd	r18, Z+22	; 0x16
    3602:	a0 91 54 16 	lds	r26, 0x1654	; 0x801654 <pxCurrentTCB>
    3606:	b0 91 55 16 	lds	r27, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    360a:	56 96       	adiw	r26, 0x16	; 22
    360c:	8c 91       	ld	r24, X
    360e:	28 17       	cp	r18, r24
    3610:	08 f0       	brcs	.+2      	; 0x3614 <vTaskPriorityInherit+0x24>
    3612:	4b c0       	rjmp	.+150    	; 0x36aa <vTaskPriorityInherit+0xba>
    3614:	84 85       	ldd	r24, Z+12	; 0x0c
    3616:	95 85       	ldd	r25, Z+13	; 0x0d
    3618:	99 23       	and	r25, r25
    361a:	64 f0       	brlt	.+24     	; 0x3634 <vTaskPriorityInherit+0x44>
    361c:	a0 91 54 16 	lds	r26, 0x1654	; 0x801654 <pxCurrentTCB>
    3620:	b0 91 55 16 	lds	r27, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    3624:	56 96       	adiw	r26, 0x16	; 22
    3626:	3c 91       	ld	r19, X
    3628:	84 e0       	ldi	r24, 0x04	; 4
    362a:	90 e0       	ldi	r25, 0x00	; 0
    362c:	83 1b       	sub	r24, r19
    362e:	91 09       	sbc	r25, r1
    3630:	95 87       	std	Z+13, r25	; 0x0d
    3632:	84 87       	std	Z+12, r24	; 0x0c
    3634:	30 e0       	ldi	r19, 0x00	; 0
    3636:	c9 01       	movw	r24, r18
    3638:	88 0f       	add	r24, r24
    363a:	99 1f       	adc	r25, r25
    363c:	88 0f       	add	r24, r24
    363e:	99 1f       	adc	r25, r25
    3640:	88 0f       	add	r24, r24
    3642:	99 1f       	adc	r25, r25
    3644:	28 0f       	add	r18, r24
    3646:	39 1f       	adc	r19, r25
    3648:	20 5d       	subi	r18, 0xD0	; 208
    364a:	39 4e       	sbci	r19, 0xE9	; 233
    364c:	82 85       	ldd	r24, Z+10	; 0x0a
    364e:	93 85       	ldd	r25, Z+11	; 0x0b
    3650:	82 17       	cp	r24, r18
    3652:	93 07       	cpc	r25, r19
    3654:	19 f5       	brne	.+70     	; 0x369c <vTaskPriorityInherit+0xac>
    3656:	8f 01       	movw	r16, r30
    3658:	ef 01       	movw	r28, r30
    365a:	22 96       	adiw	r28, 0x02	; 2
    365c:	ce 01       	movw	r24, r28
    365e:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    3662:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    3666:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    366a:	86 89       	ldd	r24, Z+22	; 0x16
    366c:	f8 01       	movw	r30, r16
    366e:	86 8b       	std	Z+22, r24	; 0x16
    3670:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    3674:	98 17       	cp	r25, r24
    3676:	10 f4       	brcc	.+4      	; 0x367c <vTaskPriorityInherit+0x8c>
    3678:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    367c:	90 e0       	ldi	r25, 0x00	; 0
    367e:	9c 01       	movw	r18, r24
    3680:	22 0f       	add	r18, r18
    3682:	33 1f       	adc	r19, r19
    3684:	22 0f       	add	r18, r18
    3686:	33 1f       	adc	r19, r19
    3688:	22 0f       	add	r18, r18
    368a:	33 1f       	adc	r19, r19
    368c:	82 0f       	add	r24, r18
    368e:	93 1f       	adc	r25, r19
    3690:	be 01       	movw	r22, r28
    3692:	80 5d       	subi	r24, 0xD0	; 208
    3694:	99 4e       	sbci	r25, 0xE9	; 233
    3696:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    369a:	07 c0       	rjmp	.+14     	; 0x36aa <vTaskPriorityInherit+0xba>
    369c:	a0 91 54 16 	lds	r26, 0x1654	; 0x801654 <pxCurrentTCB>
    36a0:	b0 91 55 16 	lds	r27, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    36a4:	56 96       	adiw	r26, 0x16	; 22
    36a6:	8c 91       	ld	r24, X
    36a8:	86 8b       	std	Z+22, r24	; 0x16
    36aa:	df 91       	pop	r29
    36ac:	cf 91       	pop	r28
    36ae:	1f 91       	pop	r17
    36b0:	0f 91       	pop	r16
    36b2:	08 95       	ret

000036b4 <xTaskPriorityDisinherit>:
    36b4:	0f 93       	push	r16
    36b6:	1f 93       	push	r17
    36b8:	cf 93       	push	r28
    36ba:	df 93       	push	r29
    36bc:	fc 01       	movw	r30, r24
    36be:	89 2b       	or	r24, r25
    36c0:	79 f1       	breq	.+94     	; 0x3720 <xTaskPriorityDisinherit+0x6c>
    36c2:	82 a1       	ldd	r24, Z+34	; 0x22
    36c4:	81 50       	subi	r24, 0x01	; 1
    36c6:	82 a3       	std	Z+34, r24	; 0x22
    36c8:	26 89       	ldd	r18, Z+22	; 0x16
    36ca:	91 a1       	ldd	r25, Z+33	; 0x21
    36cc:	29 17       	cp	r18, r25
    36ce:	51 f1       	breq	.+84     	; 0x3724 <xTaskPriorityDisinherit+0x70>
    36d0:	81 11       	cpse	r24, r1
    36d2:	2a c0       	rjmp	.+84     	; 0x3728 <xTaskPriorityDisinherit+0x74>
    36d4:	ef 01       	movw	r28, r30
    36d6:	8f 01       	movw	r16, r30
    36d8:	0e 5f       	subi	r16, 0xFE	; 254
    36da:	1f 4f       	sbci	r17, 0xFF	; 255
    36dc:	c8 01       	movw	r24, r16
    36de:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <uxListRemove>
    36e2:	89 a1       	ldd	r24, Y+33	; 0x21
    36e4:	8e 8b       	std	Y+22, r24	; 0x16
    36e6:	24 e0       	ldi	r18, 0x04	; 4
    36e8:	30 e0       	ldi	r19, 0x00	; 0
    36ea:	28 1b       	sub	r18, r24
    36ec:	31 09       	sbc	r19, r1
    36ee:	3d 87       	std	Y+13, r19	; 0x0d
    36f0:	2c 87       	std	Y+12, r18	; 0x0c
    36f2:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <uxTopReadyPriority>
    36f6:	98 17       	cp	r25, r24
    36f8:	10 f4       	brcc	.+4      	; 0x36fe <xTaskPriorityDisinherit+0x4a>
    36fa:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <uxTopReadyPriority>
    36fe:	90 e0       	ldi	r25, 0x00	; 0
    3700:	9c 01       	movw	r18, r24
    3702:	22 0f       	add	r18, r18
    3704:	33 1f       	adc	r19, r19
    3706:	22 0f       	add	r18, r18
    3708:	33 1f       	adc	r19, r19
    370a:	22 0f       	add	r18, r18
    370c:	33 1f       	adc	r19, r19
    370e:	82 0f       	add	r24, r18
    3710:	93 1f       	adc	r25, r19
    3712:	b8 01       	movw	r22, r16
    3714:	80 5d       	subi	r24, 0xD0	; 208
    3716:	99 4e       	sbci	r25, 0xE9	; 233
    3718:	0e 94 81 0c 	call	0x1902	; 0x1902 <vListInsertEnd>
    371c:	81 e0       	ldi	r24, 0x01	; 1
    371e:	05 c0       	rjmp	.+10     	; 0x372a <xTaskPriorityDisinherit+0x76>
    3720:	80 e0       	ldi	r24, 0x00	; 0
    3722:	03 c0       	rjmp	.+6      	; 0x372a <xTaskPriorityDisinherit+0x76>
    3724:	80 e0       	ldi	r24, 0x00	; 0
    3726:	01 c0       	rjmp	.+2      	; 0x372a <xTaskPriorityDisinherit+0x76>
    3728:	80 e0       	ldi	r24, 0x00	; 0
    372a:	df 91       	pop	r29
    372c:	cf 91       	pop	r28
    372e:	1f 91       	pop	r17
    3730:	0f 91       	pop	r16
    3732:	08 95       	ret

00003734 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    3734:	80 91 54 16 	lds	r24, 0x1654	; 0x801654 <pxCurrentTCB>
    3738:	90 91 55 16 	lds	r25, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    373c:	89 2b       	or	r24, r25
    373e:	39 f0       	breq	.+14     	; 0x374e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    3740:	e0 91 54 16 	lds	r30, 0x1654	; 0x801654 <pxCurrentTCB>
    3744:	f0 91 55 16 	lds	r31, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
    3748:	82 a1       	ldd	r24, Z+34	; 0x22
    374a:	8f 5f       	subi	r24, 0xFF	; 255
    374c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    374e:	80 91 54 16 	lds	r24, 0x1654	; 0x801654 <pxCurrentTCB>
    3752:	90 91 55 16 	lds	r25, 0x1655	; 0x801655 <pxCurrentTCB+0x1>
	}
    3756:	08 95       	ret

00003758 <xSerialPutChar>:

		default:
			break;
	}
	return 0;
}
    3758:	cf 93       	push	r28
    375a:	df 93       	push	r29
    375c:	dc 01       	movw	r26, r24
    375e:	0f b6       	in	r0, 0x3f	; 63
    3760:	f8 94       	cli
    3762:	0f 92       	push	r0
    3764:	1d 96       	adiw	r26, 0x0d	; 13
    3766:	2d 91       	ld	r18, X+
    3768:	3c 91       	ld	r19, X
    376a:	1e 97       	sbiw	r26, 0x0e	; 14
    376c:	0f 90       	pop	r0
    376e:	0f be       	out	0x3f, r0	; 63
    3770:	57 96       	adiw	r26, 0x17	; 23
    3772:	8d 91       	ld	r24, X+
    3774:	9c 91       	ld	r25, X
    3776:	58 97       	sbiw	r26, 0x18	; 24
    3778:	28 17       	cp	r18, r24
    377a:	39 07       	cpc	r19, r25
    377c:	f1 f0       	breq	.+60     	; 0x37ba <xSerialPutChar+0x62>
    377e:	fd 01       	movw	r30, r26
    3780:	3d 96       	adiw	r30, 0x0d	; 13
    3782:	c2 81       	ldd	r28, Z+2	; 0x02
    3784:	d3 81       	ldd	r29, Z+3	; 0x03
    3786:	68 83       	st	Y, r22
    3788:	82 81       	ldd	r24, Z+2	; 0x02
    378a:	93 81       	ldd	r25, Z+3	; 0x03
    378c:	01 96       	adiw	r24, 0x01	; 1
    378e:	93 83       	std	Z+3, r25	; 0x03
    3790:	82 83       	std	Z+2, r24	; 0x02
    3792:	20 85       	ldd	r18, Z+8	; 0x08
    3794:	31 85       	ldd	r19, Z+9	; 0x09
    3796:	82 17       	cp	r24, r18
    3798:	93 07       	cpc	r25, r19
    379a:	21 f4       	brne	.+8      	; 0x37a4 <xSerialPutChar+0x4c>
    379c:	86 81       	ldd	r24, Z+6	; 0x06
    379e:	97 81       	ldd	r25, Z+7	; 0x07
    37a0:	93 83       	std	Z+3, r25	; 0x03
    37a2:	82 83       	std	Z+2, r24	; 0x02
    37a4:	0f b6       	in	r0, 0x3f	; 63
    37a6:	f8 94       	cli
    37a8:	0f 92       	push	r0
    37aa:	80 81       	ld	r24, Z
    37ac:	91 81       	ldd	r25, Z+1	; 0x01
    37ae:	01 96       	adiw	r24, 0x01	; 1
    37b0:	91 83       	std	Z+1, r25	; 0x01
    37b2:	80 83       	st	Z, r24
    37b4:	0f 90       	pop	r0
    37b6:	0f be       	out	0x3f, r0	; 63
    37b8:	37 c0       	rjmp	.+110    	; 0x3828 <xSerialPutChar+0xd0>
    37ba:	2f ef       	ldi	r18, 0xFF	; 255
    37bc:	8f e8       	ldi	r24, 0x8F	; 143
    37be:	91 e0       	ldi	r25, 0x01	; 1
    37c0:	21 50       	subi	r18, 0x01	; 1
    37c2:	80 40       	sbci	r24, 0x00	; 0
    37c4:	90 40       	sbci	r25, 0x00	; 0
    37c6:	e1 f7       	brne	.-8      	; 0x37c0 <xSerialPutChar+0x68>
    37c8:	00 c0       	rjmp	.+0      	; 0x37ca <xSerialPutChar+0x72>
    37ca:	00 00       	nop
    37cc:	0f b6       	in	r0, 0x3f	; 63
    37ce:	f8 94       	cli
    37d0:	0f 92       	push	r0
    37d2:	1d 96       	adiw	r26, 0x0d	; 13
    37d4:	2d 91       	ld	r18, X+
    37d6:	3c 91       	ld	r19, X
    37d8:	1e 97       	sbiw	r26, 0x0e	; 14
    37da:	0f 90       	pop	r0
    37dc:	0f be       	out	0x3f, r0	; 63
    37de:	57 96       	adiw	r26, 0x17	; 23
    37e0:	8d 91       	ld	r24, X+
    37e2:	9c 91       	ld	r25, X
    37e4:	58 97       	sbiw	r26, 0x18	; 24
    37e6:	28 17       	cp	r18, r24
    37e8:	39 07       	cpc	r19, r25
    37ea:	09 f4       	brne	.+2      	; 0x37ee <xSerialPutChar+0x96>
    37ec:	44 c0       	rjmp	.+136    	; 0x3876 <xSerialPutChar+0x11e>
    37ee:	fd 01       	movw	r30, r26
    37f0:	3d 96       	adiw	r30, 0x0d	; 13
    37f2:	c2 81       	ldd	r28, Z+2	; 0x02
    37f4:	d3 81       	ldd	r29, Z+3	; 0x03
    37f6:	68 83       	st	Y, r22
    37f8:	82 81       	ldd	r24, Z+2	; 0x02
    37fa:	93 81       	ldd	r25, Z+3	; 0x03
    37fc:	01 96       	adiw	r24, 0x01	; 1
    37fe:	93 83       	std	Z+3, r25	; 0x03
    3800:	82 83       	std	Z+2, r24	; 0x02
    3802:	20 85       	ldd	r18, Z+8	; 0x08
    3804:	31 85       	ldd	r19, Z+9	; 0x09
    3806:	82 17       	cp	r24, r18
    3808:	93 07       	cpc	r25, r19
    380a:	21 f4       	brne	.+8      	; 0x3814 <xSerialPutChar+0xbc>
    380c:	86 81       	ldd	r24, Z+6	; 0x06
    380e:	97 81       	ldd	r25, Z+7	; 0x07
    3810:	93 83       	std	Z+3, r25	; 0x03
    3812:	82 83       	std	Z+2, r24	; 0x02
    3814:	0f b6       	in	r0, 0x3f	; 63
    3816:	f8 94       	cli
    3818:	0f 92       	push	r0
    381a:	80 81       	ld	r24, Z
    381c:	91 81       	ldd	r25, Z+1	; 0x01
    381e:	01 96       	adiw	r24, 0x01	; 1
    3820:	91 83       	std	Z+1, r25	; 0x01
    3822:	80 83       	st	Z, r24
    3824:	0f 90       	pop	r0
    3826:	0f be       	out	0x3f, r0	; 63
    3828:	8c 91       	ld	r24, X
    382a:	90 e0       	ldi	r25, 0x00	; 0
    382c:	88 30       	cpi	r24, 0x08	; 8
    382e:	91 05       	cpc	r25, r1
    3830:	20 f5       	brcc	.+72     	; 0x387a <xSerialPutChar+0x122>
    3832:	fc 01       	movw	r30, r24
    3834:	88 27       	eor	r24, r24
    3836:	ee 58       	subi	r30, 0x8E	; 142
    3838:	ff 4f       	sbci	r31, 0xFF	; 255
    383a:	8f 4f       	sbci	r24, 0xFF	; 255
    383c:	f1 c5       	rjmp	.+3042   	; 0x4420 <__tablejump2__>
    383e:	e1 ec       	ldi	r30, 0xC1	; 193
    3840:	f0 e0       	ldi	r31, 0x00	; 0
    3842:	80 81       	ld	r24, Z
    3844:	80 62       	ori	r24, 0x20	; 32
    3846:	80 83       	st	Z, r24
    3848:	81 e0       	ldi	r24, 0x01	; 1
    384a:	18 c0       	rjmp	.+48     	; 0x387c <xSerialPutChar+0x124>
    384c:	e9 ec       	ldi	r30, 0xC9	; 201
    384e:	f0 e0       	ldi	r31, 0x00	; 0
    3850:	80 81       	ld	r24, Z
    3852:	80 62       	ori	r24, 0x20	; 32
    3854:	80 83       	st	Z, r24
    3856:	81 e0       	ldi	r24, 0x01	; 1
    3858:	11 c0       	rjmp	.+34     	; 0x387c <xSerialPutChar+0x124>
    385a:	e1 ed       	ldi	r30, 0xD1	; 209
    385c:	f0 e0       	ldi	r31, 0x00	; 0
    385e:	80 81       	ld	r24, Z
    3860:	80 62       	ori	r24, 0x20	; 32
    3862:	80 83       	st	Z, r24
    3864:	81 e0       	ldi	r24, 0x01	; 1
    3866:	0a c0       	rjmp	.+20     	; 0x387c <xSerialPutChar+0x124>
    3868:	e1 e3       	ldi	r30, 0x31	; 49
    386a:	f1 e0       	ldi	r31, 0x01	; 1
    386c:	80 81       	ld	r24, Z
    386e:	80 62       	ori	r24, 0x20	; 32
    3870:	80 83       	st	Z, r24
    3872:	81 e0       	ldi	r24, 0x01	; 1
    3874:	03 c0       	rjmp	.+6      	; 0x387c <xSerialPutChar+0x124>
    3876:	80 e0       	ldi	r24, 0x00	; 0
    3878:	01 c0       	rjmp	.+2      	; 0x387c <xSerialPutChar+0x124>
    387a:	81 e0       	ldi	r24, 0x01	; 1
    387c:	df 91       	pop	r29
    387e:	cf 91       	pop	r28
    3880:	08 95       	ret

00003882 <xSerialPortInitMinimal>:
    3882:	7f 92       	push	r7
    3884:	8f 92       	push	r8
    3886:	9f 92       	push	r9
    3888:	af 92       	push	r10
    388a:	bf 92       	push	r11
    388c:	cf 92       	push	r12
    388e:	df 92       	push	r13
    3890:	ef 92       	push	r14
    3892:	ff 92       	push	r15
    3894:	0f 93       	push	r16
    3896:	1f 93       	push	r17
    3898:	cf 93       	push	r28
    389a:	df 93       	push	r29
    389c:	cd b7       	in	r28, 0x3d	; 61
    389e:	de b7       	in	r29, 0x3e	; 62
    38a0:	a2 97       	sbiw	r28, 0x22	; 34
    38a2:	0f b6       	in	r0, 0x3f	; 63
    38a4:	f8 94       	cli
    38a6:	de bf       	out	0x3e, r29	; 62
    38a8:	0f be       	out	0x3f, r0	; 63
    38aa:	cd bf       	out	0x3d, r28	; 61
    38ac:	6c 01       	movw	r12, r24
    38ae:	76 2e       	mov	r7, r22
    38b0:	49 01       	movw	r8, r18
    38b2:	5a 01       	movw	r10, r20
    38b4:	c7 01       	movw	r24, r14
    38b6:	0e 94 39 0c 	call	0x1872	; 0x1872 <pvPortMalloc>
    38ba:	00 97       	sbiw	r24, 0x00	; 0
    38bc:	a9 f0       	breq	.+42     	; 0x38e8 <xSerialPortInitMinimal+0x66>
    38be:	fe 01       	movw	r30, r28
    38c0:	32 96       	adiw	r30, 0x02	; 2
    38c2:	0f b6       	in	r0, 0x3f	; 63
    38c4:	f8 94       	cli
    38c6:	0f 92       	push	r0
    38c8:	11 82       	std	Z+1, r1	; 0x01
    38ca:	10 82       	st	Z, r1
    38cc:	93 83       	std	Z+3, r25	; 0x03
    38ce:	82 83       	std	Z+2, r24	; 0x02
    38d0:	95 83       	std	Z+5, r25	; 0x05
    38d2:	84 83       	std	Z+4, r24	; 0x04
    38d4:	97 83       	std	Z+7, r25	; 0x07
    38d6:	86 83       	std	Z+6, r24	; 0x06
    38d8:	8e 0d       	add	r24, r14
    38da:	9f 1d       	adc	r25, r15
    38dc:	91 87       	std	Z+9, r25	; 0x09
    38de:	80 87       	std	Z+8, r24	; 0x08
    38e0:	f3 86       	std	Z+11, r15	; 0x0b
    38e2:	e2 86       	std	Z+10, r14	; 0x0a
    38e4:	0f 90       	pop	r0
    38e6:	0f be       	out	0x3f, r0	; 63
    38e8:	c8 01       	movw	r24, r16
    38ea:	0e 94 39 0c 	call	0x1872	; 0x1872 <pvPortMalloc>
    38ee:	00 97       	sbiw	r24, 0x00	; 0
    38f0:	a9 f0       	breq	.+42     	; 0x391c <xSerialPortInitMinimal+0x9a>
    38f2:	fe 01       	movw	r30, r28
    38f4:	3e 96       	adiw	r30, 0x0e	; 14
    38f6:	0f b6       	in	r0, 0x3f	; 63
    38f8:	f8 94       	cli
    38fa:	0f 92       	push	r0
    38fc:	11 82       	std	Z+1, r1	; 0x01
    38fe:	10 82       	st	Z, r1
    3900:	93 83       	std	Z+3, r25	; 0x03
    3902:	82 83       	std	Z+2, r24	; 0x02
    3904:	95 83       	std	Z+5, r25	; 0x05
    3906:	84 83       	std	Z+4, r24	; 0x04
    3908:	97 83       	std	Z+7, r25	; 0x07
    390a:	86 83       	std	Z+6, r24	; 0x06
    390c:	80 0f       	add	r24, r16
    390e:	91 1f       	adc	r25, r17
    3910:	91 87       	std	Z+9, r25	; 0x09
    3912:	80 87       	std	Z+8, r24	; 0x08
    3914:	13 87       	std	Z+11, r17	; 0x0b
    3916:	02 87       	std	Z+10, r16	; 0x0a
    3918:	0f 90       	pop	r0
    391a:	0f be       	out	0x3f, r0	; 63
    391c:	c8 01       	movw	r24, r16
    391e:	0e 94 39 0c 	call	0x1872	; 0x1872 <pvPortMalloc>
    3922:	9b 8f       	std	Y+27, r25	; 0x1b
    3924:	8a 8f       	std	Y+26, r24	; 0x1a
    3926:	79 82       	std	Y+1, r7	; 0x01
    3928:	1d 8f       	std	Y+29, r17	; 0x1d
    392a:	0c 8f       	std	Y+28, r16	; 0x1c
    392c:	1e 8e       	std	Y+30, r1	; 0x1e
    392e:	8f 8e       	std	Y+31, r8	; 0x1f
    3930:	98 a2       	std	Y+32, r9	; 0x20
    3932:	a9 a2       	std	Y+33, r10	; 0x21
    3934:	ba a2       	std	Y+34, r11	; 0x22
    3936:	0f b6       	in	r0, 0x3f	; 63
    3938:	f8 94       	cli
    393a:	0f 92       	push	r0
    393c:	89 81       	ldd	r24, Y+1	; 0x01
    393e:	90 e0       	ldi	r25, 0x00	; 0
    3940:	88 30       	cpi	r24, 0x08	; 8
    3942:	91 05       	cpc	r25, r1
    3944:	08 f0       	brcs	.+2      	; 0x3948 <xSerialPortInitMinimal+0xc6>
    3946:	b1 c1       	rjmp	.+866    	; 0x3caa <xSerialPortInitMinimal+0x428>
    3948:	fc 01       	movw	r30, r24
    394a:	88 27       	eor	r24, r24
    394c:	e6 58       	subi	r30, 0x86	; 134
    394e:	ff 4f       	sbci	r31, 0xFF	; 255
    3950:	8f 4f       	sbci	r24, 0xFF	; 255
    3952:	66 c5       	rjmp	.+2764   	; 0x4420 <__tablejump2__>
    3954:	d5 01       	movw	r26, r10
    3956:	c4 01       	movw	r24, r8
    3958:	97 5f       	subi	r25, 0xF7	; 247
    395a:	a2 4c       	sbci	r26, 0xC2	; 194
    395c:	bf 4f       	sbci	r27, 0xFF	; 255
    395e:	bc 01       	movw	r22, r24
    3960:	cd 01       	movw	r24, r26
    3962:	66 0f       	add	r22, r22
    3964:	77 1f       	adc	r23, r23
    3966:	88 1f       	adc	r24, r24
    3968:	99 1f       	adc	r25, r25
    396a:	66 0f       	add	r22, r22
    396c:	77 1f       	adc	r23, r23
    396e:	88 1f       	adc	r24, r24
    3970:	99 1f       	adc	r25, r25
    3972:	95 01       	movw	r18, r10
    3974:	84 01       	movw	r16, r8
    3976:	00 0f       	add	r16, r16
    3978:	11 1f       	adc	r17, r17
    397a:	22 1f       	adc	r18, r18
    397c:	33 1f       	adc	r19, r19
    397e:	00 0f       	add	r16, r16
    3980:	11 1f       	adc	r17, r17
    3982:	22 1f       	adc	r18, r18
    3984:	33 1f       	adc	r19, r19
    3986:	a9 01       	movw	r20, r18
    3988:	98 01       	movw	r18, r16
    398a:	22 0f       	add	r18, r18
    398c:	33 1f       	adc	r19, r19
    398e:	44 1f       	adc	r20, r20
    3990:	55 1f       	adc	r21, r21
    3992:	08 d5       	rcall	.+2576   	; 0x43a4 <__udivmodsi4>
    3994:	21 50       	subi	r18, 0x01	; 1
    3996:	31 09       	sbc	r19, r1
    3998:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    399c:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    39a0:	82 e0       	ldi	r24, 0x02	; 2
    39a2:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    39a6:	88 e9       	ldi	r24, 0x98	; 152
    39a8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    39ac:	8e e0       	ldi	r24, 0x0E	; 14
    39ae:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    39b2:	7b c1       	rjmp	.+758    	; 0x3caa <xSerialPortInitMinimal+0x428>
    39b4:	04 ec       	ldi	r16, 0xC4	; 196
    39b6:	10 e0       	ldi	r17, 0x00	; 0
    39b8:	f8 01       	movw	r30, r16
    39ba:	11 82       	std	Z+1, r1	; 0x01
    39bc:	10 82       	st	Z, r1
    39be:	6a 9a       	sbi	0x0d, 2	; 13
    39c0:	80 ec       	ldi	r24, 0xC0	; 192
    39c2:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    39c6:	88 e9       	ldi	r24, 0x98	; 152
    39c8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    39cc:	d5 01       	movw	r26, r10
    39ce:	c4 01       	movw	r24, r8
    39d0:	80 58       	subi	r24, 0x80	; 128
    39d2:	9b 47       	sbci	r25, 0x7B	; 123
    39d4:	a1 4e       	sbci	r26, 0xE1	; 225
    39d6:	bf 4f       	sbci	r27, 0xFF	; 255
    39d8:	88 0f       	add	r24, r24
    39da:	99 1f       	adc	r25, r25
    39dc:	aa 1f       	adc	r26, r26
    39de:	bb 1f       	adc	r27, r27
    39e0:	88 0f       	add	r24, r24
    39e2:	99 1f       	adc	r25, r25
    39e4:	aa 1f       	adc	r26, r26
    39e6:	bb 1f       	adc	r27, r27
    39e8:	bc 01       	movw	r22, r24
    39ea:	cd 01       	movw	r24, r26
    39ec:	66 0f       	add	r22, r22
    39ee:	77 1f       	adc	r23, r23
    39f0:	88 1f       	adc	r24, r24
    39f2:	99 1f       	adc	r25, r25
    39f4:	88 0c       	add	r8, r8
    39f6:	99 1c       	adc	r9, r9
    39f8:	aa 1c       	adc	r10, r10
    39fa:	bb 1c       	adc	r11, r11
    39fc:	88 0c       	add	r8, r8
    39fe:	99 1c       	adc	r9, r9
    3a00:	aa 1c       	adc	r10, r10
    3a02:	bb 1c       	adc	r11, r11
    3a04:	a5 01       	movw	r20, r10
    3a06:	94 01       	movw	r18, r8
    3a08:	22 0f       	add	r18, r18
    3a0a:	33 1f       	adc	r19, r19
    3a0c:	44 1f       	adc	r20, r20
    3a0e:	55 1f       	adc	r21, r21
    3a10:	22 0f       	add	r18, r18
    3a12:	33 1f       	adc	r19, r19
    3a14:	44 1f       	adc	r20, r20
    3a16:	55 1f       	adc	r21, r21
    3a18:	c5 d4       	rcall	.+2442   	; 0x43a4 <__udivmodsi4>
    3a1a:	21 50       	subi	r18, 0x01	; 1
    3a1c:	31 09       	sbc	r19, r1
    3a1e:	f8 01       	movw	r30, r16
    3a20:	31 83       	std	Z+1, r19	; 0x01
    3a22:	20 83       	st	Z, r18
    3a24:	42 c1       	rjmp	.+644    	; 0x3caa <xSerialPortInitMinimal+0x428>
    3a26:	d5 01       	movw	r26, r10
    3a28:	c4 01       	movw	r24, r8
    3a2a:	97 5f       	subi	r25, 0xF7	; 247
    3a2c:	a2 4c       	sbci	r26, 0xC2	; 194
    3a2e:	bf 4f       	sbci	r27, 0xFF	; 255
    3a30:	bc 01       	movw	r22, r24
    3a32:	cd 01       	movw	r24, r26
    3a34:	66 0f       	add	r22, r22
    3a36:	77 1f       	adc	r23, r23
    3a38:	88 1f       	adc	r24, r24
    3a3a:	99 1f       	adc	r25, r25
    3a3c:	66 0f       	add	r22, r22
    3a3e:	77 1f       	adc	r23, r23
    3a40:	88 1f       	adc	r24, r24
    3a42:	99 1f       	adc	r25, r25
    3a44:	95 01       	movw	r18, r10
    3a46:	84 01       	movw	r16, r8
    3a48:	00 0f       	add	r16, r16
    3a4a:	11 1f       	adc	r17, r17
    3a4c:	22 1f       	adc	r18, r18
    3a4e:	33 1f       	adc	r19, r19
    3a50:	00 0f       	add	r16, r16
    3a52:	11 1f       	adc	r17, r17
    3a54:	22 1f       	adc	r18, r18
    3a56:	33 1f       	adc	r19, r19
    3a58:	a9 01       	movw	r20, r18
    3a5a:	98 01       	movw	r18, r16
    3a5c:	22 0f       	add	r18, r18
    3a5e:	33 1f       	adc	r19, r19
    3a60:	44 1f       	adc	r20, r20
    3a62:	55 1f       	adc	r21, r21
    3a64:	9f d4       	rcall	.+2366   	; 0x43a4 <__udivmodsi4>
    3a66:	21 50       	subi	r18, 0x01	; 1
    3a68:	31 09       	sbc	r19, r1
    3a6a:	30 93 cd 00 	sts	0x00CD, r19	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    3a6e:	20 93 cc 00 	sts	0x00CC, r18	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    3a72:	82 e0       	ldi	r24, 0x02	; 2
    3a74:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    3a78:	88 e9       	ldi	r24, 0x98	; 152
    3a7a:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    3a7e:	8e e0       	ldi	r24, 0x0E	; 14
    3a80:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    3a84:	12 c1       	rjmp	.+548    	; 0x3caa <xSerialPortInitMinimal+0x428>
    3a86:	0c ec       	ldi	r16, 0xCC	; 204
    3a88:	10 e0       	ldi	r17, 0x00	; 0
    3a8a:	f8 01       	movw	r30, r16
    3a8c:	11 82       	std	Z+1, r1	; 0x01
    3a8e:	10 82       	st	Z, r1
    3a90:	55 9a       	sbi	0x0a, 5	; 10
    3a92:	80 ec       	ldi	r24, 0xC0	; 192
    3a94:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    3a98:	88 e9       	ldi	r24, 0x98	; 152
    3a9a:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    3a9e:	d5 01       	movw	r26, r10
    3aa0:	c4 01       	movw	r24, r8
    3aa2:	80 58       	subi	r24, 0x80	; 128
    3aa4:	9b 47       	sbci	r25, 0x7B	; 123
    3aa6:	a1 4e       	sbci	r26, 0xE1	; 225
    3aa8:	bf 4f       	sbci	r27, 0xFF	; 255
    3aaa:	88 0f       	add	r24, r24
    3aac:	99 1f       	adc	r25, r25
    3aae:	aa 1f       	adc	r26, r26
    3ab0:	bb 1f       	adc	r27, r27
    3ab2:	88 0f       	add	r24, r24
    3ab4:	99 1f       	adc	r25, r25
    3ab6:	aa 1f       	adc	r26, r26
    3ab8:	bb 1f       	adc	r27, r27
    3aba:	bc 01       	movw	r22, r24
    3abc:	cd 01       	movw	r24, r26
    3abe:	66 0f       	add	r22, r22
    3ac0:	77 1f       	adc	r23, r23
    3ac2:	88 1f       	adc	r24, r24
    3ac4:	99 1f       	adc	r25, r25
    3ac6:	88 0c       	add	r8, r8
    3ac8:	99 1c       	adc	r9, r9
    3aca:	aa 1c       	adc	r10, r10
    3acc:	bb 1c       	adc	r11, r11
    3ace:	88 0c       	add	r8, r8
    3ad0:	99 1c       	adc	r9, r9
    3ad2:	aa 1c       	adc	r10, r10
    3ad4:	bb 1c       	adc	r11, r11
    3ad6:	a5 01       	movw	r20, r10
    3ad8:	94 01       	movw	r18, r8
    3ada:	22 0f       	add	r18, r18
    3adc:	33 1f       	adc	r19, r19
    3ade:	44 1f       	adc	r20, r20
    3ae0:	55 1f       	adc	r21, r21
    3ae2:	22 0f       	add	r18, r18
    3ae4:	33 1f       	adc	r19, r19
    3ae6:	44 1f       	adc	r20, r20
    3ae8:	55 1f       	adc	r21, r21
    3aea:	5c d4       	rcall	.+2232   	; 0x43a4 <__udivmodsi4>
    3aec:	21 50       	subi	r18, 0x01	; 1
    3aee:	31 09       	sbc	r19, r1
    3af0:	f8 01       	movw	r30, r16
    3af2:	31 83       	std	Z+1, r19	; 0x01
    3af4:	20 83       	st	Z, r18
    3af6:	d9 c0       	rjmp	.+434    	; 0x3caa <xSerialPortInitMinimal+0x428>
    3af8:	d5 01       	movw	r26, r10
    3afa:	c4 01       	movw	r24, r8
    3afc:	97 5f       	subi	r25, 0xF7	; 247
    3afe:	a2 4c       	sbci	r26, 0xC2	; 194
    3b00:	bf 4f       	sbci	r27, 0xFF	; 255
    3b02:	bc 01       	movw	r22, r24
    3b04:	cd 01       	movw	r24, r26
    3b06:	66 0f       	add	r22, r22
    3b08:	77 1f       	adc	r23, r23
    3b0a:	88 1f       	adc	r24, r24
    3b0c:	99 1f       	adc	r25, r25
    3b0e:	66 0f       	add	r22, r22
    3b10:	77 1f       	adc	r23, r23
    3b12:	88 1f       	adc	r24, r24
    3b14:	99 1f       	adc	r25, r25
    3b16:	95 01       	movw	r18, r10
    3b18:	84 01       	movw	r16, r8
    3b1a:	00 0f       	add	r16, r16
    3b1c:	11 1f       	adc	r17, r17
    3b1e:	22 1f       	adc	r18, r18
    3b20:	33 1f       	adc	r19, r19
    3b22:	00 0f       	add	r16, r16
    3b24:	11 1f       	adc	r17, r17
    3b26:	22 1f       	adc	r18, r18
    3b28:	33 1f       	adc	r19, r19
    3b2a:	a9 01       	movw	r20, r18
    3b2c:	98 01       	movw	r18, r16
    3b2e:	22 0f       	add	r18, r18
    3b30:	33 1f       	adc	r19, r19
    3b32:	44 1f       	adc	r20, r20
    3b34:	55 1f       	adc	r21, r21
    3b36:	36 d4       	rcall	.+2156   	; 0x43a4 <__udivmodsi4>
    3b38:	21 50       	subi	r18, 0x01	; 1
    3b3a:	31 09       	sbc	r19, r1
    3b3c:	30 93 d5 00 	sts	0x00D5, r19	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    3b40:	20 93 d4 00 	sts	0x00D4, r18	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    3b44:	82 e0       	ldi	r24, 0x02	; 2
    3b46:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3b4a:	88 e9       	ldi	r24, 0x98	; 152
    3b4c:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    3b50:	8e e0       	ldi	r24, 0x0E	; 14
    3b52:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    3b56:	a9 c0       	rjmp	.+338    	; 0x3caa <xSerialPortInitMinimal+0x428>
    3b58:	04 ed       	ldi	r16, 0xD4	; 212
    3b5a:	10 e0       	ldi	r17, 0x00	; 0
    3b5c:	f8 01       	movw	r30, r16
    3b5e:	11 82       	std	Z+1, r1	; 0x01
    3b60:	10 82       	st	Z, r1
    3b62:	e1 e0       	ldi	r30, 0x01	; 1
    3b64:	f1 e0       	ldi	r31, 0x01	; 1
    3b66:	80 81       	ld	r24, Z
    3b68:	84 60       	ori	r24, 0x04	; 4
    3b6a:	80 83       	st	Z, r24
    3b6c:	80 ec       	ldi	r24, 0xC0	; 192
    3b6e:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    3b72:	88 e9       	ldi	r24, 0x98	; 152
    3b74:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    3b78:	d5 01       	movw	r26, r10
    3b7a:	c4 01       	movw	r24, r8
    3b7c:	80 58       	subi	r24, 0x80	; 128
    3b7e:	9b 47       	sbci	r25, 0x7B	; 123
    3b80:	a1 4e       	sbci	r26, 0xE1	; 225
    3b82:	bf 4f       	sbci	r27, 0xFF	; 255
    3b84:	88 0f       	add	r24, r24
    3b86:	99 1f       	adc	r25, r25
    3b88:	aa 1f       	adc	r26, r26
    3b8a:	bb 1f       	adc	r27, r27
    3b8c:	88 0f       	add	r24, r24
    3b8e:	99 1f       	adc	r25, r25
    3b90:	aa 1f       	adc	r26, r26
    3b92:	bb 1f       	adc	r27, r27
    3b94:	bc 01       	movw	r22, r24
    3b96:	cd 01       	movw	r24, r26
    3b98:	66 0f       	add	r22, r22
    3b9a:	77 1f       	adc	r23, r23
    3b9c:	88 1f       	adc	r24, r24
    3b9e:	99 1f       	adc	r25, r25
    3ba0:	88 0c       	add	r8, r8
    3ba2:	99 1c       	adc	r9, r9
    3ba4:	aa 1c       	adc	r10, r10
    3ba6:	bb 1c       	adc	r11, r11
    3ba8:	88 0c       	add	r8, r8
    3baa:	99 1c       	adc	r9, r9
    3bac:	aa 1c       	adc	r10, r10
    3bae:	bb 1c       	adc	r11, r11
    3bb0:	a5 01       	movw	r20, r10
    3bb2:	94 01       	movw	r18, r8
    3bb4:	22 0f       	add	r18, r18
    3bb6:	33 1f       	adc	r19, r19
    3bb8:	44 1f       	adc	r20, r20
    3bba:	55 1f       	adc	r21, r21
    3bbc:	22 0f       	add	r18, r18
    3bbe:	33 1f       	adc	r19, r19
    3bc0:	44 1f       	adc	r20, r20
    3bc2:	55 1f       	adc	r21, r21
    3bc4:	ef d3       	rcall	.+2014   	; 0x43a4 <__udivmodsi4>
    3bc6:	21 50       	subi	r18, 0x01	; 1
    3bc8:	31 09       	sbc	r19, r1
    3bca:	f8 01       	movw	r30, r16
    3bcc:	31 83       	std	Z+1, r19	; 0x01
    3bce:	20 83       	st	Z, r18
    3bd0:	6c c0       	rjmp	.+216    	; 0x3caa <xSerialPortInitMinimal+0x428>
    3bd2:	d5 01       	movw	r26, r10
    3bd4:	c4 01       	movw	r24, r8
    3bd6:	97 5f       	subi	r25, 0xF7	; 247
    3bd8:	a2 4c       	sbci	r26, 0xC2	; 194
    3bda:	bf 4f       	sbci	r27, 0xFF	; 255
    3bdc:	bc 01       	movw	r22, r24
    3bde:	cd 01       	movw	r24, r26
    3be0:	66 0f       	add	r22, r22
    3be2:	77 1f       	adc	r23, r23
    3be4:	88 1f       	adc	r24, r24
    3be6:	99 1f       	adc	r25, r25
    3be8:	66 0f       	add	r22, r22
    3bea:	77 1f       	adc	r23, r23
    3bec:	88 1f       	adc	r24, r24
    3bee:	99 1f       	adc	r25, r25
    3bf0:	95 01       	movw	r18, r10
    3bf2:	84 01       	movw	r16, r8
    3bf4:	00 0f       	add	r16, r16
    3bf6:	11 1f       	adc	r17, r17
    3bf8:	22 1f       	adc	r18, r18
    3bfa:	33 1f       	adc	r19, r19
    3bfc:	00 0f       	add	r16, r16
    3bfe:	11 1f       	adc	r17, r17
    3c00:	22 1f       	adc	r18, r18
    3c02:	33 1f       	adc	r19, r19
    3c04:	a9 01       	movw	r20, r18
    3c06:	98 01       	movw	r18, r16
    3c08:	22 0f       	add	r18, r18
    3c0a:	33 1f       	adc	r19, r19
    3c0c:	44 1f       	adc	r20, r20
    3c0e:	55 1f       	adc	r21, r21
    3c10:	c9 d3       	rcall	.+1938   	; 0x43a4 <__udivmodsi4>
    3c12:	21 50       	subi	r18, 0x01	; 1
    3c14:	31 09       	sbc	r19, r1
    3c16:	30 93 35 01 	sts	0x0135, r19	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    3c1a:	20 93 34 01 	sts	0x0134, r18	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    3c1e:	82 e0       	ldi	r24, 0x02	; 2
    3c20:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    3c24:	88 e9       	ldi	r24, 0x98	; 152
    3c26:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    3c2a:	8e e0       	ldi	r24, 0x0E	; 14
    3c2c:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    3c30:	3c c0       	rjmp	.+120    	; 0x3caa <xSerialPortInitMinimal+0x428>
    3c32:	04 e3       	ldi	r16, 0x34	; 52
    3c34:	11 e0       	ldi	r17, 0x01	; 1
    3c36:	f8 01       	movw	r30, r16
    3c38:	11 82       	std	Z+1, r1	; 0x01
    3c3a:	10 82       	st	Z, r1
    3c3c:	e4 e0       	ldi	r30, 0x04	; 4
    3c3e:	f1 e0       	ldi	r31, 0x01	; 1
    3c40:	80 81       	ld	r24, Z
    3c42:	84 60       	ori	r24, 0x04	; 4
    3c44:	80 83       	st	Z, r24
    3c46:	80 ec       	ldi	r24, 0xC0	; 192
    3c48:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    3c4c:	88 e9       	ldi	r24, 0x98	; 152
    3c4e:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    3c52:	d5 01       	movw	r26, r10
    3c54:	c4 01       	movw	r24, r8
    3c56:	80 58       	subi	r24, 0x80	; 128
    3c58:	9b 47       	sbci	r25, 0x7B	; 123
    3c5a:	a1 4e       	sbci	r26, 0xE1	; 225
    3c5c:	bf 4f       	sbci	r27, 0xFF	; 255
    3c5e:	88 0f       	add	r24, r24
    3c60:	99 1f       	adc	r25, r25
    3c62:	aa 1f       	adc	r26, r26
    3c64:	bb 1f       	adc	r27, r27
    3c66:	88 0f       	add	r24, r24
    3c68:	99 1f       	adc	r25, r25
    3c6a:	aa 1f       	adc	r26, r26
    3c6c:	bb 1f       	adc	r27, r27
    3c6e:	bc 01       	movw	r22, r24
    3c70:	cd 01       	movw	r24, r26
    3c72:	66 0f       	add	r22, r22
    3c74:	77 1f       	adc	r23, r23
    3c76:	88 1f       	adc	r24, r24
    3c78:	99 1f       	adc	r25, r25
    3c7a:	88 0c       	add	r8, r8
    3c7c:	99 1c       	adc	r9, r9
    3c7e:	aa 1c       	adc	r10, r10
    3c80:	bb 1c       	adc	r11, r11
    3c82:	88 0c       	add	r8, r8
    3c84:	99 1c       	adc	r9, r9
    3c86:	aa 1c       	adc	r10, r10
    3c88:	bb 1c       	adc	r11, r11
    3c8a:	a5 01       	movw	r20, r10
    3c8c:	94 01       	movw	r18, r8
    3c8e:	22 0f       	add	r18, r18
    3c90:	33 1f       	adc	r19, r19
    3c92:	44 1f       	adc	r20, r20
    3c94:	55 1f       	adc	r21, r21
    3c96:	22 0f       	add	r18, r18
    3c98:	33 1f       	adc	r19, r19
    3c9a:	44 1f       	adc	r20, r20
    3c9c:	55 1f       	adc	r21, r21
    3c9e:	82 d3       	rcall	.+1796   	; 0x43a4 <__udivmodsi4>
    3ca0:	21 50       	subi	r18, 0x01	; 1
    3ca2:	31 09       	sbc	r19, r1
    3ca4:	f8 01       	movw	r30, r16
    3ca6:	31 83       	std	Z+1, r19	; 0x01
    3ca8:	20 83       	st	Z, r18
    3caa:	0f 90       	pop	r0
    3cac:	0f be       	out	0x3f, r0	; 63
    3cae:	82 e2       	ldi	r24, 0x22	; 34
    3cb0:	fe 01       	movw	r30, r28
    3cb2:	31 96       	adiw	r30, 0x01	; 1
    3cb4:	d6 01       	movw	r26, r12
    3cb6:	01 90       	ld	r0, Z+
    3cb8:	0d 92       	st	X+, r0
    3cba:	8a 95       	dec	r24
    3cbc:	e1 f7       	brne	.-8      	; 0x3cb6 <xSerialPortInitMinimal+0x434>
    3cbe:	c6 01       	movw	r24, r12
    3cc0:	a2 96       	adiw	r28, 0x22	; 34
    3cc2:	0f b6       	in	r0, 0x3f	; 63
    3cc4:	f8 94       	cli
    3cc6:	de bf       	out	0x3e, r29	; 62
    3cc8:	0f be       	out	0x3f, r0	; 63
    3cca:	cd bf       	out	0x3d, r28	; 61
    3ccc:	df 91       	pop	r29
    3cce:	cf 91       	pop	r28
    3cd0:	1f 91       	pop	r17
    3cd2:	0f 91       	pop	r16
    3cd4:	ff 90       	pop	r15
    3cd6:	ef 90       	pop	r14
    3cd8:	df 90       	pop	r13
    3cda:	cf 90       	pop	r12
    3cdc:	bf 90       	pop	r11
    3cde:	af 90       	pop	r10
    3ce0:	9f 90       	pop	r9
    3ce2:	8f 90       	pop	r8
    3ce4:	7f 90       	pop	r7
    3ce6:	08 95       	ret

00003ce8 <__vector_25>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART0_RX_vect )

#endif
{
    3ce8:	1f 92       	push	r1
    3cea:	0f 92       	push	r0
    3cec:	0f b6       	in	r0, 0x3f	; 63
    3cee:	0f 92       	push	r0
    3cf0:	11 24       	eor	r1, r1
    3cf2:	0b b6       	in	r0, 0x3b	; 59
    3cf4:	0f 92       	push	r0
    3cf6:	2f 93       	push	r18
    3cf8:	3f 93       	push	r19
    3cfa:	4f 93       	push	r20
    3cfc:	8f 93       	push	r24
    3cfe:	9f 93       	push	r25
    3d00:	af 93       	push	r26
    3d02:	bf 93       	push	r27
    3d04:	ef 93       	push	r30
    3d06:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) ) )
    3d08:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    3d0c:	8c 71       	andi	r24, 0x1C	; 28
    3d0e:	71 f0       	breq	.+28     	; 0x3d2c <__vector_25+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR0A & (1<<RXC0) ) erroredByte = UDR0;
    3d10:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    3d14:	88 23       	and	r24, r24
    3d16:	0c f0       	brlt	.+2      	; 0x3d1a <__vector_25+0x32>
    3d18:	36 c0       	rjmp	.+108    	; 0x3d86 <__vector_25+0x9e>
    3d1a:	a6 ec       	ldi	r26, 0xC6	; 198
    3d1c:	b0 e0       	ldi	r27, 0x00	; 0
    3d1e:	e0 ec       	ldi	r30, 0xC0	; 192
    3d20:	f0 e0       	ldi	r31, 0x00	; 0
    3d22:	8c 91       	ld	r24, X
    3d24:	80 81       	ld	r24, Z
    3d26:	88 23       	and	r24, r24
    3d28:	e4 f3       	brlt	.-8      	; 0x3d22 <__vector_25+0x3a>
    3d2a:	2d c0       	rjmp	.+90     	; 0x3d86 <__vector_25+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR0;
    3d2c:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3d30:	0f b6       	in	r0, 0x3f	; 63
    3d32:	f8 94       	cli
    3d34:	0f 92       	push	r0
	{
	    count = buffer->count;
    3d36:	e6 e5       	ldi	r30, 0x56	; 86
    3d38:	f6 e1       	ldi	r31, 0x16	; 22
    3d3a:	21 81       	ldd	r18, Z+1	; 0x01
    3d3c:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3d3e:	0f 90       	pop	r0
    3d40:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerialPort.xRxedChars) ) )
    3d42:	83 85       	ldd	r24, Z+11	; 0x0b
    3d44:	94 85       	ldd	r25, Z+12	; 0x0c
    3d46:	28 17       	cp	r18, r24
    3d48:	39 07       	cpc	r19, r25
    3d4a:	e9 f0       	breq	.+58     	; 0x3d86 <__vector_25+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3d4c:	e7 e5       	ldi	r30, 0x57	; 87
    3d4e:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3d50:	a2 81       	ldd	r26, Z+2	; 0x02
    3d52:	b3 81       	ldd	r27, Z+3	; 0x03
    3d54:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3d56:	82 81       	ldd	r24, Z+2	; 0x02
    3d58:	93 81       	ldd	r25, Z+3	; 0x03
    3d5a:	01 96       	adiw	r24, 0x01	; 1
    3d5c:	93 83       	std	Z+3, r25	; 0x03
    3d5e:	82 83       	std	Z+2, r24	; 0x02
    3d60:	20 85       	ldd	r18, Z+8	; 0x08
    3d62:	31 85       	ldd	r19, Z+9	; 0x09
    3d64:	82 17       	cp	r24, r18
    3d66:	93 07       	cpc	r25, r19
    3d68:	21 f4       	brne	.+8      	; 0x3d72 <__vector_25+0x8a>
	  buffer->in = buffer->start;
    3d6a:	86 81       	ldd	r24, Z+6	; 0x06
    3d6c:	97 81       	ldd	r25, Z+7	; 0x07
    3d6e:	93 83       	std	Z+3, r25	; 0x03
    3d70:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3d72:	0f b6       	in	r0, 0x3f	; 63
    3d74:	f8 94       	cli
    3d76:	0f 92       	push	r0
	{
	    buffer->count++;
    3d78:	80 81       	ld	r24, Z
    3d7a:	91 81       	ldd	r25, Z+1	; 0x01
    3d7c:	01 96       	adiw	r24, 0x01	; 1
    3d7e:	91 83       	std	Z+1, r25	; 0x01
    3d80:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3d82:	0f 90       	pop	r0
    3d84:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerialPort.xRxedChars), cChar);
	}
}
    3d86:	ff 91       	pop	r31
    3d88:	ef 91       	pop	r30
    3d8a:	bf 91       	pop	r27
    3d8c:	af 91       	pop	r26
    3d8e:	9f 91       	pop	r25
    3d90:	8f 91       	pop	r24
    3d92:	4f 91       	pop	r20
    3d94:	3f 91       	pop	r19
    3d96:	2f 91       	pop	r18
    3d98:	0f 90       	pop	r0
    3d9a:	0b be       	out	0x3b, r0	; 59
    3d9c:	0f 90       	pop	r0
    3d9e:	0f be       	out	0x3f, r0	; 63
    3da0:	0f 90       	pop	r0
    3da2:	1f 90       	pop	r1
    3da4:	18 95       	reti

00003da6 <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    3da6:	1f 92       	push	r1
    3da8:	0f 92       	push	r0
    3daa:	0f b6       	in	r0, 0x3f	; 63
    3dac:	0f 92       	push	r0
    3dae:	11 24       	eor	r1, r1
    3db0:	0b b6       	in	r0, 0x3b	; 59
    3db2:	0f 92       	push	r0
    3db4:	2f 93       	push	r18
    3db6:	8f 93       	push	r24
    3db8:	9f 93       	push	r25
    3dba:	af 93       	push	r26
    3dbc:	bf 93       	push	r27
    3dbe:	ef 93       	push	r30
    3dc0:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3dc2:	0f b6       	in	r0, 0x3f	; 63
    3dc4:	f8 94       	cli
    3dc6:	0f 92       	push	r0
	{
	    count = buffer->count;
    3dc8:	80 91 63 16 	lds	r24, 0x1663	; 0x801663 <xSerialPort+0xd>
    3dcc:	90 91 64 16 	lds	r25, 0x1664	; 0x801664 <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    3dd0:	0f 90       	pop	r0
    3dd2:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    3dd4:	89 2b       	or	r24, r25
    3dd6:	31 f4       	brne	.+12     	; 0x3de4 <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    3dd8:	e1 ec       	ldi	r30, 0xC1	; 193
    3dda:	f0 e0       	ldi	r31, 0x00	; 0
    3ddc:	80 81       	ld	r24, Z
    3dde:	8f 7d       	andi	r24, 0xDF	; 223
    3de0:	80 83       	st	Z, r24
    3de2:	1c c0       	rjmp	.+56     	; 0x3e1c <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3de4:	e3 e6       	ldi	r30, 0x63	; 99
    3de6:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    3de8:	a4 81       	ldd	r26, Z+4	; 0x04
    3dea:	b5 81       	ldd	r27, Z+5	; 0x05
    3dec:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3dee:	b5 83       	std	Z+5, r27	; 0x05
    3df0:	a4 83       	std	Z+4, r26	; 0x04
    3df2:	80 85       	ldd	r24, Z+8	; 0x08
    3df4:	91 85       	ldd	r25, Z+9	; 0x09
    3df6:	a8 17       	cp	r26, r24
    3df8:	b9 07       	cpc	r27, r25
    3dfa:	21 f4       	brne	.+8      	; 0x3e04 <__vector_26+0x5e>
	  buffer->out = buffer->start;
    3dfc:	86 81       	ldd	r24, Z+6	; 0x06
    3dfe:	97 81       	ldd	r25, Z+7	; 0x07
    3e00:	95 83       	std	Z+5, r25	; 0x05
    3e02:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3e04:	0f b6       	in	r0, 0x3f	; 63
    3e06:	f8 94       	cli
    3e08:	0f 92       	push	r0
	{
	    buffer->count--;
    3e0a:	80 81       	ld	r24, Z
    3e0c:	91 81       	ldd	r25, Z+1	; 0x01
    3e0e:	01 97       	sbiw	r24, 0x01	; 1
    3e10:	91 83       	std	Z+1, r25	; 0x01
    3e12:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3e14:	0f 90       	pop	r0
    3e16:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    3e18:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    3e1c:	ff 91       	pop	r31
    3e1e:	ef 91       	pop	r30
    3e20:	bf 91       	pop	r27
    3e22:	af 91       	pop	r26
    3e24:	9f 91       	pop	r25
    3e26:	8f 91       	pop	r24
    3e28:	2f 91       	pop	r18
    3e2a:	0f 90       	pop	r0
    3e2c:	0b be       	out	0x3b, r0	; 59
    3e2e:	0f 90       	pop	r0
    3e30:	0f be       	out	0x3f, r0	; 63
    3e32:	0f 90       	pop	r0
    3e34:	1f 90       	pop	r1
    3e36:	18 95       	reti

00003e38 <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
    3e38:	1f 92       	push	r1
    3e3a:	0f 92       	push	r0
    3e3c:	0f b6       	in	r0, 0x3f	; 63
    3e3e:	0f 92       	push	r0
    3e40:	11 24       	eor	r1, r1
    3e42:	0b b6       	in	r0, 0x3b	; 59
    3e44:	0f 92       	push	r0
    3e46:	2f 93       	push	r18
    3e48:	3f 93       	push	r19
    3e4a:	4f 93       	push	r20
    3e4c:	8f 93       	push	r24
    3e4e:	9f 93       	push	r25
    3e50:	af 93       	push	r26
    3e52:	bf 93       	push	r27
    3e54:	ef 93       	push	r30
    3e56:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
    3e58:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    3e5c:	8c 71       	andi	r24, 0x1C	; 28
    3e5e:	71 f0       	breq	.+28     	; 0x3e7c <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
    3e60:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    3e64:	88 23       	and	r24, r24
    3e66:	0c f0       	brlt	.+2      	; 0x3e6a <__vector_36+0x32>
    3e68:	36 c0       	rjmp	.+108    	; 0x3ed6 <__vector_36+0x9e>
    3e6a:	ae ec       	ldi	r26, 0xCE	; 206
    3e6c:	b0 e0       	ldi	r27, 0x00	; 0
    3e6e:	e8 ec       	ldi	r30, 0xC8	; 200
    3e70:	f0 e0       	ldi	r31, 0x00	; 0
    3e72:	8c 91       	ld	r24, X
    3e74:	80 81       	ld	r24, Z
    3e76:	88 23       	and	r24, r24
    3e78:	e4 f3       	brlt	.-8      	; 0x3e72 <__vector_36+0x3a>
    3e7a:	2d c0       	rjmp	.+90     	; 0x3ed6 <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
    3e7c:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3e80:	0f b6       	in	r0, 0x3f	; 63
    3e82:	f8 94       	cli
    3e84:	0f 92       	push	r0
	{
	    count = buffer->count;
    3e86:	e0 e0       	ldi	r30, 0x00	; 0
    3e88:	f7 e1       	ldi	r31, 0x17	; 23
    3e8a:	21 81       	ldd	r18, Z+1	; 0x01
    3e8c:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3e8e:	0f 90       	pop	r0
    3e90:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
    3e92:	83 85       	ldd	r24, Z+11	; 0x0b
    3e94:	94 85       	ldd	r25, Z+12	; 0x0c
    3e96:	28 17       	cp	r18, r24
    3e98:	39 07       	cpc	r19, r25
    3e9a:	e9 f0       	breq	.+58     	; 0x3ed6 <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3e9c:	e1 e0       	ldi	r30, 0x01	; 1
    3e9e:	f7 e1       	ldi	r31, 0x17	; 23

	*buffer->in = data;
    3ea0:	a2 81       	ldd	r26, Z+2	; 0x02
    3ea2:	b3 81       	ldd	r27, Z+3	; 0x03
    3ea4:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3ea6:	82 81       	ldd	r24, Z+2	; 0x02
    3ea8:	93 81       	ldd	r25, Z+3	; 0x03
    3eaa:	01 96       	adiw	r24, 0x01	; 1
    3eac:	93 83       	std	Z+3, r25	; 0x03
    3eae:	82 83       	std	Z+2, r24	; 0x02
    3eb0:	20 85       	ldd	r18, Z+8	; 0x08
    3eb2:	31 85       	ldd	r19, Z+9	; 0x09
    3eb4:	82 17       	cp	r24, r18
    3eb6:	93 07       	cpc	r25, r19
    3eb8:	21 f4       	brne	.+8      	; 0x3ec2 <__vector_36+0x8a>
	  buffer->in = buffer->start;
    3eba:	86 81       	ldd	r24, Z+6	; 0x06
    3ebc:	97 81       	ldd	r25, Z+7	; 0x07
    3ebe:	93 83       	std	Z+3, r25	; 0x03
    3ec0:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3ec2:	0f b6       	in	r0, 0x3f	; 63
    3ec4:	f8 94       	cli
    3ec6:	0f 92       	push	r0
	{
	    buffer->count++;
    3ec8:	80 81       	ld	r24, Z
    3eca:	91 81       	ldd	r25, Z+1	; 0x01
    3ecc:	01 96       	adiw	r24, 0x01	; 1
    3ece:	91 83       	std	Z+1, r25	; 0x01
    3ed0:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3ed2:	0f 90       	pop	r0
    3ed4:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    3ed6:	ff 91       	pop	r31
    3ed8:	ef 91       	pop	r30
    3eda:	bf 91       	pop	r27
    3edc:	af 91       	pop	r26
    3ede:	9f 91       	pop	r25
    3ee0:	8f 91       	pop	r24
    3ee2:	4f 91       	pop	r20
    3ee4:	3f 91       	pop	r19
    3ee6:	2f 91       	pop	r18
    3ee8:	0f 90       	pop	r0
    3eea:	0b be       	out	0x3b, r0	; 59
    3eec:	0f 90       	pop	r0
    3eee:	0f be       	out	0x3f, r0	; 63
    3ef0:	0f 90       	pop	r0
    3ef2:	1f 90       	pop	r1
    3ef4:	18 95       	reti

00003ef6 <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    3ef6:	1f 92       	push	r1
    3ef8:	0f 92       	push	r0
    3efa:	0f b6       	in	r0, 0x3f	; 63
    3efc:	0f 92       	push	r0
    3efe:	11 24       	eor	r1, r1
    3f00:	0b b6       	in	r0, 0x3b	; 59
    3f02:	0f 92       	push	r0
    3f04:	2f 93       	push	r18
    3f06:	8f 93       	push	r24
    3f08:	9f 93       	push	r25
    3f0a:	af 93       	push	r26
    3f0c:	bf 93       	push	r27
    3f0e:	ef 93       	push	r30
    3f10:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3f12:	0f b6       	in	r0, 0x3f	; 63
    3f14:	f8 94       	cli
    3f16:	0f 92       	push	r0
	{
	    count = buffer->count;
    3f18:	80 91 0d 17 	lds	r24, 0x170D	; 0x80170d <xSerial1Port+0xd>
    3f1c:	90 91 0e 17 	lds	r25, 0x170E	; 0x80170e <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    3f20:	0f 90       	pop	r0
    3f22:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    3f24:	89 2b       	or	r24, r25
    3f26:	31 f4       	brne	.+12     	; 0x3f34 <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    3f28:	e9 ec       	ldi	r30, 0xC9	; 201
    3f2a:	f0 e0       	ldi	r31, 0x00	; 0
    3f2c:	80 81       	ld	r24, Z
    3f2e:	8f 7d       	andi	r24, 0xDF	; 223
    3f30:	80 83       	st	Z, r24
    3f32:	1c c0       	rjmp	.+56     	; 0x3f6c <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3f34:	ed e0       	ldi	r30, 0x0D	; 13
    3f36:	f7 e1       	ldi	r31, 0x17	; 23

	uint8_t data = *buffer->out;
    3f38:	a4 81       	ldd	r26, Z+4	; 0x04
    3f3a:	b5 81       	ldd	r27, Z+5	; 0x05
    3f3c:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3f3e:	b5 83       	std	Z+5, r27	; 0x05
    3f40:	a4 83       	std	Z+4, r26	; 0x04
    3f42:	80 85       	ldd	r24, Z+8	; 0x08
    3f44:	91 85       	ldd	r25, Z+9	; 0x09
    3f46:	a8 17       	cp	r26, r24
    3f48:	b9 07       	cpc	r27, r25
    3f4a:	21 f4       	brne	.+8      	; 0x3f54 <__vector_37+0x5e>
	  buffer->out = buffer->start;
    3f4c:	86 81       	ldd	r24, Z+6	; 0x06
    3f4e:	97 81       	ldd	r25, Z+7	; 0x07
    3f50:	95 83       	std	Z+5, r25	; 0x05
    3f52:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3f54:	0f b6       	in	r0, 0x3f	; 63
    3f56:	f8 94       	cli
    3f58:	0f 92       	push	r0
	{
	    buffer->count--;
    3f5a:	80 81       	ld	r24, Z
    3f5c:	91 81       	ldd	r25, Z+1	; 0x01
    3f5e:	01 97       	sbiw	r24, 0x01	; 1
    3f60:	91 83       	std	Z+1, r25	; 0x01
    3f62:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3f64:	0f 90       	pop	r0
    3f66:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    3f68:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    3f6c:	ff 91       	pop	r31
    3f6e:	ef 91       	pop	r30
    3f70:	bf 91       	pop	r27
    3f72:	af 91       	pop	r26
    3f74:	9f 91       	pop	r25
    3f76:	8f 91       	pop	r24
    3f78:	2f 91       	pop	r18
    3f7a:	0f 90       	pop	r0
    3f7c:	0b be       	out	0x3b, r0	; 59
    3f7e:	0f 90       	pop	r0
    3f80:	0f be       	out	0x3f, r0	; 63
    3f82:	0f 90       	pop	r0
    3f84:	1f 90       	pop	r1
    3f86:	18 95       	reti

00003f88 <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    3f88:	1f 92       	push	r1
    3f8a:	0f 92       	push	r0
    3f8c:	0f b6       	in	r0, 0x3f	; 63
    3f8e:	0f 92       	push	r0
    3f90:	11 24       	eor	r1, r1
    3f92:	0b b6       	in	r0, 0x3b	; 59
    3f94:	0f 92       	push	r0
    3f96:	2f 93       	push	r18
    3f98:	3f 93       	push	r19
    3f9a:	4f 93       	push	r20
    3f9c:	8f 93       	push	r24
    3f9e:	9f 93       	push	r25
    3fa0:	af 93       	push	r26
    3fa2:	bf 93       	push	r27
    3fa4:	ef 93       	push	r30
    3fa6:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    3fa8:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3fac:	8c 71       	andi	r24, 0x1C	; 28
    3fae:	71 f0       	breq	.+28     	; 0x3fcc <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    3fb0:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3fb4:	88 23       	and	r24, r24
    3fb6:	0c f0       	brlt	.+2      	; 0x3fba <__vector_51+0x32>
    3fb8:	36 c0       	rjmp	.+108    	; 0x4026 <__vector_51+0x9e>
    3fba:	a6 ed       	ldi	r26, 0xD6	; 214
    3fbc:	b0 e0       	ldi	r27, 0x00	; 0
    3fbe:	e0 ed       	ldi	r30, 0xD0	; 208
    3fc0:	f0 e0       	ldi	r31, 0x00	; 0
    3fc2:	8c 91       	ld	r24, X
    3fc4:	80 81       	ld	r24, Z
    3fc6:	88 23       	and	r24, r24
    3fc8:	e4 f3       	brlt	.-8      	; 0x3fc2 <__vector_51+0x3a>
    3fca:	2d c0       	rjmp	.+90     	; 0x4026 <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    3fcc:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3fd0:	0f b6       	in	r0, 0x3f	; 63
    3fd2:	f8 94       	cli
    3fd4:	0f 92       	push	r0
	{
	    count = buffer->count;
    3fd6:	ec eb       	ldi	r30, 0xBC	; 188
    3fd8:	f6 e1       	ldi	r31, 0x16	; 22
    3fda:	21 81       	ldd	r18, Z+1	; 0x01
    3fdc:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3fde:	0f 90       	pop	r0
    3fe0:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    3fe2:	83 85       	ldd	r24, Z+11	; 0x0b
    3fe4:	94 85       	ldd	r25, Z+12	; 0x0c
    3fe6:	28 17       	cp	r18, r24
    3fe8:	39 07       	cpc	r19, r25
    3fea:	e9 f0       	breq	.+58     	; 0x4026 <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3fec:	ed eb       	ldi	r30, 0xBD	; 189
    3fee:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3ff0:	a2 81       	ldd	r26, Z+2	; 0x02
    3ff2:	b3 81       	ldd	r27, Z+3	; 0x03
    3ff4:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3ff6:	82 81       	ldd	r24, Z+2	; 0x02
    3ff8:	93 81       	ldd	r25, Z+3	; 0x03
    3ffa:	01 96       	adiw	r24, 0x01	; 1
    3ffc:	93 83       	std	Z+3, r25	; 0x03
    3ffe:	82 83       	std	Z+2, r24	; 0x02
    4000:	20 85       	ldd	r18, Z+8	; 0x08
    4002:	31 85       	ldd	r19, Z+9	; 0x09
    4004:	82 17       	cp	r24, r18
    4006:	93 07       	cpc	r25, r19
    4008:	21 f4       	brne	.+8      	; 0x4012 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    400a:	86 81       	ldd	r24, Z+6	; 0x06
    400c:	97 81       	ldd	r25, Z+7	; 0x07
    400e:	93 83       	std	Z+3, r25	; 0x03
    4010:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    4012:	0f b6       	in	r0, 0x3f	; 63
    4014:	f8 94       	cli
    4016:	0f 92       	push	r0
	{
	    buffer->count++;
    4018:	80 81       	ld	r24, Z
    401a:	91 81       	ldd	r25, Z+1	; 0x01
    401c:	01 96       	adiw	r24, 0x01	; 1
    401e:	91 83       	std	Z+1, r25	; 0x01
    4020:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    4022:	0f 90       	pop	r0
    4024:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    4026:	ff 91       	pop	r31
    4028:	ef 91       	pop	r30
    402a:	bf 91       	pop	r27
    402c:	af 91       	pop	r26
    402e:	9f 91       	pop	r25
    4030:	8f 91       	pop	r24
    4032:	4f 91       	pop	r20
    4034:	3f 91       	pop	r19
    4036:	2f 91       	pop	r18
    4038:	0f 90       	pop	r0
    403a:	0b be       	out	0x3b, r0	; 59
    403c:	0f 90       	pop	r0
    403e:	0f be       	out	0x3f, r0	; 63
    4040:	0f 90       	pop	r0
    4042:	1f 90       	pop	r1
    4044:	18 95       	reti

00004046 <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    4046:	1f 92       	push	r1
    4048:	0f 92       	push	r0
    404a:	0f b6       	in	r0, 0x3f	; 63
    404c:	0f 92       	push	r0
    404e:	11 24       	eor	r1, r1
    4050:	0b b6       	in	r0, 0x3b	; 59
    4052:	0f 92       	push	r0
    4054:	2f 93       	push	r18
    4056:	8f 93       	push	r24
    4058:	9f 93       	push	r25
    405a:	af 93       	push	r26
    405c:	bf 93       	push	r27
    405e:	ef 93       	push	r30
    4060:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    4062:	0f b6       	in	r0, 0x3f	; 63
    4064:	f8 94       	cli
    4066:	0f 92       	push	r0
	{
	    count = buffer->count;
    4068:	80 91 c9 16 	lds	r24, 0x16C9	; 0x8016c9 <xSerial2Port+0xd>
    406c:	90 91 ca 16 	lds	r25, 0x16CA	; 0x8016ca <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    4070:	0f 90       	pop	r0
    4072:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    4074:	89 2b       	or	r24, r25
    4076:	31 f4       	brne	.+12     	; 0x4084 <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    4078:	e1 ed       	ldi	r30, 0xD1	; 209
    407a:	f0 e0       	ldi	r31, 0x00	; 0
    407c:	80 81       	ld	r24, Z
    407e:	8f 7d       	andi	r24, 0xDF	; 223
    4080:	80 83       	st	Z, r24
    4082:	1c c0       	rjmp	.+56     	; 0x40bc <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    4084:	e9 ec       	ldi	r30, 0xC9	; 201
    4086:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    4088:	a4 81       	ldd	r26, Z+4	; 0x04
    408a:	b5 81       	ldd	r27, Z+5	; 0x05
    408c:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    408e:	b5 83       	std	Z+5, r27	; 0x05
    4090:	a4 83       	std	Z+4, r26	; 0x04
    4092:	80 85       	ldd	r24, Z+8	; 0x08
    4094:	91 85       	ldd	r25, Z+9	; 0x09
    4096:	a8 17       	cp	r26, r24
    4098:	b9 07       	cpc	r27, r25
    409a:	21 f4       	brne	.+8      	; 0x40a4 <__vector_52+0x5e>
	  buffer->out = buffer->start;
    409c:	86 81       	ldd	r24, Z+6	; 0x06
    409e:	97 81       	ldd	r25, Z+7	; 0x07
    40a0:	95 83       	std	Z+5, r25	; 0x05
    40a2:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    40a4:	0f b6       	in	r0, 0x3f	; 63
    40a6:	f8 94       	cli
    40a8:	0f 92       	push	r0
	{
	    buffer->count--;
    40aa:	80 81       	ld	r24, Z
    40ac:	91 81       	ldd	r25, Z+1	; 0x01
    40ae:	01 97       	sbiw	r24, 0x01	; 1
    40b0:	91 83       	std	Z+1, r25	; 0x01
    40b2:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    40b4:	0f 90       	pop	r0
    40b6:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    40b8:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    40bc:	ff 91       	pop	r31
    40be:	ef 91       	pop	r30
    40c0:	bf 91       	pop	r27
    40c2:	af 91       	pop	r26
    40c4:	9f 91       	pop	r25
    40c6:	8f 91       	pop	r24
    40c8:	2f 91       	pop	r18
    40ca:	0f 90       	pop	r0
    40cc:	0b be       	out	0x3b, r0	; 59
    40ce:	0f 90       	pop	r0
    40d0:	0f be       	out	0x3f, r0	; 63
    40d2:	0f 90       	pop	r0
    40d4:	1f 90       	pop	r1
    40d6:	18 95       	reti

000040d8 <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    40d8:	1f 92       	push	r1
    40da:	0f 92       	push	r0
    40dc:	0f b6       	in	r0, 0x3f	; 63
    40de:	0f 92       	push	r0
    40e0:	11 24       	eor	r1, r1
    40e2:	0b b6       	in	r0, 0x3b	; 59
    40e4:	0f 92       	push	r0
    40e6:	2f 93       	push	r18
    40e8:	3f 93       	push	r19
    40ea:	4f 93       	push	r20
    40ec:	8f 93       	push	r24
    40ee:	9f 93       	push	r25
    40f0:	af 93       	push	r26
    40f2:	bf 93       	push	r27
    40f4:	ef 93       	push	r30
    40f6:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    40f8:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    40fc:	8c 71       	andi	r24, 0x1C	; 28
    40fe:	71 f0       	breq	.+28     	; 0x411c <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    4100:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    4104:	88 23       	and	r24, r24
    4106:	0c f0       	brlt	.+2      	; 0x410a <__vector_54+0x32>
    4108:	36 c0       	rjmp	.+108    	; 0x4176 <__vector_54+0x9e>
    410a:	a6 e3       	ldi	r26, 0x36	; 54
    410c:	b1 e0       	ldi	r27, 0x01	; 1
    410e:	e0 e3       	ldi	r30, 0x30	; 48
    4110:	f1 e0       	ldi	r31, 0x01	; 1
    4112:	8c 91       	ld	r24, X
    4114:	80 81       	ld	r24, Z
    4116:	88 23       	and	r24, r24
    4118:	e4 f3       	brlt	.-8      	; 0x4112 <__vector_54+0x3a>
    411a:	2d c0       	rjmp	.+90     	; 0x4176 <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    411c:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    4120:	0f b6       	in	r0, 0x3f	; 63
    4122:	f8 94       	cli
    4124:	0f 92       	push	r0
	{
	    count = buffer->count;
    4126:	ee ed       	ldi	r30, 0xDE	; 222
    4128:	f6 e1       	ldi	r31, 0x16	; 22
    412a:	21 81       	ldd	r18, Z+1	; 0x01
    412c:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    412e:	0f 90       	pop	r0
    4130:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    4132:	83 85       	ldd	r24, Z+11	; 0x0b
    4134:	94 85       	ldd	r25, Z+12	; 0x0c
    4136:	28 17       	cp	r18, r24
    4138:	39 07       	cpc	r19, r25
    413a:	e9 f0       	breq	.+58     	; 0x4176 <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    413c:	ef ed       	ldi	r30, 0xDF	; 223
    413e:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    4140:	a2 81       	ldd	r26, Z+2	; 0x02
    4142:	b3 81       	ldd	r27, Z+3	; 0x03
    4144:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    4146:	82 81       	ldd	r24, Z+2	; 0x02
    4148:	93 81       	ldd	r25, Z+3	; 0x03
    414a:	01 96       	adiw	r24, 0x01	; 1
    414c:	93 83       	std	Z+3, r25	; 0x03
    414e:	82 83       	std	Z+2, r24	; 0x02
    4150:	20 85       	ldd	r18, Z+8	; 0x08
    4152:	31 85       	ldd	r19, Z+9	; 0x09
    4154:	82 17       	cp	r24, r18
    4156:	93 07       	cpc	r25, r19
    4158:	21 f4       	brne	.+8      	; 0x4162 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    415a:	86 81       	ldd	r24, Z+6	; 0x06
    415c:	97 81       	ldd	r25, Z+7	; 0x07
    415e:	93 83       	std	Z+3, r25	; 0x03
    4160:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    4162:	0f b6       	in	r0, 0x3f	; 63
    4164:	f8 94       	cli
    4166:	0f 92       	push	r0
	{
	    buffer->count++;
    4168:	80 81       	ld	r24, Z
    416a:	91 81       	ldd	r25, Z+1	; 0x01
    416c:	01 96       	adiw	r24, 0x01	; 1
    416e:	91 83       	std	Z+1, r25	; 0x01
    4170:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    4172:	0f 90       	pop	r0
    4174:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    4176:	ff 91       	pop	r31
    4178:	ef 91       	pop	r30
    417a:	bf 91       	pop	r27
    417c:	af 91       	pop	r26
    417e:	9f 91       	pop	r25
    4180:	8f 91       	pop	r24
    4182:	4f 91       	pop	r20
    4184:	3f 91       	pop	r19
    4186:	2f 91       	pop	r18
    4188:	0f 90       	pop	r0
    418a:	0b be       	out	0x3b, r0	; 59
    418c:	0f 90       	pop	r0
    418e:	0f be       	out	0x3f, r0	; 63
    4190:	0f 90       	pop	r0
    4192:	1f 90       	pop	r1
    4194:	18 95       	reti

00004196 <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    4196:	1f 92       	push	r1
    4198:	0f 92       	push	r0
    419a:	0f b6       	in	r0, 0x3f	; 63
    419c:	0f 92       	push	r0
    419e:	11 24       	eor	r1, r1
    41a0:	0b b6       	in	r0, 0x3b	; 59
    41a2:	0f 92       	push	r0
    41a4:	2f 93       	push	r18
    41a6:	8f 93       	push	r24
    41a8:	9f 93       	push	r25
    41aa:	af 93       	push	r26
    41ac:	bf 93       	push	r27
    41ae:	ef 93       	push	r30
    41b0:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    41b2:	0f b6       	in	r0, 0x3f	; 63
    41b4:	f8 94       	cli
    41b6:	0f 92       	push	r0
	{
	    count = buffer->count;
    41b8:	80 91 eb 16 	lds	r24, 0x16EB	; 0x8016eb <xSerial3Port+0xd>
    41bc:	90 91 ec 16 	lds	r25, 0x16EC	; 0x8016ec <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    41c0:	0f 90       	pop	r0
    41c2:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    41c4:	89 2b       	or	r24, r25
    41c6:	31 f4       	brne	.+12     	; 0x41d4 <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    41c8:	e1 e3       	ldi	r30, 0x31	; 49
    41ca:	f1 e0       	ldi	r31, 0x01	; 1
    41cc:	80 81       	ld	r24, Z
    41ce:	8f 7d       	andi	r24, 0xDF	; 223
    41d0:	80 83       	st	Z, r24
    41d2:	1c c0       	rjmp	.+56     	; 0x420c <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    41d4:	eb ee       	ldi	r30, 0xEB	; 235
    41d6:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    41d8:	a4 81       	ldd	r26, Z+4	; 0x04
    41da:	b5 81       	ldd	r27, Z+5	; 0x05
    41dc:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    41de:	b5 83       	std	Z+5, r27	; 0x05
    41e0:	a4 83       	std	Z+4, r26	; 0x04
    41e2:	80 85       	ldd	r24, Z+8	; 0x08
    41e4:	91 85       	ldd	r25, Z+9	; 0x09
    41e6:	a8 17       	cp	r26, r24
    41e8:	b9 07       	cpc	r27, r25
    41ea:	21 f4       	brne	.+8      	; 0x41f4 <__vector_55+0x5e>
	  buffer->out = buffer->start;
    41ec:	86 81       	ldd	r24, Z+6	; 0x06
    41ee:	97 81       	ldd	r25, Z+7	; 0x07
    41f0:	95 83       	std	Z+5, r25	; 0x05
    41f2:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    41f4:	0f b6       	in	r0, 0x3f	; 63
    41f6:	f8 94       	cli
    41f8:	0f 92       	push	r0
	{
	    buffer->count--;
    41fa:	80 81       	ld	r24, Z
    41fc:	91 81       	ldd	r25, Z+1	; 0x01
    41fe:	01 97       	sbiw	r24, 0x01	; 1
    4200:	91 83       	std	Z+1, r25	; 0x01
    4202:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    4204:	0f 90       	pop	r0
    4206:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    4208:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    420c:	ff 91       	pop	r31
    420e:	ef 91       	pop	r30
    4210:	bf 91       	pop	r27
    4212:	af 91       	pop	r26
    4214:	9f 91       	pop	r25
    4216:	8f 91       	pop	r24
    4218:	2f 91       	pop	r18
    421a:	0f 90       	pop	r0
    421c:	0b be       	out	0x3b, r0	; 59
    421e:	0f 90       	pop	r0
    4220:	0f be       	out	0x3f, r0	; 63
    4222:	0f 90       	pop	r0
    4224:	1f 90       	pop	r1
    4226:	18 95       	reti

00004228 <__fixsfsi>:
    4228:	04 d0       	rcall	.+8      	; 0x4232 <__fixunssfsi>
    422a:	68 94       	set
    422c:	b1 11       	cpse	r27, r1
    422e:	8d c0       	rjmp	.+282    	; 0x434a <__fp_szero>
    4230:	08 95       	ret

00004232 <__fixunssfsi>:
    4232:	70 d0       	rcall	.+224    	; 0x4314 <__fp_splitA>
    4234:	88 f0       	brcs	.+34     	; 0x4258 <__fixunssfsi+0x26>
    4236:	9f 57       	subi	r25, 0x7F	; 127
    4238:	90 f0       	brcs	.+36     	; 0x425e <__fixunssfsi+0x2c>
    423a:	b9 2f       	mov	r27, r25
    423c:	99 27       	eor	r25, r25
    423e:	b7 51       	subi	r27, 0x17	; 23
    4240:	a0 f0       	brcs	.+40     	; 0x426a <__fixunssfsi+0x38>
    4242:	d1 f0       	breq	.+52     	; 0x4278 <__fixunssfsi+0x46>
    4244:	66 0f       	add	r22, r22
    4246:	77 1f       	adc	r23, r23
    4248:	88 1f       	adc	r24, r24
    424a:	99 1f       	adc	r25, r25
    424c:	1a f0       	brmi	.+6      	; 0x4254 <__fixunssfsi+0x22>
    424e:	ba 95       	dec	r27
    4250:	c9 f7       	brne	.-14     	; 0x4244 <__fixunssfsi+0x12>
    4252:	12 c0       	rjmp	.+36     	; 0x4278 <__fixunssfsi+0x46>
    4254:	b1 30       	cpi	r27, 0x01	; 1
    4256:	81 f0       	breq	.+32     	; 0x4278 <__fixunssfsi+0x46>
    4258:	77 d0       	rcall	.+238    	; 0x4348 <__fp_zero>
    425a:	b1 e0       	ldi	r27, 0x01	; 1
    425c:	08 95       	ret
    425e:	74 c0       	rjmp	.+232    	; 0x4348 <__fp_zero>
    4260:	67 2f       	mov	r22, r23
    4262:	78 2f       	mov	r23, r24
    4264:	88 27       	eor	r24, r24
    4266:	b8 5f       	subi	r27, 0xF8	; 248
    4268:	39 f0       	breq	.+14     	; 0x4278 <__fixunssfsi+0x46>
    426a:	b9 3f       	cpi	r27, 0xF9	; 249
    426c:	cc f3       	brlt	.-14     	; 0x4260 <__fixunssfsi+0x2e>
    426e:	86 95       	lsr	r24
    4270:	77 95       	ror	r23
    4272:	67 95       	ror	r22
    4274:	b3 95       	inc	r27
    4276:	d9 f7       	brne	.-10     	; 0x426e <__fixunssfsi+0x3c>
    4278:	3e f4       	brtc	.+14     	; 0x4288 <__fixunssfsi+0x56>
    427a:	90 95       	com	r25
    427c:	80 95       	com	r24
    427e:	70 95       	com	r23
    4280:	61 95       	neg	r22
    4282:	7f 4f       	sbci	r23, 0xFF	; 255
    4284:	8f 4f       	sbci	r24, 0xFF	; 255
    4286:	9f 4f       	sbci	r25, 0xFF	; 255
    4288:	08 95       	ret

0000428a <__floatunsisf>:
    428a:	e8 94       	clt
    428c:	09 c0       	rjmp	.+18     	; 0x42a0 <__floatsisf+0x12>

0000428e <__floatsisf>:
    428e:	97 fb       	bst	r25, 7
    4290:	3e f4       	brtc	.+14     	; 0x42a0 <__floatsisf+0x12>
    4292:	90 95       	com	r25
    4294:	80 95       	com	r24
    4296:	70 95       	com	r23
    4298:	61 95       	neg	r22
    429a:	7f 4f       	sbci	r23, 0xFF	; 255
    429c:	8f 4f       	sbci	r24, 0xFF	; 255
    429e:	9f 4f       	sbci	r25, 0xFF	; 255
    42a0:	99 23       	and	r25, r25
    42a2:	a9 f0       	breq	.+42     	; 0x42ce <__floatsisf+0x40>
    42a4:	f9 2f       	mov	r31, r25
    42a6:	96 e9       	ldi	r25, 0x96	; 150
    42a8:	bb 27       	eor	r27, r27
    42aa:	93 95       	inc	r25
    42ac:	f6 95       	lsr	r31
    42ae:	87 95       	ror	r24
    42b0:	77 95       	ror	r23
    42b2:	67 95       	ror	r22
    42b4:	b7 95       	ror	r27
    42b6:	f1 11       	cpse	r31, r1
    42b8:	f8 cf       	rjmp	.-16     	; 0x42aa <__floatsisf+0x1c>
    42ba:	fa f4       	brpl	.+62     	; 0x42fa <__floatsisf+0x6c>
    42bc:	bb 0f       	add	r27, r27
    42be:	11 f4       	brne	.+4      	; 0x42c4 <__floatsisf+0x36>
    42c0:	60 ff       	sbrs	r22, 0
    42c2:	1b c0       	rjmp	.+54     	; 0x42fa <__floatsisf+0x6c>
    42c4:	6f 5f       	subi	r22, 0xFF	; 255
    42c6:	7f 4f       	sbci	r23, 0xFF	; 255
    42c8:	8f 4f       	sbci	r24, 0xFF	; 255
    42ca:	9f 4f       	sbci	r25, 0xFF	; 255
    42cc:	16 c0       	rjmp	.+44     	; 0x42fa <__floatsisf+0x6c>
    42ce:	88 23       	and	r24, r24
    42d0:	11 f0       	breq	.+4      	; 0x42d6 <__floatsisf+0x48>
    42d2:	96 e9       	ldi	r25, 0x96	; 150
    42d4:	11 c0       	rjmp	.+34     	; 0x42f8 <__floatsisf+0x6a>
    42d6:	77 23       	and	r23, r23
    42d8:	21 f0       	breq	.+8      	; 0x42e2 <__floatsisf+0x54>
    42da:	9e e8       	ldi	r25, 0x8E	; 142
    42dc:	87 2f       	mov	r24, r23
    42de:	76 2f       	mov	r23, r22
    42e0:	05 c0       	rjmp	.+10     	; 0x42ec <__floatsisf+0x5e>
    42e2:	66 23       	and	r22, r22
    42e4:	71 f0       	breq	.+28     	; 0x4302 <__floatsisf+0x74>
    42e6:	96 e8       	ldi	r25, 0x86	; 134
    42e8:	86 2f       	mov	r24, r22
    42ea:	70 e0       	ldi	r23, 0x00	; 0
    42ec:	60 e0       	ldi	r22, 0x00	; 0
    42ee:	2a f0       	brmi	.+10     	; 0x42fa <__floatsisf+0x6c>
    42f0:	9a 95       	dec	r25
    42f2:	66 0f       	add	r22, r22
    42f4:	77 1f       	adc	r23, r23
    42f6:	88 1f       	adc	r24, r24
    42f8:	da f7       	brpl	.-10     	; 0x42f0 <__floatsisf+0x62>
    42fa:	88 0f       	add	r24, r24
    42fc:	96 95       	lsr	r25
    42fe:	87 95       	ror	r24
    4300:	97 f9       	bld	r25, 7
    4302:	08 95       	ret

00004304 <__fp_split3>:
    4304:	57 fd       	sbrc	r21, 7
    4306:	90 58       	subi	r25, 0x80	; 128
    4308:	44 0f       	add	r20, r20
    430a:	55 1f       	adc	r21, r21
    430c:	59 f0       	breq	.+22     	; 0x4324 <__fp_splitA+0x10>
    430e:	5f 3f       	cpi	r21, 0xFF	; 255
    4310:	71 f0       	breq	.+28     	; 0x432e <__fp_splitA+0x1a>
    4312:	47 95       	ror	r20

00004314 <__fp_splitA>:
    4314:	88 0f       	add	r24, r24
    4316:	97 fb       	bst	r25, 7
    4318:	99 1f       	adc	r25, r25
    431a:	61 f0       	breq	.+24     	; 0x4334 <__fp_splitA+0x20>
    431c:	9f 3f       	cpi	r25, 0xFF	; 255
    431e:	79 f0       	breq	.+30     	; 0x433e <__fp_splitA+0x2a>
    4320:	87 95       	ror	r24
    4322:	08 95       	ret
    4324:	12 16       	cp	r1, r18
    4326:	13 06       	cpc	r1, r19
    4328:	14 06       	cpc	r1, r20
    432a:	55 1f       	adc	r21, r21
    432c:	f2 cf       	rjmp	.-28     	; 0x4312 <__fp_split3+0xe>
    432e:	46 95       	lsr	r20
    4330:	f1 df       	rcall	.-30     	; 0x4314 <__fp_splitA>
    4332:	08 c0       	rjmp	.+16     	; 0x4344 <__fp_splitA+0x30>
    4334:	16 16       	cp	r1, r22
    4336:	17 06       	cpc	r1, r23
    4338:	18 06       	cpc	r1, r24
    433a:	99 1f       	adc	r25, r25
    433c:	f1 cf       	rjmp	.-30     	; 0x4320 <__fp_splitA+0xc>
    433e:	86 95       	lsr	r24
    4340:	71 05       	cpc	r23, r1
    4342:	61 05       	cpc	r22, r1
    4344:	08 94       	sec
    4346:	08 95       	ret

00004348 <__fp_zero>:
    4348:	e8 94       	clt

0000434a <__fp_szero>:
    434a:	bb 27       	eor	r27, r27
    434c:	66 27       	eor	r22, r22
    434e:	77 27       	eor	r23, r23
    4350:	cb 01       	movw	r24, r22
    4352:	97 f9       	bld	r25, 7
    4354:	08 95       	ret

00004356 <__udivmodhi4>:
    4356:	aa 1b       	sub	r26, r26
    4358:	bb 1b       	sub	r27, r27
    435a:	51 e1       	ldi	r21, 0x11	; 17
    435c:	07 c0       	rjmp	.+14     	; 0x436c <__udivmodhi4_ep>

0000435e <__udivmodhi4_loop>:
    435e:	aa 1f       	adc	r26, r26
    4360:	bb 1f       	adc	r27, r27
    4362:	a6 17       	cp	r26, r22
    4364:	b7 07       	cpc	r27, r23
    4366:	10 f0       	brcs	.+4      	; 0x436c <__udivmodhi4_ep>
    4368:	a6 1b       	sub	r26, r22
    436a:	b7 0b       	sbc	r27, r23

0000436c <__udivmodhi4_ep>:
    436c:	88 1f       	adc	r24, r24
    436e:	99 1f       	adc	r25, r25
    4370:	5a 95       	dec	r21
    4372:	a9 f7       	brne	.-22     	; 0x435e <__udivmodhi4_loop>
    4374:	80 95       	com	r24
    4376:	90 95       	com	r25
    4378:	bc 01       	movw	r22, r24
    437a:	cd 01       	movw	r24, r26
    437c:	08 95       	ret

0000437e <__divmodhi4>:
    437e:	97 fb       	bst	r25, 7
    4380:	07 2e       	mov	r0, r23
    4382:	16 f4       	brtc	.+4      	; 0x4388 <__divmodhi4+0xa>
    4384:	00 94       	com	r0
    4386:	06 d0       	rcall	.+12     	; 0x4394 <__divmodhi4_neg1>
    4388:	77 fd       	sbrc	r23, 7
    438a:	08 d0       	rcall	.+16     	; 0x439c <__divmodhi4_neg2>
    438c:	e4 df       	rcall	.-56     	; 0x4356 <__udivmodhi4>
    438e:	07 fc       	sbrc	r0, 7
    4390:	05 d0       	rcall	.+10     	; 0x439c <__divmodhi4_neg2>
    4392:	3e f4       	brtc	.+14     	; 0x43a2 <__divmodhi4_exit>

00004394 <__divmodhi4_neg1>:
    4394:	90 95       	com	r25
    4396:	81 95       	neg	r24
    4398:	9f 4f       	sbci	r25, 0xFF	; 255
    439a:	08 95       	ret

0000439c <__divmodhi4_neg2>:
    439c:	70 95       	com	r23
    439e:	61 95       	neg	r22
    43a0:	7f 4f       	sbci	r23, 0xFF	; 255

000043a2 <__divmodhi4_exit>:
    43a2:	08 95       	ret

000043a4 <__udivmodsi4>:
    43a4:	a1 e2       	ldi	r26, 0x21	; 33
    43a6:	1a 2e       	mov	r1, r26
    43a8:	aa 1b       	sub	r26, r26
    43aa:	bb 1b       	sub	r27, r27
    43ac:	fd 01       	movw	r30, r26
    43ae:	0d c0       	rjmp	.+26     	; 0x43ca <__udivmodsi4_ep>

000043b0 <__udivmodsi4_loop>:
    43b0:	aa 1f       	adc	r26, r26
    43b2:	bb 1f       	adc	r27, r27
    43b4:	ee 1f       	adc	r30, r30
    43b6:	ff 1f       	adc	r31, r31
    43b8:	a2 17       	cp	r26, r18
    43ba:	b3 07       	cpc	r27, r19
    43bc:	e4 07       	cpc	r30, r20
    43be:	f5 07       	cpc	r31, r21
    43c0:	20 f0       	brcs	.+8      	; 0x43ca <__udivmodsi4_ep>
    43c2:	a2 1b       	sub	r26, r18
    43c4:	b3 0b       	sbc	r27, r19
    43c6:	e4 0b       	sbc	r30, r20
    43c8:	f5 0b       	sbc	r31, r21

000043ca <__udivmodsi4_ep>:
    43ca:	66 1f       	adc	r22, r22
    43cc:	77 1f       	adc	r23, r23
    43ce:	88 1f       	adc	r24, r24
    43d0:	99 1f       	adc	r25, r25
    43d2:	1a 94       	dec	r1
    43d4:	69 f7       	brne	.-38     	; 0x43b0 <__udivmodsi4_loop>
    43d6:	60 95       	com	r22
    43d8:	70 95       	com	r23
    43da:	80 95       	com	r24
    43dc:	90 95       	com	r25
    43de:	9b 01       	movw	r18, r22
    43e0:	ac 01       	movw	r20, r24
    43e2:	bd 01       	movw	r22, r26
    43e4:	cf 01       	movw	r24, r30
    43e6:	08 95       	ret

000043e8 <__divmodsi4>:
    43e8:	05 2e       	mov	r0, r21
    43ea:	97 fb       	bst	r25, 7
    43ec:	16 f4       	brtc	.+4      	; 0x43f2 <__divmodsi4+0xa>
    43ee:	00 94       	com	r0
    43f0:	0f d0       	rcall	.+30     	; 0x4410 <__negsi2>
    43f2:	57 fd       	sbrc	r21, 7
    43f4:	05 d0       	rcall	.+10     	; 0x4400 <__divmodsi4_neg2>
    43f6:	d6 df       	rcall	.-84     	; 0x43a4 <__udivmodsi4>
    43f8:	07 fc       	sbrc	r0, 7
    43fa:	02 d0       	rcall	.+4      	; 0x4400 <__divmodsi4_neg2>
    43fc:	46 f4       	brtc	.+16     	; 0x440e <__divmodsi4_exit>
    43fe:	08 c0       	rjmp	.+16     	; 0x4410 <__negsi2>

00004400 <__divmodsi4_neg2>:
    4400:	50 95       	com	r21
    4402:	40 95       	com	r20
    4404:	30 95       	com	r19
    4406:	21 95       	neg	r18
    4408:	3f 4f       	sbci	r19, 0xFF	; 255
    440a:	4f 4f       	sbci	r20, 0xFF	; 255
    440c:	5f 4f       	sbci	r21, 0xFF	; 255

0000440e <__divmodsi4_exit>:
    440e:	08 95       	ret

00004410 <__negsi2>:
    4410:	90 95       	com	r25
    4412:	80 95       	com	r24
    4414:	70 95       	com	r23
    4416:	61 95       	neg	r22
    4418:	7f 4f       	sbci	r23, 0xFF	; 255
    441a:	8f 4f       	sbci	r24, 0xFF	; 255
    441c:	9f 4f       	sbci	r25, 0xFF	; 255
    441e:	08 95       	ret

00004420 <__tablejump2__>:
    4420:	ee 0f       	add	r30, r30
    4422:	ff 1f       	adc	r31, r31
    4424:	88 1f       	adc	r24, r24
    4426:	8b bf       	out	0x3b, r24	; 59
    4428:	07 90       	elpm	r0, Z+
    442a:	f6 91       	elpm	r31, Z
    442c:	e0 2d       	mov	r30, r0
    442e:	19 94       	eijmp

00004430 <__umulhisi3>:
    4430:	a2 9f       	mul	r26, r18
    4432:	b0 01       	movw	r22, r0
    4434:	b3 9f       	mul	r27, r19
    4436:	c0 01       	movw	r24, r0
    4438:	a3 9f       	mul	r26, r19
    443a:	70 0d       	add	r23, r0
    443c:	81 1d       	adc	r24, r1
    443e:	11 24       	eor	r1, r1
    4440:	91 1d       	adc	r25, r1
    4442:	b2 9f       	mul	r27, r18
    4444:	70 0d       	add	r23, r0
    4446:	81 1d       	adc	r24, r1
    4448:	11 24       	eor	r1, r1
    444a:	91 1d       	adc	r25, r1
    444c:	08 95       	ret

0000444e <memcpy>:
    444e:	fb 01       	movw	r30, r22
    4450:	dc 01       	movw	r26, r24
    4452:	02 c0       	rjmp	.+4      	; 0x4458 <memcpy+0xa>
    4454:	01 90       	ld	r0, Z+
    4456:	0d 92       	st	X+, r0
    4458:	41 50       	subi	r20, 0x01	; 1
    445a:	50 40       	sbci	r21, 0x00	; 0
    445c:	d8 f7       	brcc	.-10     	; 0x4454 <memcpy+0x6>
    445e:	08 95       	ret

00004460 <memset>:
    4460:	dc 01       	movw	r26, r24
    4462:	01 c0       	rjmp	.+2      	; 0x4466 <memset+0x6>
    4464:	6d 93       	st	X+, r22
    4466:	41 50       	subi	r20, 0x01	; 1
    4468:	50 40       	sbci	r21, 0x00	; 0
    446a:	e0 f7       	brcc	.-8      	; 0x4464 <memset+0x4>
    446c:	08 95       	ret

0000446e <__itoa_ncheck>:
    446e:	bb 27       	eor	r27, r27
    4470:	4a 30       	cpi	r20, 0x0A	; 10
    4472:	31 f4       	brne	.+12     	; 0x4480 <__itoa_ncheck+0x12>
    4474:	99 23       	and	r25, r25
    4476:	22 f4       	brpl	.+8      	; 0x4480 <__itoa_ncheck+0x12>
    4478:	bd e2       	ldi	r27, 0x2D	; 45
    447a:	90 95       	com	r25
    447c:	81 95       	neg	r24
    447e:	9f 4f       	sbci	r25, 0xFF	; 255
    4480:	01 c0       	rjmp	.+2      	; 0x4484 <__utoa_common>

00004482 <__utoa_ncheck>:
    4482:	bb 27       	eor	r27, r27

00004484 <__utoa_common>:
    4484:	fb 01       	movw	r30, r22
    4486:	55 27       	eor	r21, r21
    4488:	aa 27       	eor	r26, r26
    448a:	88 0f       	add	r24, r24
    448c:	99 1f       	adc	r25, r25
    448e:	aa 1f       	adc	r26, r26
    4490:	a4 17       	cp	r26, r20
    4492:	10 f0       	brcs	.+4      	; 0x4498 <__utoa_common+0x14>
    4494:	a4 1b       	sub	r26, r20
    4496:	83 95       	inc	r24
    4498:	50 51       	subi	r21, 0x10	; 16
    449a:	b9 f7       	brne	.-18     	; 0x448a <__utoa_common+0x6>
    449c:	a0 5d       	subi	r26, 0xD0	; 208
    449e:	aa 33       	cpi	r26, 0x3A	; 58
    44a0:	08 f0       	brcs	.+2      	; 0x44a4 <__utoa_common+0x20>
    44a2:	a9 5d       	subi	r26, 0xD9	; 217
    44a4:	a1 93       	st	Z+, r26
    44a6:	00 97       	sbiw	r24, 0x00	; 0
    44a8:	79 f7       	brne	.-34     	; 0x4488 <__utoa_common+0x4>
    44aa:	b1 11       	cpse	r27, r1
    44ac:	b1 93       	st	Z+, r27
    44ae:	11 92       	st	Z+, r1
    44b0:	cb 01       	movw	r24, r22
    44b2:	26 c2       	rjmp	.+1100   	; 0x4900 <strrev>

000044b4 <printf>:
    44b4:	cf 93       	push	r28
    44b6:	df 93       	push	r29
    44b8:	cd b7       	in	r28, 0x3d	; 61
    44ba:	de b7       	in	r29, 0x3e	; 62
    44bc:	ae 01       	movw	r20, r28
    44be:	4a 5f       	subi	r20, 0xFA	; 250
    44c0:	5f 4f       	sbci	r21, 0xFF	; 255
    44c2:	fa 01       	movw	r30, r20
    44c4:	61 91       	ld	r22, Z+
    44c6:	71 91       	ld	r23, Z+
    44c8:	af 01       	movw	r20, r30
    44ca:	80 91 24 17 	lds	r24, 0x1724	; 0x801724 <__iob+0x2>
    44ce:	90 91 25 17 	lds	r25, 0x1725	; 0x801725 <__iob+0x3>
    44d2:	03 d0       	rcall	.+6      	; 0x44da <vfprintf>
    44d4:	df 91       	pop	r29
    44d6:	cf 91       	pop	r28
    44d8:	08 95       	ret

000044da <vfprintf>:
    44da:	2f 92       	push	r2
    44dc:	3f 92       	push	r3
    44de:	4f 92       	push	r4
    44e0:	5f 92       	push	r5
    44e2:	6f 92       	push	r6
    44e4:	7f 92       	push	r7
    44e6:	8f 92       	push	r8
    44e8:	9f 92       	push	r9
    44ea:	af 92       	push	r10
    44ec:	bf 92       	push	r11
    44ee:	cf 92       	push	r12
    44f0:	df 92       	push	r13
    44f2:	ef 92       	push	r14
    44f4:	ff 92       	push	r15
    44f6:	0f 93       	push	r16
    44f8:	1f 93       	push	r17
    44fa:	cf 93       	push	r28
    44fc:	df 93       	push	r29
    44fe:	cd b7       	in	r28, 0x3d	; 61
    4500:	de b7       	in	r29, 0x3e	; 62
    4502:	2b 97       	sbiw	r28, 0x0b	; 11
    4504:	0f b6       	in	r0, 0x3f	; 63
    4506:	f8 94       	cli
    4508:	de bf       	out	0x3e, r29	; 62
    450a:	0f be       	out	0x3f, r0	; 63
    450c:	cd bf       	out	0x3d, r28	; 61
    450e:	6c 01       	movw	r12, r24
    4510:	7b 01       	movw	r14, r22
    4512:	8a 01       	movw	r16, r20
    4514:	fc 01       	movw	r30, r24
    4516:	17 82       	std	Z+7, r1	; 0x07
    4518:	16 82       	std	Z+6, r1	; 0x06
    451a:	83 81       	ldd	r24, Z+3	; 0x03
    451c:	81 ff       	sbrs	r24, 1
    451e:	bf c1       	rjmp	.+894    	; 0x489e <vfprintf+0x3c4>
    4520:	ce 01       	movw	r24, r28
    4522:	01 96       	adiw	r24, 0x01	; 1
    4524:	3c 01       	movw	r6, r24
    4526:	f6 01       	movw	r30, r12
    4528:	93 81       	ldd	r25, Z+3	; 0x03
    452a:	f7 01       	movw	r30, r14
    452c:	93 fd       	sbrc	r25, 3
    452e:	85 91       	lpm	r24, Z+
    4530:	93 ff       	sbrs	r25, 3
    4532:	81 91       	ld	r24, Z+
    4534:	7f 01       	movw	r14, r30
    4536:	88 23       	and	r24, r24
    4538:	09 f4       	brne	.+2      	; 0x453c <vfprintf+0x62>
    453a:	ad c1       	rjmp	.+858    	; 0x4896 <vfprintf+0x3bc>
    453c:	85 32       	cpi	r24, 0x25	; 37
    453e:	39 f4       	brne	.+14     	; 0x454e <vfprintf+0x74>
    4540:	93 fd       	sbrc	r25, 3
    4542:	85 91       	lpm	r24, Z+
    4544:	93 ff       	sbrs	r25, 3
    4546:	81 91       	ld	r24, Z+
    4548:	7f 01       	movw	r14, r30
    454a:	85 32       	cpi	r24, 0x25	; 37
    454c:	21 f4       	brne	.+8      	; 0x4556 <vfprintf+0x7c>
    454e:	b6 01       	movw	r22, r12
    4550:	90 e0       	ldi	r25, 0x00	; 0
    4552:	e6 d1       	rcall	.+972    	; 0x4920 <fputc>
    4554:	e8 cf       	rjmp	.-48     	; 0x4526 <vfprintf+0x4c>
    4556:	91 2c       	mov	r9, r1
    4558:	21 2c       	mov	r2, r1
    455a:	31 2c       	mov	r3, r1
    455c:	ff e1       	ldi	r31, 0x1F	; 31
    455e:	f3 15       	cp	r31, r3
    4560:	d8 f0       	brcs	.+54     	; 0x4598 <vfprintf+0xbe>
    4562:	8b 32       	cpi	r24, 0x2B	; 43
    4564:	79 f0       	breq	.+30     	; 0x4584 <vfprintf+0xaa>
    4566:	38 f4       	brcc	.+14     	; 0x4576 <vfprintf+0x9c>
    4568:	80 32       	cpi	r24, 0x20	; 32
    456a:	79 f0       	breq	.+30     	; 0x458a <vfprintf+0xb0>
    456c:	83 32       	cpi	r24, 0x23	; 35
    456e:	a1 f4       	brne	.+40     	; 0x4598 <vfprintf+0xbe>
    4570:	23 2d       	mov	r18, r3
    4572:	20 61       	ori	r18, 0x10	; 16
    4574:	1d c0       	rjmp	.+58     	; 0x45b0 <vfprintf+0xd6>
    4576:	8d 32       	cpi	r24, 0x2D	; 45
    4578:	61 f0       	breq	.+24     	; 0x4592 <vfprintf+0xb8>
    457a:	80 33       	cpi	r24, 0x30	; 48
    457c:	69 f4       	brne	.+26     	; 0x4598 <vfprintf+0xbe>
    457e:	23 2d       	mov	r18, r3
    4580:	21 60       	ori	r18, 0x01	; 1
    4582:	16 c0       	rjmp	.+44     	; 0x45b0 <vfprintf+0xd6>
    4584:	83 2d       	mov	r24, r3
    4586:	82 60       	ori	r24, 0x02	; 2
    4588:	38 2e       	mov	r3, r24
    458a:	e3 2d       	mov	r30, r3
    458c:	e4 60       	ori	r30, 0x04	; 4
    458e:	3e 2e       	mov	r3, r30
    4590:	2a c0       	rjmp	.+84     	; 0x45e6 <vfprintf+0x10c>
    4592:	f3 2d       	mov	r31, r3
    4594:	f8 60       	ori	r31, 0x08	; 8
    4596:	1d c0       	rjmp	.+58     	; 0x45d2 <vfprintf+0xf8>
    4598:	37 fc       	sbrc	r3, 7
    459a:	2d c0       	rjmp	.+90     	; 0x45f6 <vfprintf+0x11c>
    459c:	20 ed       	ldi	r18, 0xD0	; 208
    459e:	28 0f       	add	r18, r24
    45a0:	2a 30       	cpi	r18, 0x0A	; 10
    45a2:	40 f0       	brcs	.+16     	; 0x45b4 <vfprintf+0xda>
    45a4:	8e 32       	cpi	r24, 0x2E	; 46
    45a6:	b9 f4       	brne	.+46     	; 0x45d6 <vfprintf+0xfc>
    45a8:	36 fc       	sbrc	r3, 6
    45aa:	75 c1       	rjmp	.+746    	; 0x4896 <vfprintf+0x3bc>
    45ac:	23 2d       	mov	r18, r3
    45ae:	20 64       	ori	r18, 0x40	; 64
    45b0:	32 2e       	mov	r3, r18
    45b2:	19 c0       	rjmp	.+50     	; 0x45e6 <vfprintf+0x10c>
    45b4:	36 fe       	sbrs	r3, 6
    45b6:	06 c0       	rjmp	.+12     	; 0x45c4 <vfprintf+0xea>
    45b8:	8a e0       	ldi	r24, 0x0A	; 10
    45ba:	98 9e       	mul	r9, r24
    45bc:	20 0d       	add	r18, r0
    45be:	11 24       	eor	r1, r1
    45c0:	92 2e       	mov	r9, r18
    45c2:	11 c0       	rjmp	.+34     	; 0x45e6 <vfprintf+0x10c>
    45c4:	ea e0       	ldi	r30, 0x0A	; 10
    45c6:	2e 9e       	mul	r2, r30
    45c8:	20 0d       	add	r18, r0
    45ca:	11 24       	eor	r1, r1
    45cc:	22 2e       	mov	r2, r18
    45ce:	f3 2d       	mov	r31, r3
    45d0:	f0 62       	ori	r31, 0x20	; 32
    45d2:	3f 2e       	mov	r3, r31
    45d4:	08 c0       	rjmp	.+16     	; 0x45e6 <vfprintf+0x10c>
    45d6:	8c 36       	cpi	r24, 0x6C	; 108
    45d8:	21 f4       	brne	.+8      	; 0x45e2 <vfprintf+0x108>
    45da:	83 2d       	mov	r24, r3
    45dc:	80 68       	ori	r24, 0x80	; 128
    45de:	38 2e       	mov	r3, r24
    45e0:	02 c0       	rjmp	.+4      	; 0x45e6 <vfprintf+0x10c>
    45e2:	88 36       	cpi	r24, 0x68	; 104
    45e4:	41 f4       	brne	.+16     	; 0x45f6 <vfprintf+0x11c>
    45e6:	f7 01       	movw	r30, r14
    45e8:	93 fd       	sbrc	r25, 3
    45ea:	85 91       	lpm	r24, Z+
    45ec:	93 ff       	sbrs	r25, 3
    45ee:	81 91       	ld	r24, Z+
    45f0:	7f 01       	movw	r14, r30
    45f2:	81 11       	cpse	r24, r1
    45f4:	b3 cf       	rjmp	.-154    	; 0x455c <vfprintf+0x82>
    45f6:	98 2f       	mov	r25, r24
    45f8:	9f 7d       	andi	r25, 0xDF	; 223
    45fa:	95 54       	subi	r25, 0x45	; 69
    45fc:	93 30       	cpi	r25, 0x03	; 3
    45fe:	28 f4       	brcc	.+10     	; 0x460a <vfprintf+0x130>
    4600:	0c 5f       	subi	r16, 0xFC	; 252
    4602:	1f 4f       	sbci	r17, 0xFF	; 255
    4604:	9f e3       	ldi	r25, 0x3F	; 63
    4606:	99 83       	std	Y+1, r25	; 0x01
    4608:	0d c0       	rjmp	.+26     	; 0x4624 <vfprintf+0x14a>
    460a:	83 36       	cpi	r24, 0x63	; 99
    460c:	31 f0       	breq	.+12     	; 0x461a <vfprintf+0x140>
    460e:	83 37       	cpi	r24, 0x73	; 115
    4610:	71 f0       	breq	.+28     	; 0x462e <vfprintf+0x154>
    4612:	83 35       	cpi	r24, 0x53	; 83
    4614:	09 f0       	breq	.+2      	; 0x4618 <vfprintf+0x13e>
    4616:	55 c0       	rjmp	.+170    	; 0x46c2 <vfprintf+0x1e8>
    4618:	20 c0       	rjmp	.+64     	; 0x465a <vfprintf+0x180>
    461a:	f8 01       	movw	r30, r16
    461c:	80 81       	ld	r24, Z
    461e:	89 83       	std	Y+1, r24	; 0x01
    4620:	0e 5f       	subi	r16, 0xFE	; 254
    4622:	1f 4f       	sbci	r17, 0xFF	; 255
    4624:	88 24       	eor	r8, r8
    4626:	83 94       	inc	r8
    4628:	91 2c       	mov	r9, r1
    462a:	53 01       	movw	r10, r6
    462c:	12 c0       	rjmp	.+36     	; 0x4652 <vfprintf+0x178>
    462e:	28 01       	movw	r4, r16
    4630:	f2 e0       	ldi	r31, 0x02	; 2
    4632:	4f 0e       	add	r4, r31
    4634:	51 1c       	adc	r5, r1
    4636:	f8 01       	movw	r30, r16
    4638:	a0 80       	ld	r10, Z
    463a:	b1 80       	ldd	r11, Z+1	; 0x01
    463c:	36 fe       	sbrs	r3, 6
    463e:	03 c0       	rjmp	.+6      	; 0x4646 <vfprintf+0x16c>
    4640:	69 2d       	mov	r22, r9
    4642:	70 e0       	ldi	r23, 0x00	; 0
    4644:	02 c0       	rjmp	.+4      	; 0x464a <vfprintf+0x170>
    4646:	6f ef       	ldi	r22, 0xFF	; 255
    4648:	7f ef       	ldi	r23, 0xFF	; 255
    464a:	c5 01       	movw	r24, r10
    464c:	4e d1       	rcall	.+668    	; 0x48ea <strnlen>
    464e:	4c 01       	movw	r8, r24
    4650:	82 01       	movw	r16, r4
    4652:	f3 2d       	mov	r31, r3
    4654:	ff 77       	andi	r31, 0x7F	; 127
    4656:	3f 2e       	mov	r3, r31
    4658:	15 c0       	rjmp	.+42     	; 0x4684 <vfprintf+0x1aa>
    465a:	28 01       	movw	r4, r16
    465c:	22 e0       	ldi	r18, 0x02	; 2
    465e:	42 0e       	add	r4, r18
    4660:	51 1c       	adc	r5, r1
    4662:	f8 01       	movw	r30, r16
    4664:	a0 80       	ld	r10, Z
    4666:	b1 80       	ldd	r11, Z+1	; 0x01
    4668:	36 fe       	sbrs	r3, 6
    466a:	03 c0       	rjmp	.+6      	; 0x4672 <vfprintf+0x198>
    466c:	69 2d       	mov	r22, r9
    466e:	70 e0       	ldi	r23, 0x00	; 0
    4670:	02 c0       	rjmp	.+4      	; 0x4676 <vfprintf+0x19c>
    4672:	6f ef       	ldi	r22, 0xFF	; 255
    4674:	7f ef       	ldi	r23, 0xFF	; 255
    4676:	c5 01       	movw	r24, r10
    4678:	2d d1       	rcall	.+602    	; 0x48d4 <strnlen_P>
    467a:	4c 01       	movw	r8, r24
    467c:	f3 2d       	mov	r31, r3
    467e:	f0 68       	ori	r31, 0x80	; 128
    4680:	3f 2e       	mov	r3, r31
    4682:	82 01       	movw	r16, r4
    4684:	33 fc       	sbrc	r3, 3
    4686:	19 c0       	rjmp	.+50     	; 0x46ba <vfprintf+0x1e0>
    4688:	82 2d       	mov	r24, r2
    468a:	90 e0       	ldi	r25, 0x00	; 0
    468c:	88 16       	cp	r8, r24
    468e:	99 06       	cpc	r9, r25
    4690:	a0 f4       	brcc	.+40     	; 0x46ba <vfprintf+0x1e0>
    4692:	b6 01       	movw	r22, r12
    4694:	80 e2       	ldi	r24, 0x20	; 32
    4696:	90 e0       	ldi	r25, 0x00	; 0
    4698:	43 d1       	rcall	.+646    	; 0x4920 <fputc>
    469a:	2a 94       	dec	r2
    469c:	f5 cf       	rjmp	.-22     	; 0x4688 <vfprintf+0x1ae>
    469e:	f5 01       	movw	r30, r10
    46a0:	37 fc       	sbrc	r3, 7
    46a2:	85 91       	lpm	r24, Z+
    46a4:	37 fe       	sbrs	r3, 7
    46a6:	81 91       	ld	r24, Z+
    46a8:	5f 01       	movw	r10, r30
    46aa:	b6 01       	movw	r22, r12
    46ac:	90 e0       	ldi	r25, 0x00	; 0
    46ae:	38 d1       	rcall	.+624    	; 0x4920 <fputc>
    46b0:	21 10       	cpse	r2, r1
    46b2:	2a 94       	dec	r2
    46b4:	21 e0       	ldi	r18, 0x01	; 1
    46b6:	82 1a       	sub	r8, r18
    46b8:	91 08       	sbc	r9, r1
    46ba:	81 14       	cp	r8, r1
    46bc:	91 04       	cpc	r9, r1
    46be:	79 f7       	brne	.-34     	; 0x469e <vfprintf+0x1c4>
    46c0:	e1 c0       	rjmp	.+450    	; 0x4884 <vfprintf+0x3aa>
    46c2:	84 36       	cpi	r24, 0x64	; 100
    46c4:	11 f0       	breq	.+4      	; 0x46ca <vfprintf+0x1f0>
    46c6:	89 36       	cpi	r24, 0x69	; 105
    46c8:	39 f5       	brne	.+78     	; 0x4718 <vfprintf+0x23e>
    46ca:	f8 01       	movw	r30, r16
    46cc:	37 fe       	sbrs	r3, 7
    46ce:	07 c0       	rjmp	.+14     	; 0x46de <vfprintf+0x204>
    46d0:	60 81       	ld	r22, Z
    46d2:	71 81       	ldd	r23, Z+1	; 0x01
    46d4:	82 81       	ldd	r24, Z+2	; 0x02
    46d6:	93 81       	ldd	r25, Z+3	; 0x03
    46d8:	0c 5f       	subi	r16, 0xFC	; 252
    46da:	1f 4f       	sbci	r17, 0xFF	; 255
    46dc:	08 c0       	rjmp	.+16     	; 0x46ee <vfprintf+0x214>
    46de:	60 81       	ld	r22, Z
    46e0:	71 81       	ldd	r23, Z+1	; 0x01
    46e2:	07 2e       	mov	r0, r23
    46e4:	00 0c       	add	r0, r0
    46e6:	88 0b       	sbc	r24, r24
    46e8:	99 0b       	sbc	r25, r25
    46ea:	0e 5f       	subi	r16, 0xFE	; 254
    46ec:	1f 4f       	sbci	r17, 0xFF	; 255
    46ee:	f3 2d       	mov	r31, r3
    46f0:	ff 76       	andi	r31, 0x6F	; 111
    46f2:	3f 2e       	mov	r3, r31
    46f4:	97 ff       	sbrs	r25, 7
    46f6:	09 c0       	rjmp	.+18     	; 0x470a <vfprintf+0x230>
    46f8:	90 95       	com	r25
    46fa:	80 95       	com	r24
    46fc:	70 95       	com	r23
    46fe:	61 95       	neg	r22
    4700:	7f 4f       	sbci	r23, 0xFF	; 255
    4702:	8f 4f       	sbci	r24, 0xFF	; 255
    4704:	9f 4f       	sbci	r25, 0xFF	; 255
    4706:	f0 68       	ori	r31, 0x80	; 128
    4708:	3f 2e       	mov	r3, r31
    470a:	2a e0       	ldi	r18, 0x0A	; 10
    470c:	30 e0       	ldi	r19, 0x00	; 0
    470e:	a3 01       	movw	r20, r6
    4710:	43 d1       	rcall	.+646    	; 0x4998 <__ultoa_invert>
    4712:	88 2e       	mov	r8, r24
    4714:	86 18       	sub	r8, r6
    4716:	44 c0       	rjmp	.+136    	; 0x47a0 <vfprintf+0x2c6>
    4718:	85 37       	cpi	r24, 0x75	; 117
    471a:	31 f4       	brne	.+12     	; 0x4728 <vfprintf+0x24e>
    471c:	23 2d       	mov	r18, r3
    471e:	2f 7e       	andi	r18, 0xEF	; 239
    4720:	b2 2e       	mov	r11, r18
    4722:	2a e0       	ldi	r18, 0x0A	; 10
    4724:	30 e0       	ldi	r19, 0x00	; 0
    4726:	25 c0       	rjmp	.+74     	; 0x4772 <vfprintf+0x298>
    4728:	93 2d       	mov	r25, r3
    472a:	99 7f       	andi	r25, 0xF9	; 249
    472c:	b9 2e       	mov	r11, r25
    472e:	8f 36       	cpi	r24, 0x6F	; 111
    4730:	c1 f0       	breq	.+48     	; 0x4762 <vfprintf+0x288>
    4732:	18 f4       	brcc	.+6      	; 0x473a <vfprintf+0x260>
    4734:	88 35       	cpi	r24, 0x58	; 88
    4736:	79 f0       	breq	.+30     	; 0x4756 <vfprintf+0x27c>
    4738:	ae c0       	rjmp	.+348    	; 0x4896 <vfprintf+0x3bc>
    473a:	80 37       	cpi	r24, 0x70	; 112
    473c:	19 f0       	breq	.+6      	; 0x4744 <vfprintf+0x26a>
    473e:	88 37       	cpi	r24, 0x78	; 120
    4740:	21 f0       	breq	.+8      	; 0x474a <vfprintf+0x270>
    4742:	a9 c0       	rjmp	.+338    	; 0x4896 <vfprintf+0x3bc>
    4744:	e9 2f       	mov	r30, r25
    4746:	e0 61       	ori	r30, 0x10	; 16
    4748:	be 2e       	mov	r11, r30
    474a:	b4 fe       	sbrs	r11, 4
    474c:	0d c0       	rjmp	.+26     	; 0x4768 <vfprintf+0x28e>
    474e:	fb 2d       	mov	r31, r11
    4750:	f4 60       	ori	r31, 0x04	; 4
    4752:	bf 2e       	mov	r11, r31
    4754:	09 c0       	rjmp	.+18     	; 0x4768 <vfprintf+0x28e>
    4756:	34 fe       	sbrs	r3, 4
    4758:	0a c0       	rjmp	.+20     	; 0x476e <vfprintf+0x294>
    475a:	29 2f       	mov	r18, r25
    475c:	26 60       	ori	r18, 0x06	; 6
    475e:	b2 2e       	mov	r11, r18
    4760:	06 c0       	rjmp	.+12     	; 0x476e <vfprintf+0x294>
    4762:	28 e0       	ldi	r18, 0x08	; 8
    4764:	30 e0       	ldi	r19, 0x00	; 0
    4766:	05 c0       	rjmp	.+10     	; 0x4772 <vfprintf+0x298>
    4768:	20 e1       	ldi	r18, 0x10	; 16
    476a:	30 e0       	ldi	r19, 0x00	; 0
    476c:	02 c0       	rjmp	.+4      	; 0x4772 <vfprintf+0x298>
    476e:	20 e1       	ldi	r18, 0x10	; 16
    4770:	32 e0       	ldi	r19, 0x02	; 2
    4772:	f8 01       	movw	r30, r16
    4774:	b7 fe       	sbrs	r11, 7
    4776:	07 c0       	rjmp	.+14     	; 0x4786 <vfprintf+0x2ac>
    4778:	60 81       	ld	r22, Z
    477a:	71 81       	ldd	r23, Z+1	; 0x01
    477c:	82 81       	ldd	r24, Z+2	; 0x02
    477e:	93 81       	ldd	r25, Z+3	; 0x03
    4780:	0c 5f       	subi	r16, 0xFC	; 252
    4782:	1f 4f       	sbci	r17, 0xFF	; 255
    4784:	06 c0       	rjmp	.+12     	; 0x4792 <vfprintf+0x2b8>
    4786:	60 81       	ld	r22, Z
    4788:	71 81       	ldd	r23, Z+1	; 0x01
    478a:	80 e0       	ldi	r24, 0x00	; 0
    478c:	90 e0       	ldi	r25, 0x00	; 0
    478e:	0e 5f       	subi	r16, 0xFE	; 254
    4790:	1f 4f       	sbci	r17, 0xFF	; 255
    4792:	a3 01       	movw	r20, r6
    4794:	01 d1       	rcall	.+514    	; 0x4998 <__ultoa_invert>
    4796:	88 2e       	mov	r8, r24
    4798:	86 18       	sub	r8, r6
    479a:	fb 2d       	mov	r31, r11
    479c:	ff 77       	andi	r31, 0x7F	; 127
    479e:	3f 2e       	mov	r3, r31
    47a0:	36 fe       	sbrs	r3, 6
    47a2:	0d c0       	rjmp	.+26     	; 0x47be <vfprintf+0x2e4>
    47a4:	23 2d       	mov	r18, r3
    47a6:	2e 7f       	andi	r18, 0xFE	; 254
    47a8:	a2 2e       	mov	r10, r18
    47aa:	89 14       	cp	r8, r9
    47ac:	58 f4       	brcc	.+22     	; 0x47c4 <vfprintf+0x2ea>
    47ae:	34 fe       	sbrs	r3, 4
    47b0:	0b c0       	rjmp	.+22     	; 0x47c8 <vfprintf+0x2ee>
    47b2:	32 fc       	sbrc	r3, 2
    47b4:	09 c0       	rjmp	.+18     	; 0x47c8 <vfprintf+0x2ee>
    47b6:	83 2d       	mov	r24, r3
    47b8:	8e 7e       	andi	r24, 0xEE	; 238
    47ba:	a8 2e       	mov	r10, r24
    47bc:	05 c0       	rjmp	.+10     	; 0x47c8 <vfprintf+0x2ee>
    47be:	b8 2c       	mov	r11, r8
    47c0:	a3 2c       	mov	r10, r3
    47c2:	03 c0       	rjmp	.+6      	; 0x47ca <vfprintf+0x2f0>
    47c4:	b8 2c       	mov	r11, r8
    47c6:	01 c0       	rjmp	.+2      	; 0x47ca <vfprintf+0x2f0>
    47c8:	b9 2c       	mov	r11, r9
    47ca:	a4 fe       	sbrs	r10, 4
    47cc:	0f c0       	rjmp	.+30     	; 0x47ec <vfprintf+0x312>
    47ce:	fe 01       	movw	r30, r28
    47d0:	e8 0d       	add	r30, r8
    47d2:	f1 1d       	adc	r31, r1
    47d4:	80 81       	ld	r24, Z
    47d6:	80 33       	cpi	r24, 0x30	; 48
    47d8:	21 f4       	brne	.+8      	; 0x47e2 <vfprintf+0x308>
    47da:	9a 2d       	mov	r25, r10
    47dc:	99 7e       	andi	r25, 0xE9	; 233
    47de:	a9 2e       	mov	r10, r25
    47e0:	09 c0       	rjmp	.+18     	; 0x47f4 <vfprintf+0x31a>
    47e2:	a2 fe       	sbrs	r10, 2
    47e4:	06 c0       	rjmp	.+12     	; 0x47f2 <vfprintf+0x318>
    47e6:	b3 94       	inc	r11
    47e8:	b3 94       	inc	r11
    47ea:	04 c0       	rjmp	.+8      	; 0x47f4 <vfprintf+0x31a>
    47ec:	8a 2d       	mov	r24, r10
    47ee:	86 78       	andi	r24, 0x86	; 134
    47f0:	09 f0       	breq	.+2      	; 0x47f4 <vfprintf+0x31a>
    47f2:	b3 94       	inc	r11
    47f4:	a3 fc       	sbrc	r10, 3
    47f6:	10 c0       	rjmp	.+32     	; 0x4818 <vfprintf+0x33e>
    47f8:	a0 fe       	sbrs	r10, 0
    47fa:	06 c0       	rjmp	.+12     	; 0x4808 <vfprintf+0x32e>
    47fc:	b2 14       	cp	r11, r2
    47fe:	80 f4       	brcc	.+32     	; 0x4820 <vfprintf+0x346>
    4800:	28 0c       	add	r2, r8
    4802:	92 2c       	mov	r9, r2
    4804:	9b 18       	sub	r9, r11
    4806:	0d c0       	rjmp	.+26     	; 0x4822 <vfprintf+0x348>
    4808:	b2 14       	cp	r11, r2
    480a:	58 f4       	brcc	.+22     	; 0x4822 <vfprintf+0x348>
    480c:	b6 01       	movw	r22, r12
    480e:	80 e2       	ldi	r24, 0x20	; 32
    4810:	90 e0       	ldi	r25, 0x00	; 0
    4812:	86 d0       	rcall	.+268    	; 0x4920 <fputc>
    4814:	b3 94       	inc	r11
    4816:	f8 cf       	rjmp	.-16     	; 0x4808 <vfprintf+0x32e>
    4818:	b2 14       	cp	r11, r2
    481a:	18 f4       	brcc	.+6      	; 0x4822 <vfprintf+0x348>
    481c:	2b 18       	sub	r2, r11
    481e:	02 c0       	rjmp	.+4      	; 0x4824 <vfprintf+0x34a>
    4820:	98 2c       	mov	r9, r8
    4822:	21 2c       	mov	r2, r1
    4824:	a4 fe       	sbrs	r10, 4
    4826:	0f c0       	rjmp	.+30     	; 0x4846 <vfprintf+0x36c>
    4828:	b6 01       	movw	r22, r12
    482a:	80 e3       	ldi	r24, 0x30	; 48
    482c:	90 e0       	ldi	r25, 0x00	; 0
    482e:	78 d0       	rcall	.+240    	; 0x4920 <fputc>
    4830:	a2 fe       	sbrs	r10, 2
    4832:	16 c0       	rjmp	.+44     	; 0x4860 <vfprintf+0x386>
    4834:	a1 fc       	sbrc	r10, 1
    4836:	03 c0       	rjmp	.+6      	; 0x483e <vfprintf+0x364>
    4838:	88 e7       	ldi	r24, 0x78	; 120
    483a:	90 e0       	ldi	r25, 0x00	; 0
    483c:	02 c0       	rjmp	.+4      	; 0x4842 <vfprintf+0x368>
    483e:	88 e5       	ldi	r24, 0x58	; 88
    4840:	90 e0       	ldi	r25, 0x00	; 0
    4842:	b6 01       	movw	r22, r12
    4844:	0c c0       	rjmp	.+24     	; 0x485e <vfprintf+0x384>
    4846:	8a 2d       	mov	r24, r10
    4848:	86 78       	andi	r24, 0x86	; 134
    484a:	51 f0       	breq	.+20     	; 0x4860 <vfprintf+0x386>
    484c:	a1 fe       	sbrs	r10, 1
    484e:	02 c0       	rjmp	.+4      	; 0x4854 <vfprintf+0x37a>
    4850:	8b e2       	ldi	r24, 0x2B	; 43
    4852:	01 c0       	rjmp	.+2      	; 0x4856 <vfprintf+0x37c>
    4854:	80 e2       	ldi	r24, 0x20	; 32
    4856:	a7 fc       	sbrc	r10, 7
    4858:	8d e2       	ldi	r24, 0x2D	; 45
    485a:	b6 01       	movw	r22, r12
    485c:	90 e0       	ldi	r25, 0x00	; 0
    485e:	60 d0       	rcall	.+192    	; 0x4920 <fputc>
    4860:	89 14       	cp	r8, r9
    4862:	30 f4       	brcc	.+12     	; 0x4870 <vfprintf+0x396>
    4864:	b6 01       	movw	r22, r12
    4866:	80 e3       	ldi	r24, 0x30	; 48
    4868:	90 e0       	ldi	r25, 0x00	; 0
    486a:	5a d0       	rcall	.+180    	; 0x4920 <fputc>
    486c:	9a 94       	dec	r9
    486e:	f8 cf       	rjmp	.-16     	; 0x4860 <vfprintf+0x386>
    4870:	8a 94       	dec	r8
    4872:	f3 01       	movw	r30, r6
    4874:	e8 0d       	add	r30, r8
    4876:	f1 1d       	adc	r31, r1
    4878:	80 81       	ld	r24, Z
    487a:	b6 01       	movw	r22, r12
    487c:	90 e0       	ldi	r25, 0x00	; 0
    487e:	50 d0       	rcall	.+160    	; 0x4920 <fputc>
    4880:	81 10       	cpse	r8, r1
    4882:	f6 cf       	rjmp	.-20     	; 0x4870 <vfprintf+0x396>
    4884:	22 20       	and	r2, r2
    4886:	09 f4       	brne	.+2      	; 0x488a <vfprintf+0x3b0>
    4888:	4e ce       	rjmp	.-868    	; 0x4526 <vfprintf+0x4c>
    488a:	b6 01       	movw	r22, r12
    488c:	80 e2       	ldi	r24, 0x20	; 32
    488e:	90 e0       	ldi	r25, 0x00	; 0
    4890:	47 d0       	rcall	.+142    	; 0x4920 <fputc>
    4892:	2a 94       	dec	r2
    4894:	f7 cf       	rjmp	.-18     	; 0x4884 <vfprintf+0x3aa>
    4896:	f6 01       	movw	r30, r12
    4898:	86 81       	ldd	r24, Z+6	; 0x06
    489a:	97 81       	ldd	r25, Z+7	; 0x07
    489c:	02 c0       	rjmp	.+4      	; 0x48a2 <vfprintf+0x3c8>
    489e:	8f ef       	ldi	r24, 0xFF	; 255
    48a0:	9f ef       	ldi	r25, 0xFF	; 255
    48a2:	2b 96       	adiw	r28, 0x0b	; 11
    48a4:	0f b6       	in	r0, 0x3f	; 63
    48a6:	f8 94       	cli
    48a8:	de bf       	out	0x3e, r29	; 62
    48aa:	0f be       	out	0x3f, r0	; 63
    48ac:	cd bf       	out	0x3d, r28	; 61
    48ae:	df 91       	pop	r29
    48b0:	cf 91       	pop	r28
    48b2:	1f 91       	pop	r17
    48b4:	0f 91       	pop	r16
    48b6:	ff 90       	pop	r15
    48b8:	ef 90       	pop	r14
    48ba:	df 90       	pop	r13
    48bc:	cf 90       	pop	r12
    48be:	bf 90       	pop	r11
    48c0:	af 90       	pop	r10
    48c2:	9f 90       	pop	r9
    48c4:	8f 90       	pop	r8
    48c6:	7f 90       	pop	r7
    48c8:	6f 90       	pop	r6
    48ca:	5f 90       	pop	r5
    48cc:	4f 90       	pop	r4
    48ce:	3f 90       	pop	r3
    48d0:	2f 90       	pop	r2
    48d2:	08 95       	ret

000048d4 <strnlen_P>:
    48d4:	fc 01       	movw	r30, r24
    48d6:	05 90       	lpm	r0, Z+
    48d8:	61 50       	subi	r22, 0x01	; 1
    48da:	70 40       	sbci	r23, 0x00	; 0
    48dc:	01 10       	cpse	r0, r1
    48de:	d8 f7       	brcc	.-10     	; 0x48d6 <strnlen_P+0x2>
    48e0:	80 95       	com	r24
    48e2:	90 95       	com	r25
    48e4:	8e 0f       	add	r24, r30
    48e6:	9f 1f       	adc	r25, r31
    48e8:	08 95       	ret

000048ea <strnlen>:
    48ea:	fc 01       	movw	r30, r24
    48ec:	61 50       	subi	r22, 0x01	; 1
    48ee:	70 40       	sbci	r23, 0x00	; 0
    48f0:	01 90       	ld	r0, Z+
    48f2:	01 10       	cpse	r0, r1
    48f4:	d8 f7       	brcc	.-10     	; 0x48ec <strnlen+0x2>
    48f6:	80 95       	com	r24
    48f8:	90 95       	com	r25
    48fa:	8e 0f       	add	r24, r30
    48fc:	9f 1f       	adc	r25, r31
    48fe:	08 95       	ret

00004900 <strrev>:
    4900:	dc 01       	movw	r26, r24
    4902:	fc 01       	movw	r30, r24
    4904:	67 2f       	mov	r22, r23
    4906:	71 91       	ld	r23, Z+
    4908:	77 23       	and	r23, r23
    490a:	e1 f7       	brne	.-8      	; 0x4904 <strrev+0x4>
    490c:	32 97       	sbiw	r30, 0x02	; 2
    490e:	04 c0       	rjmp	.+8      	; 0x4918 <strrev+0x18>
    4910:	7c 91       	ld	r23, X
    4912:	6d 93       	st	X+, r22
    4914:	70 83       	st	Z, r23
    4916:	62 91       	ld	r22, -Z
    4918:	ae 17       	cp	r26, r30
    491a:	bf 07       	cpc	r27, r31
    491c:	c8 f3       	brcs	.-14     	; 0x4910 <strrev+0x10>
    491e:	08 95       	ret

00004920 <fputc>:
    4920:	0f 93       	push	r16
    4922:	1f 93       	push	r17
    4924:	cf 93       	push	r28
    4926:	df 93       	push	r29
    4928:	fb 01       	movw	r30, r22
    492a:	23 81       	ldd	r18, Z+3	; 0x03
    492c:	21 fd       	sbrc	r18, 1
    492e:	03 c0       	rjmp	.+6      	; 0x4936 <fputc+0x16>
    4930:	8f ef       	ldi	r24, 0xFF	; 255
    4932:	9f ef       	ldi	r25, 0xFF	; 255
    4934:	2c c0       	rjmp	.+88     	; 0x498e <fputc+0x6e>
    4936:	22 ff       	sbrs	r18, 2
    4938:	16 c0       	rjmp	.+44     	; 0x4966 <fputc+0x46>
    493a:	46 81       	ldd	r20, Z+6	; 0x06
    493c:	57 81       	ldd	r21, Z+7	; 0x07
    493e:	24 81       	ldd	r18, Z+4	; 0x04
    4940:	35 81       	ldd	r19, Z+5	; 0x05
    4942:	42 17       	cp	r20, r18
    4944:	53 07       	cpc	r21, r19
    4946:	44 f4       	brge	.+16     	; 0x4958 <fputc+0x38>
    4948:	a0 81       	ld	r26, Z
    494a:	b1 81       	ldd	r27, Z+1	; 0x01
    494c:	9d 01       	movw	r18, r26
    494e:	2f 5f       	subi	r18, 0xFF	; 255
    4950:	3f 4f       	sbci	r19, 0xFF	; 255
    4952:	31 83       	std	Z+1, r19	; 0x01
    4954:	20 83       	st	Z, r18
    4956:	8c 93       	st	X, r24
    4958:	26 81       	ldd	r18, Z+6	; 0x06
    495a:	37 81       	ldd	r19, Z+7	; 0x07
    495c:	2f 5f       	subi	r18, 0xFF	; 255
    495e:	3f 4f       	sbci	r19, 0xFF	; 255
    4960:	37 83       	std	Z+7, r19	; 0x07
    4962:	26 83       	std	Z+6, r18	; 0x06
    4964:	14 c0       	rjmp	.+40     	; 0x498e <fputc+0x6e>
    4966:	8b 01       	movw	r16, r22
    4968:	ec 01       	movw	r28, r24
    496a:	fb 01       	movw	r30, r22
    496c:	00 84       	ldd	r0, Z+8	; 0x08
    496e:	f1 85       	ldd	r31, Z+9	; 0x09
    4970:	e0 2d       	mov	r30, r0
    4972:	19 95       	eicall
    4974:	89 2b       	or	r24, r25
    4976:	e1 f6       	brne	.-72     	; 0x4930 <fputc+0x10>
    4978:	d8 01       	movw	r26, r16
    497a:	16 96       	adiw	r26, 0x06	; 6
    497c:	8d 91       	ld	r24, X+
    497e:	9c 91       	ld	r25, X
    4980:	17 97       	sbiw	r26, 0x07	; 7
    4982:	01 96       	adiw	r24, 0x01	; 1
    4984:	17 96       	adiw	r26, 0x07	; 7
    4986:	9c 93       	st	X, r25
    4988:	8e 93       	st	-X, r24
    498a:	16 97       	sbiw	r26, 0x06	; 6
    498c:	ce 01       	movw	r24, r28
    498e:	df 91       	pop	r29
    4990:	cf 91       	pop	r28
    4992:	1f 91       	pop	r17
    4994:	0f 91       	pop	r16
    4996:	08 95       	ret

00004998 <__ultoa_invert>:
    4998:	fa 01       	movw	r30, r20
    499a:	aa 27       	eor	r26, r26
    499c:	28 30       	cpi	r18, 0x08	; 8
    499e:	51 f1       	breq	.+84     	; 0x49f4 <__ultoa_invert+0x5c>
    49a0:	20 31       	cpi	r18, 0x10	; 16
    49a2:	81 f1       	breq	.+96     	; 0x4a04 <__ultoa_invert+0x6c>
    49a4:	e8 94       	clt
    49a6:	6f 93       	push	r22
    49a8:	6e 7f       	andi	r22, 0xFE	; 254
    49aa:	6e 5f       	subi	r22, 0xFE	; 254
    49ac:	7f 4f       	sbci	r23, 0xFF	; 255
    49ae:	8f 4f       	sbci	r24, 0xFF	; 255
    49b0:	9f 4f       	sbci	r25, 0xFF	; 255
    49b2:	af 4f       	sbci	r26, 0xFF	; 255
    49b4:	b1 e0       	ldi	r27, 0x01	; 1
    49b6:	3e d0       	rcall	.+124    	; 0x4a34 <__ultoa_invert+0x9c>
    49b8:	b4 e0       	ldi	r27, 0x04	; 4
    49ba:	3c d0       	rcall	.+120    	; 0x4a34 <__ultoa_invert+0x9c>
    49bc:	67 0f       	add	r22, r23
    49be:	78 1f       	adc	r23, r24
    49c0:	89 1f       	adc	r24, r25
    49c2:	9a 1f       	adc	r25, r26
    49c4:	a1 1d       	adc	r26, r1
    49c6:	68 0f       	add	r22, r24
    49c8:	79 1f       	adc	r23, r25
    49ca:	8a 1f       	adc	r24, r26
    49cc:	91 1d       	adc	r25, r1
    49ce:	a1 1d       	adc	r26, r1
    49d0:	6a 0f       	add	r22, r26
    49d2:	71 1d       	adc	r23, r1
    49d4:	81 1d       	adc	r24, r1
    49d6:	91 1d       	adc	r25, r1
    49d8:	a1 1d       	adc	r26, r1
    49da:	20 d0       	rcall	.+64     	; 0x4a1c <__ultoa_invert+0x84>
    49dc:	09 f4       	brne	.+2      	; 0x49e0 <__ultoa_invert+0x48>
    49de:	68 94       	set
    49e0:	3f 91       	pop	r19
    49e2:	2a e0       	ldi	r18, 0x0A	; 10
    49e4:	26 9f       	mul	r18, r22
    49e6:	11 24       	eor	r1, r1
    49e8:	30 19       	sub	r19, r0
    49ea:	30 5d       	subi	r19, 0xD0	; 208
    49ec:	31 93       	st	Z+, r19
    49ee:	de f6       	brtc	.-74     	; 0x49a6 <__ultoa_invert+0xe>
    49f0:	cf 01       	movw	r24, r30
    49f2:	08 95       	ret
    49f4:	46 2f       	mov	r20, r22
    49f6:	47 70       	andi	r20, 0x07	; 7
    49f8:	40 5d       	subi	r20, 0xD0	; 208
    49fa:	41 93       	st	Z+, r20
    49fc:	b3 e0       	ldi	r27, 0x03	; 3
    49fe:	0f d0       	rcall	.+30     	; 0x4a1e <__ultoa_invert+0x86>
    4a00:	c9 f7       	brne	.-14     	; 0x49f4 <__ultoa_invert+0x5c>
    4a02:	f6 cf       	rjmp	.-20     	; 0x49f0 <__ultoa_invert+0x58>
    4a04:	46 2f       	mov	r20, r22
    4a06:	4f 70       	andi	r20, 0x0F	; 15
    4a08:	40 5d       	subi	r20, 0xD0	; 208
    4a0a:	4a 33       	cpi	r20, 0x3A	; 58
    4a0c:	18 f0       	brcs	.+6      	; 0x4a14 <__ultoa_invert+0x7c>
    4a0e:	49 5d       	subi	r20, 0xD9	; 217
    4a10:	31 fd       	sbrc	r19, 1
    4a12:	40 52       	subi	r20, 0x20	; 32
    4a14:	41 93       	st	Z+, r20
    4a16:	02 d0       	rcall	.+4      	; 0x4a1c <__ultoa_invert+0x84>
    4a18:	a9 f7       	brne	.-22     	; 0x4a04 <__ultoa_invert+0x6c>
    4a1a:	ea cf       	rjmp	.-44     	; 0x49f0 <__ultoa_invert+0x58>
    4a1c:	b4 e0       	ldi	r27, 0x04	; 4
    4a1e:	a6 95       	lsr	r26
    4a20:	97 95       	ror	r25
    4a22:	87 95       	ror	r24
    4a24:	77 95       	ror	r23
    4a26:	67 95       	ror	r22
    4a28:	ba 95       	dec	r27
    4a2a:	c9 f7       	brne	.-14     	; 0x4a1e <__ultoa_invert+0x86>
    4a2c:	00 97       	sbiw	r24, 0x00	; 0
    4a2e:	61 05       	cpc	r22, r1
    4a30:	71 05       	cpc	r23, r1
    4a32:	08 95       	ret
    4a34:	9b 01       	movw	r18, r22
    4a36:	ac 01       	movw	r20, r24
    4a38:	0a 2e       	mov	r0, r26
    4a3a:	06 94       	lsr	r0
    4a3c:	57 95       	ror	r21
    4a3e:	47 95       	ror	r20
    4a40:	37 95       	ror	r19
    4a42:	27 95       	ror	r18
    4a44:	ba 95       	dec	r27
    4a46:	c9 f7       	brne	.-14     	; 0x4a3a <__ultoa_invert+0xa2>
    4a48:	62 0f       	add	r22, r18
    4a4a:	73 1f       	adc	r23, r19
    4a4c:	84 1f       	adc	r24, r20
    4a4e:	95 1f       	adc	r25, r21
    4a50:	a0 1d       	adc	r26, r0
    4a52:	08 95       	ret

00004a54 <_exit>:
    4a54:	f8 94       	cli

00004a56 <__stop_program>:
    4a56:	ff cf       	rjmp	.-2      	; 0x4a56 <__stop_program>
