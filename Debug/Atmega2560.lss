
Atmega2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000132  00800200  000049c6  00004a5a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000049c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001371  00800332  00800332  00004b8c  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004b8c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004be8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000698  00000000  00000000  00004c28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a6f7  00000000  00000000  000052c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000024a4  00000000  00000000  0000f9b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000068d9  00000000  00000000  00011e5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001904  00000000  00000000  00018734  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002188  00000000  00000000  0001a038  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a5ca  00000000  00000000  0001c1c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000ba8  00000000  00000000  0002678a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f3 c1       	rjmp	.+998    	; 0x3e8 <__ctors_end>
       2:	00 00       	nop
       4:	11 c2       	rjmp	.+1058   	; 0x428 <__bad_interrupt>
       6:	00 00       	nop
       8:	0f c2       	rjmp	.+1054   	; 0x428 <__bad_interrupt>
       a:	00 00       	nop
       c:	0d c2       	rjmp	.+1050   	; 0x428 <__bad_interrupt>
       e:	00 00       	nop
      10:	0b c2       	rjmp	.+1046   	; 0x428 <__bad_interrupt>
      12:	00 00       	nop
      14:	09 c2       	rjmp	.+1042   	; 0x428 <__bad_interrupt>
      16:	00 00       	nop
      18:	07 c2       	rjmp	.+1038   	; 0x428 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	05 c2       	rjmp	.+1034   	; 0x428 <__bad_interrupt>
      1e:	00 00       	nop
      20:	03 c2       	rjmp	.+1030   	; 0x428 <__bad_interrupt>
      22:	00 00       	nop
      24:	01 c2       	rjmp	.+1026   	; 0x428 <__bad_interrupt>
      26:	00 00       	nop
      28:	ff c1       	rjmp	.+1022   	; 0x428 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	fd c1       	rjmp	.+1018   	; 0x428 <__bad_interrupt>
      2e:	00 00       	nop
      30:	fb c1       	rjmp	.+1014   	; 0x428 <__bad_interrupt>
      32:	00 00       	nop
      34:	88 c6       	rjmp	.+3344   	; 0xd46 <__vector_13>
      36:	00 00       	nop
      38:	f7 c1       	rjmp	.+1006   	; 0x428 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	f5 c1       	rjmp	.+1002   	; 0x428 <__bad_interrupt>
      3e:	00 00       	nop
      40:	f3 c1       	rjmp	.+998    	; 0x428 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 2a 0d 	jmp	0x1a54	; 0x1a54 <__vector_17>
      48:	ef c1       	rjmp	.+990    	; 0x428 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ed c1       	rjmp	.+986    	; 0x428 <__bad_interrupt>
      4e:	00 00       	nop
      50:	eb c1       	rjmp	.+982    	; 0x428 <__bad_interrupt>
      52:	00 00       	nop
      54:	2c c6       	rjmp	.+3160   	; 0xcae <__vector_21>
      56:	00 00       	nop
      58:	e7 c1       	rjmp	.+974    	; 0x428 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	e5 c1       	rjmp	.+970    	; 0x428 <__bad_interrupt>
      5e:	00 00       	nop
      60:	e3 c1       	rjmp	.+966    	; 0x428 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 0f 1d 	jmp	0x3a1e	; 0x3a1e <__vector_25>
      68:	0c 94 6e 1d 	jmp	0x3adc	; 0x3adc <__vector_26>
      6c:	dd c1       	rjmp	.+954    	; 0x428 <__bad_interrupt>
      6e:	00 00       	nop
      70:	db c1       	rjmp	.+950    	; 0x428 <__bad_interrupt>
      72:	00 00       	nop
      74:	d9 c1       	rjmp	.+946    	; 0x428 <__bad_interrupt>
      76:	00 00       	nop
      78:	d7 c1       	rjmp	.+942    	; 0x428 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	d5 c1       	rjmp	.+938    	; 0x428 <__bad_interrupt>
      7e:	00 00       	nop
      80:	d3 c1       	rjmp	.+934    	; 0x428 <__bad_interrupt>
      82:	00 00       	nop
      84:	d1 c1       	rjmp	.+930    	; 0x428 <__bad_interrupt>
      86:	00 00       	nop
      88:	cf c1       	rjmp	.+926    	; 0x428 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	cd c1       	rjmp	.+922    	; 0x428 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 b7 1d 	jmp	0x3b6e	; 0x3b6e <__vector_36>
      94:	0c 94 16 1e 	jmp	0x3c2c	; 0x3c2c <__vector_37>
      98:	c7 c1       	rjmp	.+910    	; 0x428 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	c5 c1       	rjmp	.+906    	; 0x428 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	c3 c1       	rjmp	.+902    	; 0x428 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c1 c1       	rjmp	.+898    	; 0x428 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	bf c1       	rjmp	.+894    	; 0x428 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	bd c1       	rjmp	.+890    	; 0x428 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	bb c1       	rjmp	.+886    	; 0x428 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	b9 c1       	rjmp	.+882    	; 0x428 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	b7 c1       	rjmp	.+878    	; 0x428 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	b5 c1       	rjmp	.+874    	; 0x428 <__bad_interrupt>
      be:	00 00       	nop
      c0:	b3 c1       	rjmp	.+870    	; 0x428 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b1 c1       	rjmp	.+866    	; 0x428 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	af c1       	rjmp	.+862    	; 0x428 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 5f 1e 	jmp	0x3cbe	; 0x3cbe <__vector_51>
      d0:	0c 94 be 1e 	jmp	0x3d7c	; 0x3d7c <__vector_52>
      d4:	a9 c1       	rjmp	.+850    	; 0x428 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	0c 94 07 1f 	jmp	0x3e0e	; 0x3e0e <__vector_54>
      dc:	0c 94 66 1f 	jmp	0x3ecc	; 0x3ecc <__vector_55>
      e0:	a3 c1       	rjmp	.+838    	; 0x428 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ba 1a       	sub	r11, r26
      e6:	ba 1a       	sub	r11, r26
      e8:	c1 1a       	sub	r12, r17
      ea:	c1 1a       	sub	r12, r17
      ec:	c8 1a       	sub	r12, r24
      ee:	c8 1a       	sub	r12, r24
      f0:	cf 1a       	sub	r12, r31
      f2:	cf 1a       	sub	r12, r31
      f4:	45 1b       	sub	r20, r21
      f6:	75 1b       	sub	r23, r21
      f8:	ae 1b       	sub	r26, r30
      fa:	de 1b       	sub	r29, r30
      fc:	17 1c       	adc	r1, r7
      fe:	47 1c       	adc	r4, r7
     100:	84 1c       	adc	r8, r4
     102:	b4 1c       	adc	r11, r4

00000104 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     104:	0f 2e       	mov	r0, r31
     106:	ff e7       	ldi	r31, 0x7F	; 127
     108:	af 2e       	mov	r10, r31
     10a:	f5 e1       	ldi	r31, 0x15	; 21
     10c:	bf 2e       	mov	r11, r31
     10e:	f0 2d       	mov	r31, r0
     110:	08 e8       	ldi	r16, 0x88	; 136
     112:	15 e1       	ldi	r17, 0x15	; 21
     114:	88 24       	eor	r8, r8
     116:	8a 94       	dec	r8
     118:	98 2c       	mov	r9, r8
     11a:	33 24       	eor	r3, r3
     11c:	33 94       	inc	r3
     11e:	43 2c       	mov	r4, r3
     120:	73 2c       	mov	r7, r3
     122:	52 c1       	rjmp	.+676    	; 0x3c8 <prvIdleTask+0x2c4>
     124:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
     128:	8f 5f       	subi	r24, 0xFF	; 255
     12a:	80 93 69 15 	sts	0x1569, r24	; 0x801569 <uxSchedulerSuspended>
     12e:	d5 01       	movw	r26, r10
     130:	6c 90       	ld	r6, X
     132:	0f b6       	in	r0, 0x3f	; 63
     134:	f8 94       	cli
     136:	0f 92       	push	r0
     138:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
     13c:	81 50       	subi	r24, 0x01	; 1
     13e:	80 93 69 15 	sts	0x1569, r24	; 0x801569 <uxSchedulerSuspended>
     142:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
     146:	81 11       	cpse	r24, r1
     148:	1a c1       	rjmp	.+564    	; 0x37e <prvIdleTask+0x27a>
     14a:	80 91 74 15 	lds	r24, 0x1574	; 0x801574 <uxCurrentNumberOfTasks>
     14e:	81 11       	cpse	r24, r1
     150:	33 c0       	rjmp	.+102    	; 0x1b8 <prvIdleTask+0xb4>
     152:	15 c1       	rjmp	.+554    	; 0x37e <prvIdleTask+0x27a>
     154:	d8 01       	movw	r26, r16
     156:	15 96       	adiw	r26, 0x05	; 5
     158:	ed 91       	ld	r30, X+
     15a:	fc 91       	ld	r31, X
     15c:	16 97       	sbiw	r26, 0x06	; 6
     15e:	c6 81       	ldd	r28, Z+6	; 0x06
     160:	d7 81       	ldd	r29, Z+7	; 0x07
     162:	ce 01       	movw	r24, r28
     164:	0c 96       	adiw	r24, 0x0c	; 12
     166:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
     16a:	7e 01       	movw	r14, r28
     16c:	b2 e0       	ldi	r27, 0x02	; 2
     16e:	eb 0e       	add	r14, r27
     170:	f1 1c       	adc	r15, r1
     172:	c7 01       	movw	r24, r14
     174:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
     178:	8e 89       	ldd	r24, Y+22	; 0x16
     17a:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
     17e:	98 17       	cp	r25, r24
     180:	10 f4       	brcc	.+4      	; 0x186 <prvIdleTask+0x82>
     182:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	9c 01       	movw	r18, r24
     18a:	22 0f       	add	r18, r18
     18c:	33 1f       	adc	r19, r19
     18e:	22 0f       	add	r18, r18
     190:	33 1f       	adc	r19, r19
     192:	22 0f       	add	r18, r18
     194:	33 1f       	adc	r19, r19
     196:	82 0f       	add	r24, r18
     198:	93 1f       	adc	r25, r19
     19a:	b7 01       	movw	r22, r14
     19c:	89 55       	subi	r24, 0x59	; 89
     19e:	9a 4e       	sbci	r25, 0xEA	; 234
     1a0:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
     1a4:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
     1a8:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
     1ac:	9e 89       	ldd	r25, Y+22	; 0x16
     1ae:	86 89       	ldd	r24, Z+22	; 0x16
     1b0:	98 17       	cp	r25, r24
     1b2:	10 f0       	brcs	.+4      	; 0x1b8 <prvIdleTask+0xb4>
     1b4:	40 92 6e 15 	sts	0x156E, r4	; 0x80156e <xYieldPending>
     1b8:	f8 01       	movw	r30, r16
     1ba:	80 81       	ld	r24, Z
     1bc:	81 11       	cpse	r24, r1
     1be:	ca cf       	rjmp	.-108    	; 0x154 <prvIdleTask+0x50>
     1c0:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
     1c4:	88 23       	and	r24, r24
     1c6:	09 f4       	brne	.+2      	; 0x1ca <prvIdleTask+0xc6>
     1c8:	d4 c0       	rjmp	.+424    	; 0x372 <prvIdleTask+0x26e>
     1ca:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
     1ce:	88 23       	and	r24, r24
     1d0:	09 f4       	brne	.+2      	; 0x1d4 <prvIdleTask+0xd0>
     1d2:	cf c0       	rjmp	.+414    	; 0x372 <prvIdleTask+0x26e>
     1d4:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
     1d8:	81 11       	cpse	r24, r1
     1da:	b1 c0       	rjmp	.+354    	; 0x33e <prvIdleTask+0x23a>
     1dc:	80 91 72 15 	lds	r24, 0x1572	; 0x801572 <xTickCount>
     1e0:	90 91 73 15 	lds	r25, 0x1573	; 0x801573 <xTickCount+0x1>
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	90 93 73 15 	sts	0x1573, r25	; 0x801573 <xTickCount+0x1>
     1ea:	80 93 72 15 	sts	0x1572, r24	; 0x801572 <xTickCount>
     1ee:	c0 90 72 15 	lds	r12, 0x1572	; 0x801572 <xTickCount>
     1f2:	d0 90 73 15 	lds	r13, 0x1573	; 0x801573 <xTickCount+0x1>
     1f6:	c1 14       	cp	r12, r1
     1f8:	d1 04       	cpc	r13, r1
     1fa:	89 f5       	brne	.+98     	; 0x25e <prvIdleTask+0x15a>
     1fc:	80 91 93 15 	lds	r24, 0x1593	; 0x801593 <pxDelayedTaskList>
     200:	90 91 94 15 	lds	r25, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
     204:	20 91 91 15 	lds	r18, 0x1591	; 0x801591 <pxOverflowDelayedTaskList>
     208:	30 91 92 15 	lds	r19, 0x1592	; 0x801592 <pxOverflowDelayedTaskList+0x1>
     20c:	30 93 94 15 	sts	0x1594, r19	; 0x801594 <pxDelayedTaskList+0x1>
     210:	20 93 93 15 	sts	0x1593, r18	; 0x801593 <pxDelayedTaskList>
     214:	90 93 92 15 	sts	0x1592, r25	; 0x801592 <pxOverflowDelayedTaskList+0x1>
     218:	80 93 91 15 	sts	0x1591, r24	; 0x801591 <pxOverflowDelayedTaskList>
     21c:	80 91 6d 15 	lds	r24, 0x156D	; 0x80156d <xNumOfOverflows>
     220:	8f 5f       	subi	r24, 0xFF	; 255
     222:	80 93 6d 15 	sts	0x156D, r24	; 0x80156d <xNumOfOverflows>
     226:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
     22a:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
     22e:	80 81       	ld	r24, Z
     230:	81 11       	cpse	r24, r1
     232:	05 c0       	rjmp	.+10     	; 0x23e <prvIdleTask+0x13a>
     234:	90 92 6b 15 	sts	0x156B, r9	; 0x80156b <xNextTaskUnblockTime+0x1>
     238:	80 92 6a 15 	sts	0x156A, r8	; 0x80156a <xNextTaskUnblockTime>
     23c:	10 c0       	rjmp	.+32     	; 0x25e <prvIdleTask+0x15a>
     23e:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
     242:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
     246:	05 80       	ldd	r0, Z+5	; 0x05
     248:	f6 81       	ldd	r31, Z+6	; 0x06
     24a:	e0 2d       	mov	r30, r0
     24c:	06 80       	ldd	r0, Z+6	; 0x06
     24e:	f7 81       	ldd	r31, Z+7	; 0x07
     250:	e0 2d       	mov	r30, r0
     252:	82 81       	ldd	r24, Z+2	; 0x02
     254:	93 81       	ldd	r25, Z+3	; 0x03
     256:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
     25a:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
     25e:	80 91 6a 15 	lds	r24, 0x156A	; 0x80156a <xNextTaskUnblockTime>
     262:	90 91 6b 15 	lds	r25, 0x156B	; 0x80156b <xNextTaskUnblockTime+0x1>
     266:	c8 16       	cp	r12, r24
     268:	d9 06       	cpc	r13, r25
     26a:	10 f4       	brcc	.+4      	; 0x270 <prvIdleTask+0x16c>
     26c:	25 2c       	mov	r2, r5
     26e:	50 c0       	rjmp	.+160    	; 0x310 <prvIdleTask+0x20c>
     270:	25 2c       	mov	r2, r5
     272:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
     276:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
     27a:	80 81       	ld	r24, Z
     27c:	81 11       	cpse	r24, r1
     27e:	05 c0       	rjmp	.+10     	; 0x28a <prvIdleTask+0x186>
     280:	90 92 6b 15 	sts	0x156B, r9	; 0x80156b <xNextTaskUnblockTime+0x1>
     284:	80 92 6a 15 	sts	0x156A, r8	; 0x80156a <xNextTaskUnblockTime>
     288:	43 c0       	rjmp	.+134    	; 0x310 <prvIdleTask+0x20c>
     28a:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
     28e:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
     292:	05 80       	ldd	r0, Z+5	; 0x05
     294:	f6 81       	ldd	r31, Z+6	; 0x06
     296:	e0 2d       	mov	r30, r0
     298:	c6 81       	ldd	r28, Z+6	; 0x06
     29a:	d7 81       	ldd	r29, Z+7	; 0x07
     29c:	8a 81       	ldd	r24, Y+2	; 0x02
     29e:	9b 81       	ldd	r25, Y+3	; 0x03
     2a0:	c8 16       	cp	r12, r24
     2a2:	d9 06       	cpc	r13, r25
     2a4:	28 f4       	brcc	.+10     	; 0x2b0 <prvIdleTask+0x1ac>
     2a6:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
     2aa:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
     2ae:	30 c0       	rjmp	.+96     	; 0x310 <prvIdleTask+0x20c>
     2b0:	7e 01       	movw	r14, r28
     2b2:	f2 e0       	ldi	r31, 0x02	; 2
     2b4:	ef 0e       	add	r14, r31
     2b6:	f1 1c       	adc	r15, r1
     2b8:	c7 01       	movw	r24, r14
     2ba:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
     2be:	8c 89       	ldd	r24, Y+20	; 0x14
     2c0:	9d 89       	ldd	r25, Y+21	; 0x15
     2c2:	89 2b       	or	r24, r25
     2c4:	21 f0       	breq	.+8      	; 0x2ce <prvIdleTask+0x1ca>
     2c6:	ce 01       	movw	r24, r28
     2c8:	0c 96       	adiw	r24, 0x0c	; 12
     2ca:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
     2ce:	8e 89       	ldd	r24, Y+22	; 0x16
     2d0:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
     2d4:	98 17       	cp	r25, r24
     2d6:	10 f4       	brcc	.+4      	; 0x2dc <prvIdleTask+0x1d8>
     2d8:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	9c 01       	movw	r18, r24
     2e0:	22 0f       	add	r18, r18
     2e2:	33 1f       	adc	r19, r19
     2e4:	22 0f       	add	r18, r18
     2e6:	33 1f       	adc	r19, r19
     2e8:	22 0f       	add	r18, r18
     2ea:	33 1f       	adc	r19, r19
     2ec:	82 0f       	add	r24, r18
     2ee:	93 1f       	adc	r25, r19
     2f0:	b7 01       	movw	r22, r14
     2f2:	89 55       	subi	r24, 0x59	; 89
     2f4:	9a 4e       	sbci	r25, 0xEA	; 234
     2f6:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
     2fa:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
     2fe:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
     302:	9e 89       	ldd	r25, Y+22	; 0x16
     304:	86 89       	ldd	r24, Z+22	; 0x16
     306:	98 17       	cp	r25, r24
     308:	08 f4       	brcc	.+2      	; 0x30c <prvIdleTask+0x208>
     30a:	b3 cf       	rjmp	.-154    	; 0x272 <prvIdleTask+0x16e>
     30c:	27 2c       	mov	r2, r7
     30e:	b1 cf       	rjmp	.-158    	; 0x272 <prvIdleTask+0x16e>
     310:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
     314:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
     318:	86 89       	ldd	r24, Z+22	; 0x16
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	fc 01       	movw	r30, r24
     31e:	ee 0f       	add	r30, r30
     320:	ff 1f       	adc	r31, r31
     322:	ee 0f       	add	r30, r30
     324:	ff 1f       	adc	r31, r31
     326:	ee 0f       	add	r30, r30
     328:	ff 1f       	adc	r31, r31
     32a:	8e 0f       	add	r24, r30
     32c:	9f 1f       	adc	r25, r31
     32e:	fc 01       	movw	r30, r24
     330:	e9 55       	subi	r30, 0x59	; 89
     332:	fa 4e       	sbci	r31, 0xEA	; 234
     334:	80 81       	ld	r24, Z
     336:	82 30       	cpi	r24, 0x02	; 2
     338:	08 f0       	brcs	.+2      	; 0x33c <prvIdleTask+0x238>
     33a:	53 c0       	rjmp	.+166    	; 0x3e2 <prvIdleTask+0x2de>
     33c:	0a c0       	rjmp	.+20     	; 0x352 <prvIdleTask+0x24e>
     33e:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
     342:	8f 5f       	subi	r24, 0xFF	; 255
     344:	80 93 6f 15 	sts	0x156F, r24	; 0x80156f <uxPendedTicks>
     348:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
     34c:	88 23       	and	r24, r24
     34e:	41 f0       	breq	.+16     	; 0x360 <prvIdleTask+0x25c>
     350:	05 c0       	rjmp	.+10     	; 0x35c <prvIdleTask+0x258>
     352:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
     356:	81 11       	cpse	r24, r1
     358:	01 c0       	rjmp	.+2      	; 0x35c <prvIdleTask+0x258>
     35a:	21 10       	cpse	r2, r1
     35c:	70 92 6e 15 	sts	0x156E, r7	; 0x80156e <xYieldPending>
     360:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
     364:	81 50       	subi	r24, 0x01	; 1
     366:	80 93 6f 15 	sts	0x156F, r24	; 0x80156f <uxPendedTicks>
     36a:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
     36e:	81 11       	cpse	r24, r1
     370:	31 cf       	rjmp	.-414    	; 0x1d4 <prvIdleTask+0xd0>
     372:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
     376:	81 30       	cpi	r24, 0x01	; 1
     378:	11 f4       	brne	.+4      	; 0x37e <prvIdleTask+0x27a>
     37a:	0e 94 4f 0c 	call	0x189e	; 0x189e <vPortYield>
     37e:	0f 90       	pop	r0
     380:	0f be       	out	0x3f, r0	; 63
     382:	66 20       	and	r6, r6
     384:	11 f1       	breq	.+68     	; 0x3ca <prvIdleTask+0x2c6>
     386:	0f b6       	in	r0, 0x3f	; 63
     388:	f8 94       	cli
     38a:	0f 92       	push	r0
     38c:	d5 01       	movw	r26, r10
     38e:	15 96       	adiw	r26, 0x05	; 5
     390:	ed 91       	ld	r30, X+
     392:	fc 91       	ld	r31, X
     394:	16 97       	sbiw	r26, 0x06	; 6
     396:	c6 81       	ldd	r28, Z+6	; 0x06
     398:	d7 81       	ldd	r29, Z+7	; 0x07
     39a:	ce 01       	movw	r24, r28
     39c:	02 96       	adiw	r24, 0x02	; 2
     39e:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
     3a2:	80 91 74 15 	lds	r24, 0x1574	; 0x801574 <uxCurrentNumberOfTasks>
     3a6:	81 50       	subi	r24, 0x01	; 1
     3a8:	80 93 74 15 	sts	0x1574, r24	; 0x801574 <uxCurrentNumberOfTasks>
     3ac:	80 91 7e 15 	lds	r24, 0x157E	; 0x80157e <uxTasksDeleted>
     3b0:	81 50       	subi	r24, 0x01	; 1
     3b2:	80 93 7e 15 	sts	0x157E, r24	; 0x80157e <uxTasksDeleted>
     3b6:	0f 90       	pop	r0
     3b8:	0f be       	out	0x3f, r0	; 63
     3ba:	8f 89       	ldd	r24, Y+23	; 0x17
     3bc:	98 8d       	ldd	r25, Y+24	; 0x18
     3be:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortFree>
     3c2:	ce 01       	movw	r24, r28
     3c4:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortFree>
     3c8:	51 2c       	mov	r5, r1
     3ca:	80 91 7e 15 	lds	r24, 0x157E	; 0x80157e <uxTasksDeleted>
     3ce:	81 11       	cpse	r24, r1
     3d0:	a9 ce       	rjmp	.-686    	; 0x124 <prvIdleTask+0x20>
     3d2:	80 91 a7 15 	lds	r24, 0x15A7	; 0x8015a7 <pxReadyTasksLists>
     3d6:	82 30       	cpi	r24, 0x02	; 2
     3d8:	08 f4       	brcc	.+2      	; 0x3dc <prvIdleTask+0x2d8>
     3da:	a1 ce       	rjmp	.-702    	; 0x11e <prvIdleTask+0x1a>
     3dc:	0e 94 4f 0c 	call	0x189e	; 0x189e <vPortYield>
     3e0:	9c ce       	rjmp	.-712    	; 0x11a <prvIdleTask+0x16>
     3e2:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
     3e6:	ba cf       	rjmp	.-140    	; 0x35c <prvIdleTask+0x258>

000003e8 <__ctors_end>:
     3e8:	11 24       	eor	r1, r1
     3ea:	1f be       	out	0x3f, r1	; 63
     3ec:	cf ef       	ldi	r28, 0xFF	; 255
     3ee:	d1 e2       	ldi	r29, 0x21	; 33
     3f0:	de bf       	out	0x3e, r29	; 62
     3f2:	cd bf       	out	0x3d, r28	; 61
     3f4:	00 e0       	ldi	r16, 0x00	; 0
     3f6:	0c bf       	out	0x3c, r16	; 60

000003f8 <__do_copy_data>:
     3f8:	13 e0       	ldi	r17, 0x03	; 3
     3fa:	a0 e0       	ldi	r26, 0x00	; 0
     3fc:	b2 e0       	ldi	r27, 0x02	; 2
     3fe:	e6 ec       	ldi	r30, 0xC6	; 198
     400:	f9 e4       	ldi	r31, 0x49	; 73
     402:	00 e0       	ldi	r16, 0x00	; 0
     404:	0b bf       	out	0x3b, r16	; 59
     406:	02 c0       	rjmp	.+4      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     408:	07 90       	elpm	r0, Z+
     40a:	0d 92       	st	X+, r0
     40c:	a2 33       	cpi	r26, 0x32	; 50
     40e:	b1 07       	cpc	r27, r17
     410:	d9 f7       	brne	.-10     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>

00000412 <__do_clear_bss>:
     412:	26 e1       	ldi	r18, 0x16	; 22
     414:	a2 e3       	ldi	r26, 0x32	; 50
     416:	b3 e0       	ldi	r27, 0x03	; 3
     418:	01 c0       	rjmp	.+2      	; 0x41c <.do_clear_bss_start>

0000041a <.do_clear_bss_loop>:
     41a:	1d 92       	st	X+, r1

0000041c <.do_clear_bss_start>:
     41c:	a3 3a       	cpi	r26, 0xA3	; 163
     41e:	b2 07       	cpc	r27, r18
     420:	e1 f7       	brne	.-8      	; 0x41a <.do_clear_bss_loop>
     422:	29 d1       	rcall	.+594    	; 0x676 <main>
     424:	0c 94 e1 24 	jmp	0x49c2	; 0x49c2 <_exit>

00000428 <__bad_interrupt>:
     428:	eb cd       	rjmp	.-1066   	; 0x0 <__vectors>

0000042a <system_tick>:
     42a:	8f 93       	push	r24
     42c:	8f b7       	in	r24, 0x3f	; 63
     42e:	8f 93       	push	r24
     430:	f8 94       	cli
     432:	80 91 9f 16 	lds	r24, 0x169F	; 0x80169f <__system_time>
     436:	8f 5f       	subi	r24, 0xFF	; 255
     438:	80 93 9f 16 	sts	0x169F, r24	; 0x80169f <__system_time>
     43c:	80 91 a0 16 	lds	r24, 0x16A0	; 0x8016a0 <__system_time+0x1>
     440:	8f 4f       	sbci	r24, 0xFF	; 255
     442:	80 93 a0 16 	sts	0x16A0, r24	; 0x8016a0 <__system_time+0x1>
     446:	80 91 a1 16 	lds	r24, 0x16A1	; 0x8016a1 <__system_time+0x2>
     44a:	8f 4f       	sbci	r24, 0xFF	; 255
     44c:	80 93 a1 16 	sts	0x16A1, r24	; 0x8016a1 <__system_time+0x2>
     450:	80 91 a2 16 	lds	r24, 0x16A2	; 0x8016a2 <__system_time+0x3>
     454:	8f 4f       	sbci	r24, 0xFF	; 255
     456:	80 93 a2 16 	sts	0x16A2, r24	; 0x8016a2 <__system_time+0x3>
     45a:	8f 91       	pop	r24
     45c:	8f bf       	out	0x3f, r24	; 63
     45e:	8f 91       	pop	r24
     460:	08 95       	ret

00000462 <vKeyPadHandler>:
			break;
			
			case IDK_RIGHT: case IDK_LEFT:
			
			taskENTER_CRITICAL(); //////////////////////////////////
			ints[IDD_LASTKEY] = ch;                             ////
     462:	0f e4       	ldi	r16, 0x4F	; 79
     464:	13 e0       	ldi	r17, 0x03	; 3
			taskEXIT_CRITICAL();  //////////////////////////////////
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
     466:	ca e3       	ldi	r28, 0x3A	; 58
     468:	d3 e0       	ldi	r29, 0x03	; 3
			message.idMessage = IDM_RL;
     46a:	68 94       	set
     46c:	dd 24       	eor	r13, r13
     46e:	d2 f8       	bld	r13, 2
			taskENTER_CRITICAL(); //////////////////////////////////
			ints[IDD_LASTKEY] = ch;                             ////
			taskEXIT_CRITICAL();  //////////////////////////////////
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
			message.idMessage = IDM_UPDATE_DISPLAY;
     470:	68 94       	set
     472:	ee 24       	eor	r14, r14
     474:	e1 f8       	bld	r14, 1
			taskENTER_CRITICAL(); //////////////////////////////////
			ints[IDD_LASTKEY] = ch;                             ////
			taskEXIT_CRITICAL();  //////////////////////////////////
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
			message.idMessage = IDM_DOWN;
     476:	0f 2e       	mov	r0, r31
     478:	f3 e0       	ldi	r31, 0x03	; 3
     47a:	ff 2e       	mov	r15, r31
     47c:	f0 2d       	mov	r31, r0
	for( ;; )//=================
	{
		
		do  //tämä silmukka kuormittaa!!!
		{
			xSemaphoreTake( xADC, portMAX_DELAY );
     47e:	20 e0       	ldi	r18, 0x00	; 0
     480:	4f ef       	ldi	r20, 0xFF	; 255
     482:	5f ef       	ldi	r21, 0xFF	; 255
     484:	60 e0       	ldi	r22, 0x00	; 0
     486:	70 e0       	ldi	r23, 0x00	; 0
     488:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <xADC>
     48c:	90 91 40 03 	lds	r25, 0x0340	; 0x800340 <xADC+0x1>
     490:	0e 94 de 10 	call	0x21bc	; 0x21bc <xQueueGenericReceive>
			ch =GetKey();vTaskDelay(1);
     494:	af d4       	rcall	.+2398   	; 0xdf4 <GetKey>
     496:	80 93 3c 03 	sts	0x033C, r24	; 0x80033c <ch.3024>
     49a:	81 e0       	ldi	r24, 0x01	; 1
     49c:	90 e0       	ldi	r25, 0x00	; 0
     49e:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <vTaskDelay>
			xSemaphoreGive( xADC );
     4a2:	60 e0       	ldi	r22, 0x00	; 0
     4a4:	70 e0       	ldi	r23, 0x00	; 0
     4a6:	80 91 3f 03 	lds	r24, 0x033F	; 0x80033f <xADC>
     4aa:	90 91 40 03 	lds	r25, 0x0340	; 0x800340 <xADC+0x1>
     4ae:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <xQueueGive>

		}while (ch == NO_KEY);
     4b2:	80 91 3c 03 	lds	r24, 0x033C	; 0x80033c <ch.3024>
     4b6:	83 36       	cpi	r24, 0x63	; 99
     4b8:	11 f3       	breq	.-60     	; 0x47e <vKeyPadHandler+0x1c>

		switch( ch )
     4ba:	84 30       	cpi	r24, 0x04	; 4
     4bc:	30 f4       	brcc	.+12     	; 0x4ca <vKeyPadHandler+0x68>
     4be:	82 30       	cpi	r24, 0x02	; 2
     4c0:	10 f5       	brcc	.+68     	; 0x506 <vKeyPadHandler+0xa4>
     4c2:	81 30       	cpi	r24, 0x01	; 1
     4c4:	09 f4       	brne	.+2      	; 0x4c8 <vKeyPadHandler+0x66>
     4c6:	37 c0       	rjmp	.+110    	; 0x536 <vKeyPadHandler+0xd4>
     4c8:	da cf       	rjmp	.-76     	; 0x47e <vKeyPadHandler+0x1c>
     4ca:	85 30       	cpi	r24, 0x05	; 5
     4cc:	21 f0       	breq	.+8      	; 0x4d6 <vKeyPadHandler+0x74>
     4ce:	08 f4       	brcc	.+2      	; 0x4d2 <vKeyPadHandler+0x70>
     4d0:	32 c0       	rjmp	.+100    	; 0x536 <vKeyPadHandler+0xd4>
     4d2:	83 36       	cpi	r24, 0x63	; 99
     4d4:	a1 f6       	brne	.-88     	; 0x47e <vKeyPadHandler+0x1c>
		{
			case IDK_SELECT: case NO_KEY:  // näppäinten käyttö
			
			taskENTER_CRITICAL(); //////////////////////////////////
     4d6:	0f b6       	in	r0, 0x3f	; 63
     4d8:	f8 94       	cli
     4da:	0f 92       	push	r0
			ints[IDD_LASTKEY] = ch;                             ////
     4dc:	80 91 3c 03 	lds	r24, 0x033C	; 0x80033c <ch.3024>
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	f8 01       	movw	r30, r16
     4e4:	93 8b       	std	Z+19, r25	; 0x13
     4e6:	82 8b       	std	Z+18, r24	; 0x12
			taskEXIT_CRITICAL();  //////////////////////////////////
     4e8:	0f 90       	pop	r0
     4ea:	0f be       	out	0x3f, r0	; 63
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
     4ec:	19 82       	std	Y+1, r1	; 0x01
			message.idMessage = IDM_UPDATE_DISPLAY;
     4ee:	e8 82       	st	Y, r14
			xQueueSend( xDisplay, (void*)&message,0);
     4f0:	20 e0       	ldi	r18, 0x00	; 0
     4f2:	40 e0       	ldi	r20, 0x00	; 0
     4f4:	50 e0       	ldi	r21, 0x00	; 0
     4f6:	be 01       	movw	r22, r28
     4f8:	80 91 41 03 	lds	r24, 0x0341	; 0x800341 <xDisplay>
     4fc:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <xDisplay+0x1>
     500:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <xQueueGenericSend>
			
			break;
     504:	bc cf       	rjmp	.-136    	; 0x47e <vKeyPadHandler+0x1c>
			
			case IDK_DOWN: case IDK_UP:
			
			taskENTER_CRITICAL(); //////////////////////////////////
     506:	0f b6       	in	r0, 0x3f	; 63
     508:	f8 94       	cli
     50a:	0f 92       	push	r0
			ints[IDD_LASTKEY] = ch;                             ////
     50c:	80 91 3c 03 	lds	r24, 0x033C	; 0x80033c <ch.3024>
     510:	90 e0       	ldi	r25, 0x00	; 0
     512:	f8 01       	movw	r30, r16
     514:	93 8b       	std	Z+19, r25	; 0x13
     516:	82 8b       	std	Z+18, r24	; 0x12
			taskEXIT_CRITICAL();  //////////////////////////////////
     518:	0f 90       	pop	r0
     51a:	0f be       	out	0x3f, r0	; 63
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
     51c:	19 82       	std	Y+1, r1	; 0x01
			message.idMessage = IDM_DOWN;
     51e:	f8 82       	st	Y, r15
			xQueueSend( xDisplay, (void*)&message,0);
     520:	20 e0       	ldi	r18, 0x00	; 0
     522:	40 e0       	ldi	r20, 0x00	; 0
     524:	50 e0       	ldi	r21, 0x00	; 0
     526:	be 01       	movw	r22, r28
     528:	80 91 41 03 	lds	r24, 0x0341	; 0x800341 <xDisplay>
     52c:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <xDisplay+0x1>
     530:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <xQueueGenericSend>
			
			break;
     534:	a4 cf       	rjmp	.-184    	; 0x47e <vKeyPadHandler+0x1c>
			
			case IDK_RIGHT: case IDK_LEFT:
			
			taskENTER_CRITICAL(); //////////////////////////////////
     536:	0f b6       	in	r0, 0x3f	; 63
     538:	f8 94       	cli
     53a:	0f 92       	push	r0
			ints[IDD_LASTKEY] = ch;                             ////
     53c:	80 91 3c 03 	lds	r24, 0x033C	; 0x80033c <ch.3024>
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	f8 01       	movw	r30, r16
     544:	93 8b       	std	Z+19, r25	; 0x13
     546:	82 8b       	std	Z+18, r24	; 0x12
			taskEXIT_CRITICAL();  //////////////////////////////////
     548:	0f 90       	pop	r0
     54a:	0f be       	out	0x3f, r0	; 63
			// lähetään viesti lcd-näyttötaskille,jotta se päivittää näytön
			message.data      = 0; // näytön numero
     54c:	19 82       	std	Y+1, r1	; 0x01
			message.idMessage = IDM_RL;
     54e:	d8 82       	st	Y, r13
			xQueueSend( xDisplay, (void*)&message,0);
     550:	20 e0       	ldi	r18, 0x00	; 0
     552:	40 e0       	ldi	r20, 0x00	; 0
     554:	50 e0       	ldi	r21, 0x00	; 0
     556:	be 01       	movw	r22, r28
     558:	80 91 41 03 	lds	r24, 0x0341	; 0x800341 <xDisplay>
     55c:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <xDisplay+0x1>
     560:	0e 94 7a 0d 	call	0x1af4	; 0x1af4 <xQueueGenericSend>

			break;
     564:	8c cf       	rjmp	.-232    	; 0x47e <vKeyPadHandler+0x1c>

00000566 <vDoMeasurements>:
	float avegValue;
	int address = 0;

	static unsigned char  numberOfSensors;
	
	numberOfSensors = GetSensorCount(); // samassa johtimessa lämpöantureiden määrä
     566:	ee d7       	rcall	.+4060   	; 0x1544 <GetSensorCount>
     568:	80 93 39 03 	sts	0x0339, r24	; 0x800339 <numberOfSensors.2972>
static void vDoMeasurements( void *pvParameters )
{
	( void ) pvParameters; // Just to stop compiler warnings.
	float value ;
	float maxValue = 0;
	float minValue = 999;
     56c:	a1 2c       	mov	r10, r1
     56e:	0f 2e       	mov	r0, r31
     570:	f0 ec       	ldi	r31, 0xC0	; 192
     572:	df 2e       	mov	r13, r31
     574:	f0 2d       	mov	r31, r0
     576:	0f 2e       	mov	r0, r31
     578:	f9 e7       	ldi	r31, 0x79	; 121
     57a:	cf 2e       	mov	r12, r31
     57c:	f0 2d       	mov	r31, r0
     57e:	0f 2e       	mov	r0, r31
     580:	f4 e4       	ldi	r31, 0x44	; 68
     582:	bf 2e       	mov	r11, r31
     584:	f0 2d       	mov	r31, r0

static void vDoMeasurements( void *pvParameters )
{
	( void ) pvParameters; // Just to stop compiler warnings.
	float value ;
	float maxValue = 0;
     586:	91 2c       	mov	r9, r1
     588:	81 2c       	mov	r8, r1
     58a:	71 2c       	mov	r7, r1
     58c:	61 2c       	mov	r6, r1
	for( ;; )
	{

		if (numberOfSensors)
		{
			value  = (float)(GetTemperature(0)/1000);
     58e:	0f 2e       	mov	r0, r31
     590:	f8 ee       	ldi	r31, 0xE8	; 232
     592:	2f 2e       	mov	r2, r31
     594:	f3 e0       	ldi	r31, 0x03	; 3
     596:	3f 2e       	mov	r3, r31
     598:	41 2c       	mov	r4, r1
     59a:	51 2c       	mov	r5, r1
     59c:	f0 2d       	mov	r31, r0
			}

			avegValue = (minValue+maxValue)/2;
			
			taskENTER_CRITICAL(); //////////////////////////
			ints[ IDD_TEMP ] = value ;
     59e:	cf e4       	ldi	r28, 0x4F	; 79
     5a0:	d3 e0       	ldi	r29, 0x03	; 3


	for( ;; )
	{

		if (numberOfSensors)
     5a2:	80 91 39 03 	lds	r24, 0x0339	; 0x800339 <numberOfSensors.2972>
     5a6:	88 23       	and	r24, r24
     5a8:	09 f4       	brne	.+2      	; 0x5ac <vDoMeasurements+0x46>
     5aa:	60 c0       	rjmp	.+192    	; 0x66c <vDoMeasurements+0x106>
		{
			value  = (float)(GetTemperature(0)/1000);
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	cb d7       	rcall	.+3990   	; 0x1548 <GetTemperature>
     5b2:	a2 01       	movw	r20, r4
     5b4:	91 01       	movw	r18, r2
     5b6:	0e 94 ab 21 	call	0x4356	; 0x4356 <__divmodsi4>
     5ba:	ca 01       	movw	r24, r20
     5bc:	b9 01       	movw	r22, r18
     5be:	0e 94 4b 20 	call	0x4096	; 0x4096 <__floatsisf>
     5c2:	16 2f       	mov	r17, r22
     5c4:	07 2f       	mov	r16, r23
     5c6:	f8 2e       	mov	r15, r24
     5c8:	e9 2e       	mov	r14, r25

			if (minValue >= value)
     5ca:	26 2f       	mov	r18, r22
     5cc:	37 2f       	mov	r19, r23
     5ce:	48 2f       	mov	r20, r24
     5d0:	59 2f       	mov	r21, r25
     5d2:	6a 2d       	mov	r22, r10
     5d4:	7d 2d       	mov	r23, r13
     5d6:	8c 2d       	mov	r24, r12
     5d8:	9b 2d       	mov	r25, r11
     5da:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <__gesf2>
     5de:	88 23       	and	r24, r24
     5e0:	24 f0       	brlt	.+8      	; 0x5ea <vDoMeasurements+0x84>
			{
				minValue = value;
     5e2:	a1 2e       	mov	r10, r17
     5e4:	d0 2e       	mov	r13, r16
     5e6:	cf 2c       	mov	r12, r15
     5e8:	be 2c       	mov	r11, r14
			}
			if (maxValue < value)
     5ea:	21 2f       	mov	r18, r17
     5ec:	30 2f       	mov	r19, r16
     5ee:	4f 2d       	mov	r20, r15
     5f0:	5e 2d       	mov	r21, r14
     5f2:	69 2d       	mov	r22, r9
     5f4:	78 2d       	mov	r23, r8
     5f6:	87 2d       	mov	r24, r7
     5f8:	96 2d       	mov	r25, r6
     5fa:	0e 94 14 20 	call	0x4028	; 0x4028 <__cmpsf2>
     5fe:	88 23       	and	r24, r24
     600:	24 f4       	brge	.+8      	; 0x60a <vDoMeasurements+0xa4>
			{
				maxValue= value;
     602:	91 2e       	mov	r9, r17
     604:	80 2e       	mov	r8, r16
     606:	7f 2c       	mov	r7, r15
     608:	6e 2c       	mov	r6, r14
			}

			avegValue = (minValue+maxValue)/2;
			
			taskENTER_CRITICAL(); //////////////////////////
     60a:	0f b6       	in	r0, 0x3f	; 63
     60c:	f8 94       	cli
     60e:	0f 92       	push	r0
			ints[ IDD_TEMP ] = value ;
     610:	61 2f       	mov	r22, r17
     612:	70 2f       	mov	r23, r16
     614:	8f 2d       	mov	r24, r15
     616:	9e 2d       	mov	r25, r14
     618:	0e 94 18 20 	call	0x4030	; 0x4030 <__fixsfsi>
     61c:	7b 87       	std	Y+11, r23	; 0x0b
     61e:	6a 87       	std	Y+10, r22	; 0x0a
			ints[IDD_MIN] = minValue;
     620:	6a 2d       	mov	r22, r10
     622:	7d 2d       	mov	r23, r13
     624:	8c 2d       	mov	r24, r12
     626:	9b 2d       	mov	r25, r11
     628:	0e 94 18 20 	call	0x4030	; 0x4030 <__fixsfsi>
     62c:	7f 87       	std	Y+15, r23	; 0x0f
     62e:	6e 87       	std	Y+14, r22	; 0x0e
			ints[IDD_MAX] = maxValue;
     630:	69 2d       	mov	r22, r9
     632:	78 2d       	mov	r23, r8
     634:	87 2d       	mov	r24, r7
     636:	96 2d       	mov	r25, r6
     638:	0e 94 18 20 	call	0x4030	; 0x4030 <__fixsfsi>
     63c:	79 8b       	std	Y+17, r23	; 0x11
     63e:	68 8b       	std	Y+16, r22	; 0x10
			ints[IDD_AVE] = avegValue;					 ////
     640:	2a 2d       	mov	r18, r10
     642:	3d 2d       	mov	r19, r13
     644:	4c 2d       	mov	r20, r12
     646:	5b 2d       	mov	r21, r11
     648:	69 2d       	mov	r22, r9
     64a:	78 2d       	mov	r23, r8
     64c:	87 2d       	mov	r24, r7
     64e:	96 2d       	mov	r25, r6
     650:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <__addsf3>
     654:	20 e0       	ldi	r18, 0x00	; 0
     656:	30 e0       	ldi	r19, 0x00	; 0
     658:	40 e0       	ldi	r20, 0x00	; 0
     65a:	5f e3       	ldi	r21, 0x3F	; 63
     65c:	0e 94 ff 20 	call	0x41fe	; 0x41fe <__mulsf3>
     660:	0e 94 18 20 	call	0x4030	; 0x4030 <__fixsfsi>
     664:	7d 87       	std	Y+13, r23	; 0x0d
     666:	6c 87       	std	Y+12, r22	; 0x0c
			taskEXIT_CRITICAL(); ///////////////////////////
     668:	0f 90       	pop	r0
     66a:	0f be       	out	0x3f, r0	; 63
		}
		
		vTaskDelay(1000);
     66c:	88 ee       	ldi	r24, 0xE8	; 232
     66e:	93 e0       	ldi	r25, 0x03	; 3
     670:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <vTaskDelay>
	}
     674:	96 cf       	rjmp	.-212    	; 0x5a2 <vDoMeasurements+0x3c>

00000676 <main>:

xComPortHandle xSerialPort;
//--------------------------------------------------------
// pääohjelma luo taskit ja käynnistää systeemin
int main( void )
{
     676:	af 92       	push	r10
     678:	bf 92       	push	r11
     67a:	cf 92       	push	r12
     67c:	df 92       	push	r13
     67e:	ef 92       	push	r14
     680:	ff 92       	push	r15
     682:	0f 93       	push	r16
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	cd b7       	in	r28, 0x3d	; 61
     68c:	de b7       	in	r29, 0x3e	; 62
     68e:	a2 97       	sbiw	r28, 0x22	; 34
     690:	0f b6       	in	r0, 0x3f	; 63
     692:	f8 94       	cli
     694:	de bf       	out	0x3e, r29	; 62
     696:	0f be       	out	0x3f, r0	; 63
     698:	cd bf       	out	0x3d, r28	; 61
	xDisplay = xQueueCreate( 2, sizeof(DISPLAY_MESSAGE));// luodaan postilaatikko näyttötaskille
     69a:	40 e0       	ldi	r20, 0x00	; 0
     69c:	62 e0       	ldi	r22, 0x02	; 2
     69e:	82 e0       	ldi	r24, 0x02	; 2
     6a0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <xQueueGenericCreate>
     6a4:	90 93 42 03 	sts	0x0342, r25	; 0x800342 <xDisplay+0x1>
     6a8:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <xDisplay>

	vSemaphoreCreateBinary( xADC );// luodaan semafori
     6ac:	43 e0       	ldi	r20, 0x03	; 3
     6ae:	60 e0       	ldi	r22, 0x00	; 0
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <xQueueGenericCreate>
     6b6:	90 93 40 03 	sts	0x0340, r25	; 0x800340 <xADC+0x1>
     6ba:	80 93 3f 03 	sts	0x033F, r24	; 0x80033f <xADC>
     6be:	00 97       	sbiw	r24, 0x00	; 0
     6c0:	21 f0       	breq	.+8      	; 0x6ca <main+0x54>
     6c2:	60 e0       	ldi	r22, 0x00	; 0
     6c4:	70 e0       	ldi	r23, 0x00	; 0
     6c6:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <xQueueGive>
	vSemaphoreCreateBinary(xClock);
     6ca:	43 e0       	ldi	r20, 0x03	; 3
     6cc:	60 e0       	ldi	r22, 0x00	; 0
     6ce:	81 e0       	ldi	r24, 0x01	; 1
     6d0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <xQueueGenericCreate>
     6d4:	90 93 3e 03 	sts	0x033E, r25	; 0x80033e <xClock+0x1>
     6d8:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <xClock>
     6dc:	00 97       	sbiw	r24, 0x00	; 0
     6de:	21 f0       	breq	.+8      	; 0x6e8 <main+0x72>
     6e0:	60 e0       	ldi	r22, 0x00	; 0
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <xQueueGive>

	// alustetaan sarjaportti
	xSerialPort = xSerialPortInitMinimal(0, mainCOM_BAUD_RATE, comBUFFER_LEN ,10);
     6e8:	0f 2e       	mov	r0, r31
     6ea:	fa e0       	ldi	r31, 0x0A	; 10
     6ec:	ef 2e       	mov	r14, r31
     6ee:	f1 2c       	mov	r15, r1
     6f0:	f0 2d       	mov	r31, r0
     6f2:	02 e3       	ldi	r16, 0x32	; 50
     6f4:	10 e0       	ldi	r17, 0x00	; 0
     6f6:	20 e8       	ldi	r18, 0x80	; 128
     6f8:	35 e2       	ldi	r19, 0x25	; 37
     6fa:	40 e0       	ldi	r20, 0x00	; 0
     6fc:	50 e0       	ldi	r21, 0x00	; 0
     6fe:	60 e0       	ldi	r22, 0x00	; 0
     700:	ce 01       	movw	r24, r28
     702:	01 96       	adiw	r24, 0x01	; 1
     704:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <xSerialPortInitMinimal>
     708:	82 e2       	ldi	r24, 0x22	; 34
     70a:	fe 01       	movw	r30, r28
     70c:	31 96       	adiw	r30, 0x01	; 1
     70e:	ad ec       	ldi	r26, 0xCD	; 205
     710:	b5 e1       	ldi	r27, 0x15	; 21
     712:	01 90       	ld	r0, Z+
     714:	0d 92       	st	X+, r0
     716:	8a 95       	dec	r24
     718:	e1 f7       	brne	.-8      	; 0x712 <main+0x9c>
	lcd_init(LCD_DISP_ON);  // lcd-kuntoon
     71a:	8c e0       	ldi	r24, 0x0C	; 12
     71c:	6c d4       	rcall	.+2264   	; 0xff6 <lcd_init>

	// luodaan taskit
	xTaskCreate( vLcdHandler, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     71e:	a1 2c       	mov	r10, r1
     720:	b1 2c       	mov	r11, r1
     722:	c1 2c       	mov	r12, r1
     724:	d1 2c       	mov	r13, r1
     726:	e1 2c       	mov	r14, r1
     728:	f1 2c       	mov	r15, r1
     72a:	02 e0       	ldi	r16, 0x02	; 2
     72c:	20 e0       	ldi	r18, 0x00	; 0
     72e:	30 e0       	ldi	r19, 0x00	; 0
     730:	44 e6       	ldi	r20, 0x64	; 100
     732:	50 e0       	ldi	r21, 0x00	; 0
     734:	60 e0       	ldi	r22, 0x00	; 0
     736:	70 e0       	ldi	r23, 0x00	; 0
     738:	80 e3       	ldi	r24, 0x30	; 48
     73a:	94 e0       	ldi	r25, 0x04	; 4
     73c:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <xTaskGenericCreate>
	xTaskCreate( vDoMeasurements, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     740:	20 e0       	ldi	r18, 0x00	; 0
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	44 e6       	ldi	r20, 0x64	; 100
     746:	50 e0       	ldi	r21, 0x00	; 0
     748:	60 e0       	ldi	r22, 0x00	; 0
     74a:	70 e0       	ldi	r23, 0x00	; 0
     74c:	83 eb       	ldi	r24, 0xB3	; 179
     74e:	92 e0       	ldi	r25, 0x02	; 2
     750:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <xTaskGenericCreate>
	xTaskCreate( vKeyPadHandler, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     754:	20 e0       	ldi	r18, 0x00	; 0
     756:	30 e0       	ldi	r19, 0x00	; 0
     758:	44 e6       	ldi	r20, 0x64	; 100
     75a:	50 e0       	ldi	r21, 0x00	; 0
     75c:	60 e0       	ldi	r22, 0x00	; 0
     75e:	70 e0       	ldi	r23, 0x00	; 0
     760:	81 e3       	ldi	r24, 0x31	; 49
     762:	92 e0       	ldi	r25, 0x02	; 2
     764:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <xTaskGenericCreate>
	xTaskCreate( vClock, 0, configMINIMAL_STACK_SIZE, 0,  (tskIDLE_PRIORITY + 2), NULL );
     768:	20 e0       	ldi	r18, 0x00	; 0
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	44 e6       	ldi	r20, 0x64	; 100
     76e:	50 e0       	ldi	r21, 0x00	; 0
     770:	60 e0       	ldi	r22, 0x00	; 0
     772:	70 e0       	ldi	r23, 0x00	; 0
     774:	8d ef       	ldi	r24, 0xFD	; 253
     776:	95 e0       	ldi	r25, 0x05	; 5
     778:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <xTaskGenericCreate>

	vTaskStartScheduler();  // ajastus päälle
     77c:	0e 94 18 15 	call	0x2a30	; 0x2a30 <vTaskStartScheduler>


	return 0;
}
     780:	80 e0       	ldi	r24, 0x00	; 0
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	a2 96       	adiw	r28, 0x22	; 34
     786:	0f b6       	in	r0, 0x3f	; 63
     788:	f8 94       	cli
     78a:	de bf       	out	0x3e, r29	; 62
     78c:	0f be       	out	0x3f, r0	; 63
     78e:	cd bf       	out	0x3d, r28	; 61
     790:	df 91       	pop	r29
     792:	cf 91       	pop	r28
     794:	1f 91       	pop	r17
     796:	0f 91       	pop	r16
     798:	ff 90       	pop	r15
     79a:	ef 90       	pop	r14
     79c:	df 90       	pop	r13
     79e:	cf 90       	pop	r12
     7a0:	bf 90       	pop	r11
     7a2:	af 90       	pop	r10
     7a4:	08 95       	ret

000007a6 <ShowTime>:
}



void ShowTime(void)
{
     7a6:	0f 93       	push	r16
     7a8:	1f 93       	push	r17
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
     7ae:	cd b7       	in	r28, 0x3d	; 61
     7b0:	de b7       	in	r29, 0x3e	; 62
     7b2:	28 97       	sbiw	r28, 0x08	; 8
     7b4:	0f b6       	in	r0, 0x3f	; 63
     7b6:	f8 94       	cli
     7b8:	de bf       	out	0x3e, r29	; 62
     7ba:	0f be       	out	0x3f, r0	; 63
     7bc:	cd bf       	out	0x3d, r28	; 61
	char  szVariable[8];  // muuttujan arvo tulostetaan tähän

	lcd_gotoxy(0,0);
     7be:	60 e0       	ldi	r22, 0x00	; 0
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	e9 d3       	rcall	.+2002   	; 0xf96 <lcd_gotoxy>
	
	// tunnit
	if( tietoKanta[IDD_HOUR] < 10)
     7c4:	80 91 49 03 	lds	r24, 0x0349	; 0x800349 <tietoKanta+0x6>
     7c8:	90 91 4a 03 	lds	r25, 0x034A	; 0x80034a <tietoKanta+0x7>
     7cc:	0a 97       	sbiw	r24, 0x0a	; 10
     7ce:	14 f4       	brge	.+4      	; 0x7d4 <ShowTime+0x2e>
	lcd_putc('0');
     7d0:	80 e3       	ldi	r24, 0x30	; 48
     7d2:	fe d3       	rcall	.+2044   	; 0xfd0 <lcd_putc>
	
	itoa(tietoKanta[IDD_HOUR],szVariable,10);
     7d4:	03 e4       	ldi	r16, 0x43	; 67
     7d6:	13 e0       	ldi	r17, 0x03	; 3
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     7d8:	4a e0       	ldi	r20, 0x0A	; 10
     7da:	be 01       	movw	r22, r28
     7dc:	6f 5f       	subi	r22, 0xFF	; 255
     7de:	7f 4f       	sbci	r23, 0xFF	; 255
     7e0:	f8 01       	movw	r30, r16
     7e2:	86 81       	ldd	r24, Z+6	; 0x06
     7e4:	97 81       	ldd	r25, Z+7	; 0x07
     7e6:	0e 94 ee 21 	call	0x43dc	; 0x43dc <__itoa_ncheck>
	lcd_puts(szVariable);
     7ea:	ce 01       	movw	r24, r28
     7ec:	01 96       	adiw	r24, 0x01	; 1
	lcd_putc(':');
     7ee:	f4 d3       	rcall	.+2024   	; 0xfd8 <lcd_puts>
     7f0:	8a e3       	ldi	r24, 0x3A	; 58
     7f2:	ee d3       	rcall	.+2012   	; 0xfd0 <lcd_putc>
	
	// minuutit
	if( tietoKanta[IDD_MINU] < 10)
     7f4:	f8 01       	movw	r30, r16
     7f6:	84 81       	ldd	r24, Z+4	; 0x04
     7f8:	95 81       	ldd	r25, Z+5	; 0x05
     7fa:	0a 97       	sbiw	r24, 0x0a	; 10
	lcd_putc('0');
     7fc:	14 f4       	brge	.+4      	; 0x802 <ShowTime+0x5c>
     7fe:	80 e3       	ldi	r24, 0x30	; 48
     800:	e7 d3       	rcall	.+1998   	; 0xfd0 <lcd_putc>
	
	itoa(tietoKanta[IDD_MINU],szVariable,10);
     802:	03 e4       	ldi	r16, 0x43	; 67
     804:	13 e0       	ldi	r17, 0x03	; 3
     806:	4a e0       	ldi	r20, 0x0A	; 10
     808:	be 01       	movw	r22, r28
     80a:	6f 5f       	subi	r22, 0xFF	; 255
     80c:	7f 4f       	sbci	r23, 0xFF	; 255
     80e:	f8 01       	movw	r30, r16
     810:	84 81       	ldd	r24, Z+4	; 0x04
     812:	95 81       	ldd	r25, Z+5	; 0x05
     814:	0e 94 ee 21 	call	0x43dc	; 0x43dc <__itoa_ncheck>
	lcd_puts(szVariable);
     818:	ce 01       	movw	r24, r28
     81a:	01 96       	adiw	r24, 0x01	; 1
     81c:	dd d3       	rcall	.+1978   	; 0xfd8 <lcd_puts>
	lcd_putc(':');
     81e:	8a e3       	ldi	r24, 0x3A	; 58
     820:	d7 d3       	rcall	.+1966   	; 0xfd0 <lcd_putc>
	
	// sekunnit
	if( tietoKanta[IDD_SEC] < 10)
     822:	f8 01       	movw	r30, r16
     824:	82 81       	ldd	r24, Z+2	; 0x02
     826:	93 81       	ldd	r25, Z+3	; 0x03
     828:	0a 97       	sbiw	r24, 0x0a	; 10
     82a:	14 f4       	brge	.+4      	; 0x830 <ShowTime+0x8a>
	lcd_putc('0');
     82c:	80 e3       	ldi	r24, 0x30	; 48
     82e:	d0 d3       	rcall	.+1952   	; 0xfd0 <lcd_putc>
     830:	4a e0       	ldi	r20, 0x0A	; 10
     832:	be 01       	movw	r22, r28
     834:	6f 5f       	subi	r22, 0xFF	; 255
     836:	7f 4f       	sbci	r23, 0xFF	; 255
     838:	80 91 45 03 	lds	r24, 0x0345	; 0x800345 <tietoKanta+0x2>
     83c:	90 91 46 03 	lds	r25, 0x0346	; 0x800346 <tietoKanta+0x3>
     840:	0e 94 ee 21 	call	0x43dc	; 0x43dc <__itoa_ncheck>
	
	itoa(tietoKanta[IDD_SEC],szVariable,10);
	lcd_puts(szVariable);
     844:	ce 01       	movw	r24, r28
     846:	01 96       	adiw	r24, 0x01	; 1
     848:	c7 d3       	rcall	.+1934   	; 0xfd8 <lcd_puts>
     84a:	28 96       	adiw	r28, 0x08	; 8
	
	
	
}
     84c:	0f b6       	in	r0, 0x3f	; 63
     84e:	f8 94       	cli
     850:	de bf       	out	0x3e, r29	; 62
     852:	0f be       	out	0x3f, r0	; 63
     854:	cd bf       	out	0x3d, r28	; 61
     856:	df 91       	pop	r29
     858:	cf 91       	pop	r28
     85a:	1f 91       	pop	r17
     85c:	0f 91       	pop	r16
     85e:	08 95       	ret

00000860 <vLcdHandler>:
     860:	cf 93       	push	r28
	}
	
}
//--------------------- lcd-näyttöä päivittävä taski -------------------------------
static void vLcdHandler( void *pvParameters )
{
     862:	df 93       	push	r29
     864:	cd b7       	in	r28, 0x3d	; 61
     866:	de b7       	in	r29, 0x3e	; 62
     868:	28 97       	sbiw	r28, 0x08	; 8
     86a:	0f b6       	in	r0, 0x3f	; 63
     86c:	f8 94       	cli
     86e:	de bf       	out	0x3e, r29	; 62
     870:	0f be       	out	0x3f, r0	; 63
     872:	cd bf       	out	0x3d, r28	; 61
	volatile  char *pChDisplay =0,  // osoitin, jota osoittaa nytn pohjatekstiss olevaan kirjaimeen
	*pChVariable=0; // osoitin, jota kytetään muuttujan arvon tulostukseen
	int             i;
	char            szVariable[8]; // muuttujan arvo tulostetaan tähän
	static DISPLAY_MESSAGE message;
	bool skip = false;
     874:	91 2c       	mov	r9, r1

	static char *pDisplay[] = {"%t	\ntemp:%i05C"};//no key
	static char *pDisplay2[] = {"MAX:%i08   \nMIN:%i07"};//up or down
	static char *pDisplay3[] = {"cl..cl%i03 Ave:%i06   \nMin-Max=%i07-%i08"};//right or left
	
	volatile  char *pChDisplay =0,  // osoitin, jota osoittaa nytn pohjatekstiss olevaan kirjaimeen
     876:	00 e0       	ldi	r16, 0x00	; 0
     878:	10 e0       	ldi	r17, 0x00	; 0
	
	
	// taskilla tulee aina  olla ikisilmukka
	for( ;; )//.................
	{
		xSemaphoreTake(xDisplay, portMAX_DELAY);
     87a:	d1 2c       	mov	r13, r1
					}
					
					if(!skip)	{
						// tulostetaan muuttuja
						pChVariable = szVariable;
						while(*pChVariable != 0)
     87c:	cd 2c       	mov	r12, r13
						}
					}
				}
				else if(*pChDisplay == '\n')
				{
					lcd_gotoxy(0, 1);
     87e:	bb 24       	eor	r11, r11
     880:	b3 94       	inc	r11
			break;
			
			case IDM_DOWN:
			
			if( message.data == 0 )
			pChDisplay = pDisplay2[0];
     882:	0f 2e       	mov	r0, r31
     884:	ff e0       	ldi	r31, 0x0F	; 15
     886:	2f 2e       	mov	r2, r31
     888:	f2 e0       	ldi	r31, 0x02	; 2
     88a:	3f 2e       	mov	r3, r31
     88c:	f0 2d       	mov	r31, r0
						
						case 't':
						
						taskENTER_CRITICAL();
						ShowTime();
						taskEXIT_CRITICAL();
     88e:	ab 2c       	mov	r10, r11
		switch( message.idMessage)
		{
			
			case IDM_UPDATE_DISPLAY: case NO_KEY:
			if( message.data == 0 )
			pChDisplay = pDisplay[0];
     890:	0f 2e       	mov	r0, r31
     892:	f0 e0       	ldi	r31, 0x00	; 0
     894:	4f 2e       	mov	r4, r31
     896:	f2 e0       	ldi	r31, 0x02	; 2
     898:	5f 2e       	mov	r5, r31
     89a:	f0 2d       	mov	r31, r0
			break;
			
			case IDM_RL:
			
			if( message.data == 0 )
			pChDisplay = pDisplay3[0];
     89c:	0f 2e       	mov	r0, r31
     89e:	f4 e2       	ldi	r31, 0x24	; 36
     8a0:	6f 2e       	mov	r6, r31
     8a2:	f2 e0       	ldi	r31, 0x02	; 2
     8a4:	7f 2e       	mov	r7, r31
     8a6:	f0 2d       	mov	r31, r0
	
	
	// taskilla tulee aina  olla ikisilmukka
	for( ;; )//.................
	{
		xSemaphoreTake(xDisplay, portMAX_DELAY);
     8a8:	2d 2d       	mov	r18, r13
     8aa:	4f ef       	ldi	r20, 0xFF	; 255
     8ac:	5f ef       	ldi	r21, 0xFF	; 255
     8ae:	60 e0       	ldi	r22, 0x00	; 0
     8b0:	70 e0       	ldi	r23, 0x00	; 0
     8b2:	80 91 41 03 	lds	r24, 0x0341	; 0x800341 <xDisplay>
     8b6:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <xDisplay+0x1>
     8ba:	0e 94 de 10 	call	0x21bc	; 0x21bc <xQueueGenericReceive>
		xQueueReceive(xDisplay,&message, portMAX_DELAY); // odotetaan viestiä
     8be:	2d 2d       	mov	r18, r13
     8c0:	4f ef       	ldi	r20, 0xFF	; 255
     8c2:	5f ef       	ldi	r21, 0xFF	; 255
     8c4:	67 e3       	ldi	r22, 0x37	; 55
     8c6:	73 e0       	ldi	r23, 0x03	; 3
     8c8:	80 91 41 03 	lds	r24, 0x0341	; 0x800341 <xDisplay>
     8cc:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <xDisplay+0x1>
     8d0:	0e 94 de 10 	call	0x21bc	; 0x21bc <xQueueGenericReceive>
		

		switch( message.idMessage)
     8d4:	80 91 37 03 	lds	r24, 0x0337	; 0x800337 <message.2984>
     8d8:	83 30       	cpi	r24, 0x03	; 3
     8da:	09 f4       	brne	.+2      	; 0x8de <vLcdHandler+0x7e>
     8dc:	8d c0       	rjmp	.+282    	; 0x9f8 <vLcdHandler+0x198>
     8de:	18 f4       	brcc	.+6      	; 0x8e6 <vLcdHandler+0x86>
     8e0:	82 30       	cpi	r24, 0x02	; 2
     8e2:	39 f0       	breq	.+14     	; 0x8f2 <vLcdHandler+0x92>
     8e4:	6a c1       	rjmp	.+724    	; 0xbba <vLcdHandler+0x35a>
     8e6:	84 30       	cpi	r24, 0x04	; 4
     8e8:	09 f4       	brne	.+2      	; 0x8ec <vLcdHandler+0x8c>
     8ea:	fd c0       	rjmp	.+506    	; 0xae6 <vLcdHandler+0x286>
     8ec:	83 36       	cpi	r24, 0x63	; 99
     8ee:	09 f0       	breq	.+2      	; 0x8f2 <vLcdHandler+0x92>
     8f0:	64 c1       	rjmp	.+712    	; 0xbba <vLcdHandler+0x35a>
		{
			
			case IDM_UPDATE_DISPLAY: case NO_KEY:
			if( message.data == 0 )
     8f2:	80 91 38 03 	lds	r24, 0x0338	; 0x800338 <message.2984+0x1>
     8f6:	81 11       	cpse	r24, r1
     8f8:	01 c0       	rjmp	.+2      	; 0x8fc <vLcdHandler+0x9c>
			pChDisplay = pDisplay[0];
     8fa:	82 01       	movw	r16, r4
			lcd_clrscr();
     8fc:	60 d3       	rcall	.+1728   	; 0xfbe <lcd_clrscr>
			
			lcd_gotoxy(0, 0);	// lcd-näytön alkuun
     8fe:	6d 2d       	mov	r22, r13
     900:	8d 2d       	mov	r24, r13
     902:	49 d3       	rcall	.+1682   	; 0xf96 <lcd_gotoxy>
			// tulostetaan näyttö tässä silmukassa
			while(*pChDisplay != 0)
     904:	d8 01       	movw	r26, r16
     906:	8c 91       	ld	r24, X
     908:	88 23       	and	r24, r24
     90a:	09 f4       	brne	.+2      	; 0x90e <vLcdHandler+0xae>
     90c:	56 c1       	rjmp	.+684    	; 0xbba <vLcdHandler+0x35a>
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
     90e:	f8 01       	movw	r30, r16
     910:	80 81       	ld	r24, Z
     912:	85 32       	cpi	r24, 0x25	; 37
     914:	09 f0       	breq	.+2      	; 0x918 <vLcdHandler+0xb8>
     916:	59 c0       	rjmp	.+178    	; 0x9ca <vLcdHandler+0x16a>
				{
					pChDisplay++; //ohitetaan %-merkki
     918:	78 01       	movw	r14, r16
     91a:	ff ef       	ldi	r31, 0xFF	; 255
     91c:	ef 1a       	sub	r14, r31
     91e:	ff 0a       	sbc	r15, r31
					// minkä tyypin dataa?
					switch(*pChDisplay)
     920:	d8 01       	movw	r26, r16
     922:	11 96       	adiw	r26, 0x01	; 1
     924:	8c 91       	ld	r24, X
     926:	89 36       	cpi	r24, 0x69	; 105
     928:	19 f0       	breq	.+6      	; 0x930 <vLcdHandler+0xd0>
     92a:	84 37       	cpi	r24, 0x74	; 116
     92c:	59 f1       	breq	.+86     	; 0x984 <vLcdHandler+0x124>
     92e:	32 c0       	rjmp	.+100    	; 0x994 <vLcdHandler+0x134>
					{
						// int-tyypin kokonaislukuja
						// muuttujan arvo poimitaan ints-taulukosta indeksin määräämästä paikasta
						case 'i': pChDisplay++;
						// indeksi annettu muodossa 09, 10,11,..
						i = (*pChDisplay - '0')*10;
     930:	f8 01       	movw	r30, r16
     932:	82 81       	ldd	r24, Z+2	; 0x02
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	c0 97       	sbiw	r24, 0x30	; 48
     938:	fc 01       	movw	r30, r24
     93a:	ee 0f       	add	r30, r30
     93c:	ff 1f       	adc	r31, r31
     93e:	88 0f       	add	r24, r24
     940:	99 1f       	adc	r25, r25
     942:	88 0f       	add	r24, r24
     944:	99 1f       	adc	r25, r25
     946:	88 0f       	add	r24, r24
     948:	99 1f       	adc	r25, r25
     94a:	e8 0f       	add	r30, r24
     94c:	f9 1f       	adc	r31, r25
						pChDisplay++;
     94e:	78 01       	movw	r14, r16
     950:	23 e0       	ldi	r18, 0x03	; 3
     952:	e2 0e       	add	r14, r18
     954:	f1 1c       	adc	r15, r1
						i +=  (*pChDisplay- '0'); // indeksi ints-taulukkoon
     956:	d8 01       	movw	r26, r16
     958:	13 96       	adiw	r26, 0x03	; 3
     95a:	8c 91       	ld	r24, X
						taskENTER_CRITICAL();
     95c:	0f b6       	in	r0, 0x3f	; 63
     95e:	f8 94       	cli
     960:	0f 92       	push	r0
						itoa(ints[i],szVariable,10);
     962:	e8 0f       	add	r30, r24
     964:	f1 1d       	adc	r31, r1
     966:	ee 0f       	add	r30, r30
     968:	ff 1f       	adc	r31, r31
     96a:	e1 51       	subi	r30, 0x11	; 17
     96c:	fd 4f       	sbci	r31, 0xFD	; 253
     96e:	4a e0       	ldi	r20, 0x0A	; 10
     970:	be 01       	movw	r22, r28
     972:	6f 5f       	subi	r22, 0xFF	; 255
     974:	7f 4f       	sbci	r23, 0xFF	; 255
     976:	80 81       	ld	r24, Z
     978:	91 81       	ldd	r25, Z+1	; 0x01
     97a:	0e 94 ee 21 	call	0x43dc	; 0x43dc <__itoa_ncheck>
						taskEXIT_CRITICAL();
     97e:	0f 90       	pop	r0
     980:	0f be       	out	0x3f, r0	; 63
     982:	0a c0       	rjmp	.+20     	; 0x998 <vLcdHandler+0x138>
						
						break;
						
						case 't':
						
						taskENTER_CRITICAL();
     984:	0f b6       	in	r0, 0x3f	; 63
     986:	f8 94       	cli
						ShowTime();
     988:	0f 92       	push	r0
     98a:	0d df       	rcall	.-486    	; 0x7a6 <ShowTime>
						taskEXIT_CRITICAL();
     98c:	0f 90       	pop	r0
     98e:	0f be       	out	0x3f, r0	; 63
     990:	9a 2c       	mov	r9, r10
     992:	29 c0       	rjmp	.+82     	; 0x9e6 <vLcdHandler+0x186>
						break;
						
						
					}
					// tulostetaan muuttuja
					if(!skip)	{
     994:	91 10       	cpse	r9, r1
     996:	27 c0       	rjmp	.+78     	; 0x9e6 <vLcdHandler+0x186>
						pChVariable = szVariable;
						while(*pChVariable != 0)
     998:	89 81       	ldd	r24, Y+1	; 0x01
     99a:	88 23       	and	r24, r24
     99c:	19 f1       	breq	.+70     	; 0x9e4 <vLcdHandler+0x184>
     99e:	8e 01       	movw	r16, r28
     9a0:	0f 5f       	subi	r16, 0xFF	; 255
						{
							lcd_putc(*pChVariable); // merkki näkyviin
     9a2:	1f 4f       	sbci	r17, 0xFF	; 255
     9a4:	f8 01       	movw	r30, r16
     9a6:	80 81       	ld	r24, Z
     9a8:	13 d3       	rcall	.+1574   	; 0xfd0 <lcd_putc>
							while(xSerialPutChar(&xSerialPort, *pChVariable)==pdFAIL);//odotetaan kunnes jonoon mahtuu
     9aa:	d8 01       	movw	r26, r16
     9ac:	6c 91       	ld	r22, X
     9ae:	8d ec       	ldi	r24, 0xCD	; 205
     9b0:	95 e1       	ldi	r25, 0x15	; 21
     9b2:	0e 94 47 1a 	call	0x348e	; 0x348e <xSerialPutChar>
     9b6:	88 23       	and	r24, r24
     9b8:	c1 f3       	breq	.-16     	; 0x9aa <vLcdHandler+0x14a>
							pChVariable++; // seuraava kirjain
     9ba:	0f 5f       	subi	r16, 0xFF	; 255
     9bc:	1f 4f       	sbci	r17, 0xFF	; 255
						
					}
					// tulostetaan muuttuja
					if(!skip)	{
						pChVariable = szVariable;
						while(*pChVariable != 0)
     9be:	f8 01       	movw	r30, r16
     9c0:	80 81       	ld	r24, Z
     9c2:	81 11       	cpse	r24, r1
     9c4:	ef cf       	rjmp	.-34     	; 0x9a4 <vLcdHandler+0x144>
     9c6:	9c 2c       	mov	r9, r12
     9c8:	0e c0       	rjmp	.+28     	; 0x9e6 <vLcdHandler+0x186>
							while(xSerialPutChar(&xSerialPort, *pChVariable)==pdFAIL);//odotetaan kunnes jonoon mahtuu
							pChVariable++; // seuraava kirjain
						}
					}
				}
				else if(*pChDisplay == '\n')
     9ca:	80 81       	ld	r24, Z
     9cc:	8a 30       	cpi	r24, 0x0A	; 10
				{
					lcd_gotoxy(0, 1);
     9ce:	29 f4       	brne	.+10     	; 0x9da <vLcdHandler+0x17a>
     9d0:	6a 2d       	mov	r22, r10
     9d2:	8c 2d       	mov	r24, r12
     9d4:	e0 d2       	rcall	.+1472   	; 0xf96 <lcd_gotoxy>
     9d6:	78 01       	movw	r14, r16
				}
				
				else
				lcd_putc(*pChDisplay); // merkki näkyviin
     9d8:	06 c0       	rjmp	.+12     	; 0x9e6 <vLcdHandler+0x186>
     9da:	f8 01       	movw	r30, r16
     9dc:	80 81       	ld	r24, Z
     9de:	f8 d2       	rcall	.+1520   	; 0xfd0 <lcd_putc>
     9e0:	78 01       	movw	r14, r16
     9e2:	01 c0       	rjmp	.+2      	; 0x9e6 <vLcdHandler+0x186>
						
					}
					// tulostetaan muuttuja
					if(!skip)	{
						pChVariable = szVariable;
						while(*pChVariable != 0)
     9e4:	9c 2c       	mov	r9, r12
					lcd_gotoxy(0, 1);
				}
				
				else
				lcd_putc(*pChDisplay); // merkki näkyviin
				pChDisplay++; // seuraava kirjain
     9e6:	87 01       	movw	r16, r14
     9e8:	0f 5f       	subi	r16, 0xFF	; 255
     9ea:	1f 4f       	sbci	r17, 0xFF	; 255
			pChDisplay = pDisplay[0];
			lcd_clrscr();
			
			lcd_gotoxy(0, 0);	// lcd-näytön alkuun
			// tulostetaan näyttö tässä silmukassa
			while(*pChDisplay != 0)
     9ec:	d7 01       	movw	r26, r14
     9ee:	11 96       	adiw	r26, 0x01	; 1
     9f0:	8c 91       	ld	r24, X
     9f2:	81 11       	cpse	r24, r1
     9f4:	8c cf       	rjmp	.-232    	; 0x90e <vLcdHandler+0xae>
     9f6:	e1 c0       	rjmp	.+450    	; 0xbba <vLcdHandler+0x35a>
			
			break;
			
			case IDM_DOWN:
			
			if( message.data == 0 )
     9f8:	80 91 38 03 	lds	r24, 0x0338	; 0x800338 <message.2984+0x1>
			pChDisplay = pDisplay2[0];
     9fc:	81 11       	cpse	r24, r1
			lcd_gotoxy(0, 0);
     9fe:	01 c0       	rjmp	.+2      	; 0xa02 <vLcdHandler+0x1a2>
     a00:	81 01       	movw	r16, r2
     a02:	6d 2d       	mov	r22, r13
     a04:	8d 2d       	mov	r24, r13
			lcd_clrscr();
     a06:	c7 d2       	rcall	.+1422   	; 0xf96 <lcd_gotoxy>
     a08:	da d2       	rcall	.+1460   	; 0xfbe <lcd_clrscr>
			
			while(*pChDisplay != 0)
     a0a:	f8 01       	movw	r30, r16
     a0c:	80 81       	ld	r24, Z
     a0e:	88 23       	and	r24, r24
     a10:	09 f4       	brne	.+2      	; 0xa14 <vLcdHandler+0x1b4>
     a12:	5f c0       	rjmp	.+190    	; 0xad2 <vLcdHandler+0x272>
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
     a14:	d8 01       	movw	r26, r16
     a16:	8c 91       	ld	r24, X
     a18:	85 32       	cpi	r24, 0x25	; 37
     a1a:	09 f0       	breq	.+2      	; 0xa1e <vLcdHandler+0x1be>
     a1c:	45 c0       	rjmp	.+138    	; 0xaa8 <vLcdHandler+0x248>
				{
					pChDisplay++; //ohitetaan %-merkki
					// minkä tyypin dataa?
					switch(*pChDisplay)
     a1e:	11 96       	adiw	r26, 0x01	; 1
     a20:	8c 91       	ld	r24, X
     a22:	11 97       	sbiw	r26, 0x01	; 1
     a24:	89 36       	cpi	r24, 0x69	; 105
     a26:	51 f5       	brne	.+84     	; 0xa7c <vLcdHandler+0x21c>
					{
						// int-tyypin kokonaislukuja
						// muuttujan arvo poimitaan ints-taulukosta indeksin määräämästä paikasta
						case 'i': pChDisplay++;
						// indeksi annettu muodossa 09, 10,11,..
						i = (*pChDisplay - '0')*10;
     a28:	12 96       	adiw	r26, 0x02	; 2
     a2a:	8c 91       	ld	r24, X
     a2c:	90 e0       	ldi	r25, 0x00	; 0
     a2e:	c0 97       	sbiw	r24, 0x30	; 48
     a30:	fc 01       	movw	r30, r24
     a32:	ee 0f       	add	r30, r30
     a34:	ff 1f       	adc	r31, r31
     a36:	88 0f       	add	r24, r24
     a38:	99 1f       	adc	r25, r25
     a3a:	88 0f       	add	r24, r24
     a3c:	99 1f       	adc	r25, r25
     a3e:	88 0f       	add	r24, r24
     a40:	99 1f       	adc	r25, r25
     a42:	e8 0f       	add	r30, r24
     a44:	f9 1f       	adc	r31, r25
						pChDisplay++;
     a46:	78 01       	movw	r14, r16
     a48:	b3 e0       	ldi	r27, 0x03	; 3
     a4a:	eb 0e       	add	r14, r27
     a4c:	f1 1c       	adc	r15, r1
						i +=  (*pChDisplay - '0'); // indeksi ints-taulukkoon
     a4e:	d8 01       	movw	r26, r16
     a50:	13 96       	adiw	r26, 0x03	; 3
     a52:	8c 91       	ld	r24, X
						taskENTER_CRITICAL();
     a54:	0f b6       	in	r0, 0x3f	; 63
     a56:	f8 94       	cli
     a58:	0f 92       	push	r0
						itoa(ints[i],szVariable,10);
     a5a:	e8 0f       	add	r30, r24
     a5c:	f1 1d       	adc	r31, r1
     a5e:	ee 0f       	add	r30, r30
     a60:	ff 1f       	adc	r31, r31
     a62:	e1 51       	subi	r30, 0x11	; 17
     a64:	fd 4f       	sbci	r31, 0xFD	; 253
     a66:	4a e0       	ldi	r20, 0x0A	; 10
     a68:	be 01       	movw	r22, r28
     a6a:	6f 5f       	subi	r22, 0xFF	; 255
     a6c:	7f 4f       	sbci	r23, 0xFF	; 255
     a6e:	80 81       	ld	r24, Z
     a70:	91 81       	ldd	r25, Z+1	; 0x01
     a72:	0e 94 ee 21 	call	0x43dc	; 0x43dc <__itoa_ncheck>
						taskEXIT_CRITICAL();
     a76:	0f 90       	pop	r0
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	06 c0       	rjmp	.+12     	; 0xa88 <vLcdHandler+0x228>
			while(*pChDisplay != 0)
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
				{
					pChDisplay++; //ohitetaan %-merkki
     a7c:	78 01       	movw	r14, r16
     a7e:	bf ef       	ldi	r27, 0xFF	; 255
     a80:	eb 1a       	sub	r14, r27
     a82:	fb 0a       	sbc	r15, r27
						taskEXIT_CRITICAL();
						skip = false;
						break;
					}
					
					if(!skip)	{
     a84:	91 10       	cpse	r9, r1
     a86:	1e c0       	rjmp	.+60     	; 0xac4 <vLcdHandler+0x264>
						// tulostetaan muuttuja
						pChVariable = szVariable;
						while(*pChVariable != 0)
     a88:	89 81       	ldd	r24, Y+1	; 0x01
     a8a:	88 23       	and	r24, r24
     a8c:	d1 f0       	breq	.+52     	; 0xac2 <vLcdHandler+0x262>
     a8e:	8e 01       	movw	r16, r28
     a90:	0f 5f       	subi	r16, 0xFF	; 255
						{
							lcd_putc(*pChVariable); // merkki näkyviin
     a92:	1f 4f       	sbci	r17, 0xFF	; 255
     a94:	f8 01       	movw	r30, r16
     a96:	81 91       	ld	r24, Z+
     a98:	8f 01       	movw	r16, r30
     a9a:	9a d2       	rcall	.+1332   	; 0xfd0 <lcd_putc>
					}
					
					if(!skip)	{
						// tulostetaan muuttuja
						pChVariable = szVariable;
						while(*pChVariable != 0)
     a9c:	d8 01       	movw	r26, r16
     a9e:	8c 91       	ld	r24, X
     aa0:	81 11       	cpse	r24, r1
     aa2:	f8 cf       	rjmp	.-16     	; 0xa94 <vLcdHandler+0x234>
     aa4:	9c 2c       	mov	r9, r12
							
							pChVariable++; // seuraava kirjain
						}
					}
				}
				else if(*pChDisplay == '\n')
     aa6:	0e c0       	rjmp	.+28     	; 0xac4 <vLcdHandler+0x264>
     aa8:	f8 01       	movw	r30, r16
     aaa:	80 81       	ld	r24, Z
				{
					lcd_gotoxy(0, 1);
     aac:	8a 30       	cpi	r24, 0x0A	; 10
     aae:	29 f4       	brne	.+10     	; 0xaba <vLcdHandler+0x25a>
     ab0:	6b 2d       	mov	r22, r11
     ab2:	8c 2d       	mov	r24, r12
     ab4:	70 d2       	rcall	.+1248   	; 0xf96 <lcd_gotoxy>
     ab6:	78 01       	movw	r14, r16
				}
				else
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin
     ab8:	05 c0       	rjmp	.+10     	; 0xac4 <vLcdHandler+0x264>
     aba:	80 81       	ld	r24, Z
     abc:	89 d2       	rcall	.+1298   	; 0xfd0 <lcd_putc>
     abe:	78 01       	movw	r14, r16
     ac0:	01 c0       	rjmp	.+2      	; 0xac4 <vLcdHandler+0x264>
					}
					
					if(!skip)	{
						// tulostetaan muuttuja
						pChVariable = szVariable;
						while(*pChVariable != 0)
     ac2:	9c 2c       	mov	r9, r12
					lcd_gotoxy(0, 1);
				}
				else
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin
				pChDisplay++; // seuraava kirjain
     ac4:	87 01       	movw	r16, r14
     ac6:	0f 5f       	subi	r16, 0xFF	; 255
     ac8:	1f 4f       	sbci	r17, 0xFF	; 255
			if( message.data == 0 )
			pChDisplay = pDisplay2[0];
			lcd_gotoxy(0, 0);
			lcd_clrscr();
			
			while(*pChDisplay != 0)
     aca:	f7 01       	movw	r30, r14
     acc:	81 81       	ldd	r24, Z+1	; 0x01
     ace:	81 11       	cpse	r24, r1
     ad0:	a1 cf       	rjmp	.-190    	; 0xa14 <vLcdHandler+0x1b4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     ad2:	ff ef       	ldi	r31, 0xFF	; 255
     ad4:	23 ed       	ldi	r18, 0xD3	; 211
     ad6:	80 e3       	ldi	r24, 0x30	; 48
     ad8:	f1 50       	subi	r31, 0x01	; 1
     ada:	20 40       	sbci	r18, 0x00	; 0
     adc:	80 40       	sbci	r24, 0x00	; 0
     ade:	e1 f7       	brne	.-8      	; 0xad8 <vLcdHandler+0x278>
     ae0:	00 c0       	rjmp	.+0      	; 0xae2 <vLcdHandler+0x282>
			
			break;
			
			case IDM_RL:
			
			if( message.data == 0 )
     ae2:	00 00       	nop
     ae4:	6a c0       	rjmp	.+212    	; 0xbba <vLcdHandler+0x35a>
     ae6:	80 91 38 03 	lds	r24, 0x0338	; 0x800338 <message.2984+0x1>
			pChDisplay = pDisplay3[0];
     aea:	81 11       	cpse	r24, r1
			lcd_gotoxy(0, 0);
     aec:	01 c0       	rjmp	.+2      	; 0xaf0 <vLcdHandler+0x290>
     aee:	83 01       	movw	r16, r6
     af0:	6d 2d       	mov	r22, r13
     af2:	8d 2d       	mov	r24, r13
			lcd_clrscr();
     af4:	50 d2       	rcall	.+1184   	; 0xf96 <lcd_gotoxy>
     af6:	63 d2       	rcall	.+1222   	; 0xfbe <lcd_clrscr>
			
			
			while(*pChDisplay != 0)
     af8:	d8 01       	movw	r26, r16
     afa:	8c 91       	ld	r24, X
     afc:	88 23       	and	r24, r24
     afe:	09 f4       	brne	.+2      	; 0xb02 <vLcdHandler+0x2a2>
     b00:	5c c0       	rjmp	.+184    	; 0xbba <vLcdHandler+0x35a>
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
     b02:	f8 01       	movw	r30, r16
     b04:	80 81       	ld	r24, Z
     b06:	85 32       	cpi	r24, 0x25	; 37
     b08:	09 f0       	breq	.+2      	; 0xb0c <vLcdHandler+0x2ac>
     b0a:	42 c0       	rjmp	.+132    	; 0xb90 <vLcdHandler+0x330>
				{
					pChDisplay++; //ohitetaan %-merkki
					// minkä tyypin dataa?
					switch(*pChDisplay)
     b0c:	81 81       	ldd	r24, Z+1	; 0x01
     b0e:	89 36       	cpi	r24, 0x69	; 105
     b10:	49 f5       	brne	.+82     	; 0xb64 <vLcdHandler+0x304>
					{
						case 'i': pChDisplay++;
						// indeksi annettu muodossa 09, 10,11,..
						i = (*pChDisplay - '0')*10;
     b12:	82 81       	ldd	r24, Z+2	; 0x02
     b14:	90 e0       	ldi	r25, 0x00	; 0
     b16:	c0 97       	sbiw	r24, 0x30	; 48
     b18:	fc 01       	movw	r30, r24
     b1a:	ee 0f       	add	r30, r30
     b1c:	ff 1f       	adc	r31, r31
     b1e:	88 0f       	add	r24, r24
     b20:	99 1f       	adc	r25, r25
     b22:	88 0f       	add	r24, r24
     b24:	99 1f       	adc	r25, r25
     b26:	88 0f       	add	r24, r24
     b28:	99 1f       	adc	r25, r25
     b2a:	e8 0f       	add	r30, r24
     b2c:	f9 1f       	adc	r31, r25
						pChDisplay++;
     b2e:	78 01       	movw	r14, r16
     b30:	23 e0       	ldi	r18, 0x03	; 3
     b32:	e2 0e       	add	r14, r18
     b34:	f1 1c       	adc	r15, r1
						i +=  (*pChDisplay - '0'); // indeksi ints-taulukkoon
     b36:	d8 01       	movw	r26, r16
     b38:	13 96       	adiw	r26, 0x03	; 3
     b3a:	8c 91       	ld	r24, X
						taskENTER_CRITICAL();
     b3c:	0f b6       	in	r0, 0x3f	; 63
     b3e:	f8 94       	cli
     b40:	0f 92       	push	r0
						itoa(ints[i],szVariable,10);
     b42:	e8 0f       	add	r30, r24
     b44:	f1 1d       	adc	r31, r1
     b46:	ee 0f       	add	r30, r30
     b48:	ff 1f       	adc	r31, r31
     b4a:	e1 51       	subi	r30, 0x11	; 17
     b4c:	fd 4f       	sbci	r31, 0xFD	; 253
     b4e:	4a e0       	ldi	r20, 0x0A	; 10
     b50:	be 01       	movw	r22, r28
     b52:	6f 5f       	subi	r22, 0xFF	; 255
     b54:	7f 4f       	sbci	r23, 0xFF	; 255
     b56:	80 81       	ld	r24, Z
     b58:	91 81       	ldd	r25, Z+1	; 0x01
     b5a:	0e 94 ee 21 	call	0x43dc	; 0x43dc <__itoa_ncheck>
						taskEXIT_CRITICAL();
     b5e:	0f 90       	pop	r0
     b60:	0f be       	out	0x3f, r0	; 63
     b62:	06 c0       	rjmp	.+12     	; 0xb70 <vLcdHandler+0x310>
			while(*pChDisplay != 0)
			{
				// onko muuttujan tulostuspaikka?
				if( *pChDisplay == '%')
				{
					pChDisplay++; //ohitetaan %-merkki
     b64:	78 01       	movw	r14, r16
     b66:	bf ef       	ldi	r27, 0xFF	; 255
     b68:	eb 1a       	sub	r14, r27
						taskEXIT_CRITICAL();
						skip = false;
						break;
					}
					
					if(!skip)
     b6a:	fb 0a       	sbc	r15, r27
     b6c:	91 10       	cpse	r9, r1
					{
						// tulostetaan muuttuja
						pChVariable = szVariable;
						while(*pChVariable != 0)
     b6e:	1e c0       	rjmp	.+60     	; 0xbac <vLcdHandler+0x34c>
     b70:	89 81       	ldd	r24, Y+1	; 0x01
     b72:	88 23       	and	r24, r24
     b74:	d1 f0       	breq	.+52     	; 0xbaa <vLcdHandler+0x34a>
     b76:	8e 01       	movw	r16, r28
     b78:	0f 5f       	subi	r16, 0xFF	; 255
						{
							lcd_putc(*pChVariable); // merkki näkyviin
     b7a:	1f 4f       	sbci	r17, 0xFF	; 255
     b7c:	f8 01       	movw	r30, r16
     b7e:	81 91       	ld	r24, Z+
     b80:	8f 01       	movw	r16, r30
					
					if(!skip)
					{
						// tulostetaan muuttuja
						pChVariable = szVariable;
						while(*pChVariable != 0)
     b82:	26 d2       	rcall	.+1100   	; 0xfd0 <lcd_putc>
     b84:	d8 01       	movw	r26, r16
     b86:	8c 91       	ld	r24, X
     b88:	81 11       	cpse	r24, r1
     b8a:	f8 cf       	rjmp	.-16     	; 0xb7c <vLcdHandler+0x31c>
							lcd_putc(*pChVariable); // merkki näkyviin
							pChVariable++; // seuraava kirjain
						}
					}
				}
				else if(*pChDisplay == '\n')
     b8c:	9c 2c       	mov	r9, r12
     b8e:	0e c0       	rjmp	.+28     	; 0xbac <vLcdHandler+0x34c>
     b90:	f8 01       	movw	r30, r16
     b92:	80 81       	ld	r24, Z
				{
					lcd_gotoxy(0, 1);
     b94:	8a 30       	cpi	r24, 0x0A	; 10
     b96:	29 f4       	brne	.+10     	; 0xba2 <vLcdHandler+0x342>
     b98:	6b 2d       	mov	r22, r11
     b9a:	8c 2d       	mov	r24, r12
     b9c:	fc d1       	rcall	.+1016   	; 0xf96 <lcd_gotoxy>
     b9e:	78 01       	movw	r14, r16
				}
				else
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin
     ba0:	05 c0       	rjmp	.+10     	; 0xbac <vLcdHandler+0x34c>
     ba2:	80 81       	ld	r24, Z
     ba4:	15 d2       	rcall	.+1066   	; 0xfd0 <lcd_putc>
     ba6:	78 01       	movw	r14, r16
     ba8:	01 c0       	rjmp	.+2      	; 0xbac <vLcdHandler+0x34c>
					
					if(!skip)
					{
						// tulostetaan muuttuja
						pChVariable = szVariable;
						while(*pChVariable != 0)
     baa:	9c 2c       	mov	r9, r12
				}
				else
				// näytön pohjateksti
				lcd_putc(*pChDisplay); // merkki näkyviin

				pChDisplay++; // seuraava kirjain
     bac:	87 01       	movw	r16, r14
     bae:	0f 5f       	subi	r16, 0xFF	; 255
     bb0:	1f 4f       	sbci	r17, 0xFF	; 255
			pChDisplay = pDisplay3[0];
			lcd_gotoxy(0, 0);
			lcd_clrscr();
			
			
			while(*pChDisplay != 0)
     bb2:	f7 01       	movw	r30, r14
     bb4:	81 81       	ldd	r24, Z+1	; 0x01
     bb6:	81 11       	cpse	r24, r1
     bb8:	a4 cf       	rjmp	.-184    	; 0xb02 <vLcdHandler+0x2a2>
			break;
			
			default:
			break;
		}
		xSemaphoreGive(xDisplay);
     bba:	60 e0       	ldi	r22, 0x00	; 0
     bbc:	70 e0       	ldi	r23, 0x00	; 0
     bbe:	80 91 41 03 	lds	r24, 0x0341	; 0x800341 <xDisplay>
     bc2:	90 91 42 03 	lds	r25, 0x0342	; 0x800342 <xDisplay+0x1>
     bc6:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <xQueueGive>
	}
     bca:	6e ce       	rjmp	.-804    	; 0x8a8 <vLcdHandler+0x48>

00000bcc <StartTimer>:

void StartTimer( int ticks)
{
	// ks. manuaalia doc2549.pdf sivulta 118 alkaen
	// 0 = stop  1 = clock  2 = clock/8 3 = clock/64  4 = clock/256 5 = clock/1024
	TCCR0B = (1<<FOC0A) | ( 1<<CS02) | (1<<CS00); // prosessorin kellotaajuus/1024   , jos 16MHz => 64 us
     bcc:	95 e8       	ldi	r25, 0x85	; 133
     bce:	95 bd       	out	0x25, r25	; 37
	TIMSK0 |= (1 << OCIE0A); // vertailuarvokeskeytys
     bd0:	ee e6       	ldi	r30, 0x6E	; 110
     bd2:	f0 e0       	ldi	r31, 0x00	; 0
     bd4:	90 81       	ld	r25, Z
     bd6:	92 60       	ori	r25, 0x02	; 2
     bd8:	90 83       	st	Z, r25
	OCR0A = ticks; // laitetaan vertailuarvoksi annettu lukema
     bda:	87 bd       	out	0x27, r24	; 39
	TCNT0 = 0;    // laskuri alkuun
     bdc:	16 bc       	out	0x26, r1	; 38
     bde:	08 95       	ret

00000be0 <StartTimer2>:

void StartTimer2( int ticks)
{
	// ks. manuaalia doc2549.pdf sivulta 118 alkaen
	// 0 = stop  1 = clock  2 = clock/8 3 = clock/64  4 = clock/256 5 = clock/1024
	TCCR2B = (1<<FOC2A) | ( 1<<CS22) | (1<<CS20); // prosessorin kellotaajuus/1024   , jos 16MHz => 64 us
     be0:	95 e8       	ldi	r25, 0x85	; 133
     be2:	90 93 b1 00 	sts	0x00B1, r25	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
	TIMSK2 |= (1 << OCIE2A); // vertailuarvokeskeytys
     be6:	e0 e7       	ldi	r30, 0x70	; 112
     be8:	f0 e0       	ldi	r31, 0x00	; 0
     bea:	90 81       	ld	r25, Z
     bec:	92 60       	ori	r25, 0x02	; 2
     bee:	90 83       	st	Z, r25
	OCR2A = ticks; // laitetaan vertailuarvoksi annettu lukema
     bf0:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
	TCNT2 = 0;    // laskuri alkuun
     bf4:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7000b2>
     bf8:	08 95       	ret

00000bfa <vClock>:
}
static void vClock( void *pvParameters )
{
	( void ) pvParameters; // Just to stop compiler warnings.

	vSemaphoreCreateBinary( xClock );// luodaan semafori
     bfa:	43 e0       	ldi	r20, 0x03	; 3
     bfc:	60 e0       	ldi	r22, 0x00	; 0
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	2b d7       	rcall	.+3670   	; 0x1a58 <xQueueGenericCreate>
     c02:	90 93 3e 03 	sts	0x033E, r25	; 0x80033e <xClock+0x1>
     c06:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <xClock>
     c0a:	00 97       	sbiw	r24, 0x00	; 0
     c0c:	21 f0       	breq	.+8      	; 0xc16 <vClock+0x1c>
     c0e:	60 e0       	ldi	r22, 0x00	; 0
     c10:	70 e0       	ldi	r23, 0x00	; 0
     c12:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <xQueueGive>
	char  szVariable[8];
	
	StartTimer(125); // = 8 msekunnin välein keskeytys 8*125 = 1000ms = 1s
     c16:	8d e7       	ldi	r24, 0x7D	; 125
     c18:	90 e0       	ldi	r25, 0x00	; 0
     c1a:	d8 df       	rcall	.-80     	; 0xbcc <StartTimer>
	StartTimer2(125);
     c1c:	8d e7       	ldi	r24, 0x7D	; 125
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	df df       	rcall	.-66     	; 0xbe0 <StartTimer2>
	for( ;; )//.........
	{
		xSemaphoreTake( xClock, portMAX_DELAY ); // odotetaan tietoa keskeytyksestä

		taskENTER_CRITICAL(); /////////////////////////////////////////
		tietoKanta[ IDD_HOUR ]   =  secondsFromMidNight / 3600L;         ////
     c22:	c3 e4       	ldi	r28, 0x43	; 67
     c24:	d3 e0       	ldi	r29, 0x03	; 3
     c26:	00 e1       	ldi	r16, 0x10	; 16
     c28:	1e e0       	ldi	r17, 0x0E	; 14
		tietoKanta[ IDD_MINU ]= (secondsFromMidNight % 3600L) / 60L ; ////
		tietoKanta[ IDD_SEC ]=  secondsFromMidNight % 60L;           ////
     c2a:	0f 2e       	mov	r0, r31
     c2c:	fc e3       	ldi	r31, 0x3C	; 60
     c2e:	ff 2e       	mov	r15, r31
     c30:	f0 2d       	mov	r31, r0
	
	
	// taskilla tulee aina  olla ikisilmukka
	for( ;; )//.........
	{
		xSemaphoreTake( xClock, portMAX_DELAY ); // odotetaan tietoa keskeytyksestä
     c32:	20 e0       	ldi	r18, 0x00	; 0
     c34:	4f ef       	ldi	r20, 0xFF	; 255
     c36:	5f ef       	ldi	r21, 0xFF	; 255
     c38:	60 e0       	ldi	r22, 0x00	; 0
     c3a:	70 e0       	ldi	r23, 0x00	; 0
     c3c:	80 91 3d 03 	lds	r24, 0x033D	; 0x80033d <xClock>
     c40:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <xClock+0x1>
     c44:	0e 94 de 10 	call	0x21bc	; 0x21bc <xQueueGenericReceive>

		taskENTER_CRITICAL(); /////////////////////////////////////////
     c48:	0f b6       	in	r0, 0x3f	; 63
     c4a:	f8 94       	cli
     c4c:	0f 92       	push	r0
		tietoKanta[ IDD_HOUR ]   =  secondsFromMidNight / 3600L;         ////
     c4e:	e0 91 63 03 	lds	r30, 0x0363	; 0x800363 <secondsFromMidNight>
     c52:	f0 91 64 03 	lds	r31, 0x0364	; 0x800364 <secondsFromMidNight+0x1>
     c56:	cf 01       	movw	r24, r30
     c58:	b8 01       	movw	r22, r16
     c5a:	0e 94 62 21 	call	0x42c4	; 0x42c4 <__udivmodhi4>
     c5e:	7f 83       	std	Y+7, r23	; 0x07
     c60:	6e 83       	std	Y+6, r22	; 0x06
		tietoKanta[ IDD_MINU ]= (secondsFromMidNight % 3600L) / 60L ; ////
     c62:	9c 01       	movw	r18, r24
     c64:	a9 e8       	ldi	r26, 0x89	; 137
     c66:	b8 e8       	ldi	r27, 0x88	; 136
     c68:	0e 94 cf 21 	call	0x439e	; 0x439e <__umulhisi3>
     c6c:	96 95       	lsr	r25
     c6e:	87 95       	ror	r24
     c70:	92 95       	swap	r25
     c72:	82 95       	swap	r24
     c74:	8f 70       	andi	r24, 0x0F	; 15
     c76:	89 27       	eor	r24, r25
     c78:	9f 70       	andi	r25, 0x0F	; 15
     c7a:	89 27       	eor	r24, r25
     c7c:	9d 83       	std	Y+5, r25	; 0x05
     c7e:	8c 83       	std	Y+4, r24	; 0x04
		tietoKanta[ IDD_SEC ]=  secondsFromMidNight % 60L;           ////
     c80:	9f 01       	movw	r18, r30
     c82:	0e 94 cf 21 	call	0x439e	; 0x439e <__umulhisi3>
     c86:	96 95       	lsr	r25
     c88:	87 95       	ror	r24
     c8a:	92 95       	swap	r25
     c8c:	82 95       	swap	r24
     c8e:	8f 70       	andi	r24, 0x0F	; 15
     c90:	89 27       	eor	r24, r25
     c92:	9f 70       	andi	r25, 0x0F	; 15
     c94:	89 27       	eor	r24, r25
     c96:	f8 9e       	mul	r15, r24
     c98:	90 01       	movw	r18, r0
     c9a:	f9 9e       	mul	r15, r25
     c9c:	30 0d       	add	r19, r0
     c9e:	11 24       	eor	r1, r1
     ca0:	e2 1b       	sub	r30, r18
     ca2:	f3 0b       	sbc	r31, r19
     ca4:	fb 83       	std	Y+3, r31	; 0x03
     ca6:	ea 83       	std	Y+2, r30	; 0x02
		taskEXIT_CRITICAL(); //////////////////////////////////////////
     ca8:	0f 90       	pop	r0
     caa:	0f be       	out	0x3f, r0	; 63
     cac:	c2 cf       	rjmp	.-124    	; 0xc32 <vClock+0x38>

00000cae <__vector_21>:
	TIMSK2 |= (1 << OCIE2A); // vertailuarvokeskeytys
	OCR2A = ticks; // laitetaan vertailuarvoksi annettu lukema
	TCNT2 = 0;    // laskuri alkuun
}

SIGNAL(TIMER0_COMPA_vect) {
     cae:	1f 92       	push	r1
     cb0:	0f 92       	push	r0
     cb2:	0f b6       	in	r0, 0x3f	; 63
     cb4:	0f 92       	push	r0
     cb6:	11 24       	eor	r1, r1
     cb8:	0b b6       	in	r0, 0x3b	; 59
     cba:	0f 92       	push	r0
     cbc:	2f 93       	push	r18
     cbe:	3f 93       	push	r19
     cc0:	4f 93       	push	r20
     cc2:	5f 93       	push	r21
     cc4:	6f 93       	push	r22
     cc6:	7f 93       	push	r23
     cc8:	8f 93       	push	r24
     cca:	9f 93       	push	r25
     ccc:	af 93       	push	r26
     cce:	bf 93       	push	r27
     cd0:	ef 93       	push	r30
     cd2:	ff 93       	push	r31
	static BaseType_t xTaskWoken = pdFALSE;
	static unsigned msCounter = 0;
	msCounter += 8 ; // interval 8ms
     cd4:	80 91 35 03 	lds	r24, 0x0335	; 0x800335 <msCounter.3049>
     cd8:	90 91 36 03 	lds	r25, 0x0336	; 0x800336 <msCounter.3049+0x1>
     cdc:	08 96       	adiw	r24, 0x08	; 8
     cde:	90 93 36 03 	sts	0x0336, r25	; 0x800336 <msCounter.3049+0x1>
     ce2:	80 93 35 03 	sts	0x0335, r24	; 0x800335 <msCounter.3049>
	TCNT0 = 0; // laskuri alkuun
     ce6:	16 bc       	out	0x26, r1	; 38
	//timer0 interrupt handler
	if ( msCounter == 1000)
     ce8:	80 91 35 03 	lds	r24, 0x0335	; 0x800335 <msCounter.3049>
     cec:	90 91 36 03 	lds	r25, 0x0336	; 0x800336 <msCounter.3049+0x1>
     cf0:	88 3e       	cpi	r24, 0xE8	; 232
     cf2:	93 40       	sbci	r25, 0x03	; 3
     cf4:	a9 f4       	brne	.+42     	; 0xd20 <__vector_21+0x72>
	{
		secondsFromMidNight++;
     cf6:	80 91 63 03 	lds	r24, 0x0363	; 0x800363 <secondsFromMidNight>
     cfa:	90 91 64 03 	lds	r25, 0x0364	; 0x800364 <secondsFromMidNight+0x1>
     cfe:	01 96       	adiw	r24, 0x01	; 1
     d00:	90 93 64 03 	sts	0x0364, r25	; 0x800364 <secondsFromMidNight+0x1>
     d04:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <secondsFromMidNight>
		xSemaphoreGiveFromISR( xClock, &xTaskWoken ); // ilmoitetaan kellonajan muutos
     d08:	64 e3       	ldi	r22, 0x34	; 52
     d0a:	73 e0       	ldi	r23, 0x03	; 3
     d0c:	80 91 3d 03 	lds	r24, 0x033D	; 0x80033d <xClock>
     d10:	90 91 3e 03 	lds	r25, 0x033E	; 0x80033e <xClock+0x1>
     d14:	0e 94 b3 10 	call	0x2166	; 0x2166 <xQueueGiveFromISR>
		msCounter = 0;
     d18:	10 92 36 03 	sts	0x0336, r1	; 0x800336 <msCounter.3049+0x1>
     d1c:	10 92 35 03 	sts	0x0335, r1	; 0x800335 <msCounter.3049>
	}
}
     d20:	ff 91       	pop	r31
     d22:	ef 91       	pop	r30
     d24:	bf 91       	pop	r27
     d26:	af 91       	pop	r26
     d28:	9f 91       	pop	r25
     d2a:	8f 91       	pop	r24
     d2c:	7f 91       	pop	r23
     d2e:	6f 91       	pop	r22
     d30:	5f 91       	pop	r21
     d32:	4f 91       	pop	r20
     d34:	3f 91       	pop	r19
     d36:	2f 91       	pop	r18
     d38:	0f 90       	pop	r0
     d3a:	0b be       	out	0x3b, r0	; 59
     d3c:	0f 90       	pop	r0
     d3e:	0f be       	out	0x3f, r0	; 63
     d40:	0f 90       	pop	r0
     d42:	1f 90       	pop	r1
     d44:	18 95       	reti

00000d46 <__vector_13>:
////////////////////////////////////////////////////////////////
SIGNAL(TIMER2_COMPA_vect) {
     d46:	1f 92       	push	r1
     d48:	0f 92       	push	r0
     d4a:	0f b6       	in	r0, 0x3f	; 63
     d4c:	0f 92       	push	r0
     d4e:	11 24       	eor	r1, r1
     d50:	8f 93       	push	r24
     d52:	9f 93       	push	r25
	static BaseType_t xTaskWoken = pdFALSE;
	static unsigned msCounter = 0;
	msCounter += 8 ; // interval 8ms
     d54:	80 91 32 03 	lds	r24, 0x0332	; 0x800332 <__data_end>
     d58:	90 91 33 03 	lds	r25, 0x0333	; 0x800333 <__data_end+0x1>
     d5c:	08 96       	adiw	r24, 0x08	; 8
     d5e:	90 93 33 03 	sts	0x0333, r25	; 0x800333 <__data_end+0x1>
     d62:	80 93 32 03 	sts	0x0332, r24	; 0x800332 <__data_end>
	TCNT2 = 0; // laskuri alkuun
     d66:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7000b2>
	{
		//		secondsFromMidNight++;
		//		xSemaphoreGiveFromISR( xClock, &xTaskWoken ); // ilmoitetaan kellonajan muutos
		//		msCounter = 0;
	}
     d6a:	9f 91       	pop	r25
     d6c:	8f 91       	pop	r24
     d6e:	0f 90       	pop	r0
     d70:	0f be       	out	0x3f, r0	; 63
     d72:	0f 90       	pop	r0
     d74:	1f 90       	pop	r1
     d76:	18 95       	reti

00000d78 <ReadADC>:
#include <avr\io.h>              // Most basic include files
#include "adc.h"
// oletus kellotaajuus 16 Mhz Atmega328P
int ReadADC(void)
{
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
  char i;
  int  lukema;

  int  tulos = 0;

  ADCSRA |= 1 << ADEN; // laite plle
     d7c:	ea e7       	ldi	r30, 0x7A	; 122
     d7e:	f0 e0       	ldi	r31, 0x00	; 0
     d80:	80 81       	ld	r24, Z
     d82:	80 68       	ori	r24, 0x80	; 128
     d84:	80 83       	st	Z, r24

  //pitkkestoinen lukema pois
  ADCSRA |= (1<<ADSC); //
     d86:	80 81       	ld	r24, Z
     d88:	80 64       	ori	r24, 0x40	; 64
     d8a:	80 83       	st	Z, r24
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi
     d8c:	80 81       	ld	r24, Z
     d8e:	84 ff       	sbrs	r24, 4
     d90:	fd cf       	rjmp	.-6      	; 0xd8c <ReadADC+0x14>
     d92:	48 e0       	ldi	r20, 0x08	; 8
     d94:	60 e0       	ldi	r22, 0x00	; 0
     d96:	70 e0       	ldi	r23, 0x00	; 0

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
  {
    ADCSRA |= (1<<ADSC); // aloita muunnos
     d98:	ea e7       	ldi	r30, 0x7A	; 122
     d9a:	f0 e0       	ldi	r31, 0x00	; 0
    while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi

    lukema = ADCL;         // alaosa luetaan ensiksi
     d9c:	c8 e7       	ldi	r28, 0x78	; 120
     d9e:	d0 e0       	ldi	r29, 0x00	; 0
    lukema += (ADCH << 8); // ylosan luenta
     da0:	a9 e7       	ldi	r26, 0x79	; 121
     da2:	b0 e0       	ldi	r27, 0x00	; 0
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
  {
    ADCSRA |= (1<<ADSC); // aloita muunnos
     da4:	90 81       	ld	r25, Z
     da6:	90 64       	ori	r25, 0x40	; 64
     da8:	90 83       	st	Z, r25
    while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi
     daa:	90 81       	ld	r25, Z
     dac:	94 ff       	sbrs	r25, 4
     dae:	fd cf       	rjmp	.-6      	; 0xdaa <ReadADC+0x32>

    lukema = ADCL;         // alaosa luetaan ensiksi
     db0:	88 81       	ld	r24, Y
    lukema += (ADCH << 8); // ylosan luenta
     db2:	2c 91       	ld	r18, X

    // otetaan 8 lukemaa summaksi
    tulos += lukema;
     db4:	30 e0       	ldi	r19, 0x00	; 0
     db6:	32 2f       	mov	r19, r18
     db8:	22 27       	eor	r18, r18
     dba:	28 0f       	add	r18, r24
     dbc:	31 1d       	adc	r19, r1
     dbe:	62 0f       	add	r22, r18
     dc0:	73 1f       	adc	r23, r19
     dc2:	41 50       	subi	r20, 0x01	; 1
  //pitkkestoinen lukema pois
  ADCSRA |= (1<<ADSC); //
  while(!(ADCSRA & (1 << ADIF))); // ADIF tulee plle lopuksi

  // do the ADC conversion 8 times for better accuracy
  for(i=0;i<8;i++)
     dc4:	79 f7       	brne	.-34     	; 0xda4 <ReadADC+0x2c>
    tulos += lukema;
  }

  tulos = tulos >> 3; // lukemien keskiarvo

  ADCSRA &= ~(1<<ADEN); // AD-muunnin pois plt
     dc6:	ea e7       	ldi	r30, 0x7A	; 122
     dc8:	f0 e0       	ldi	r31, 0x00	; 0
     dca:	80 81       	ld	r24, Z
     dcc:	8f 77       	andi	r24, 0x7F	; 127
     dce:	80 83       	st	Z, r24
  return tulos;
}
     dd0:	cb 01       	movw	r24, r22
     dd2:	95 95       	asr	r25
     dd4:	87 95       	ror	r24
     dd6:	95 95       	asr	r25
     dd8:	87 95       	ror	r24
     dda:	95 95       	asr	r25
     ddc:	87 95       	ror	r24
     dde:	df 91       	pop	r29
     de0:	cf 91       	pop	r28
     de2:	08 95       	ret

00000de4 <InitADC>:

void InitADC(char portti)
{
  // sisinen referenssijnnite + kanavan valinta
  //ADMUX = (1 << REFS1) | (1 << REFS0) | portti;
  ADMUX =  (1 << REFS0) | portti;
     de4:	80 64       	ori	r24, 0x40	; 64
     de6:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x70007c>

  // laite plle + kellotaajuudeksi 16MHz / 128 = 125kHz
  ADCSRA = (1<<ADEN) | (1<<ADPS0) | (1<<ADPS1) | (1<<ADPS2);
     dea:	87 e8       	ldi	r24, 0x87	; 135
     dec:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>

  ReadADC(); // nollataan muunnin lukemalla kertaalleen
     df0:	c3 cf       	rjmp	.-122    	; 0xd78 <ReadADC>
     df2:	08 95       	ret

00000df4 <GetKey>:
#include "device.h"

unsigned char GetKey(void)
{
     df4:	0f 93       	push	r16
     df6:	1f 93       	push	r17
     df8:	cf 93       	push	r28
     dfa:	df 93       	push	r29

  int nValue;

  InitADC(0);
     dfc:	80 e0       	ldi	r24, 0x00	; 0
     dfe:	f2 df       	rcall	.-28     	; 0xde4 <InitADC>

  nValue = ReadADC();
     e00:	bb df       	rcall	.-138    	; 0xd78 <ReadADC>
     e02:	85 38       	cpi	r24, 0x85	; 133
  
  // jos mikn nppin ei ole alhaalla
  // saadaan 1023, mutta siirtymvaiheessa
  // saattaa tulla hieman pienempi arvoja
  // tulkitaan nekin ei nppiksi
  if (nValue > 900)
     e04:	93 40       	sbci	r25, 0x03	; 3
     e06:	0c f5       	brge	.+66     	; 0xe4a <GetKey+0x56>
     e08:	ca e0       	ldi	r28, 0x0A	; 10
     e0a:	d0 e0       	ldi	r29, 0x00	; 0
     e0c:	00 e0       	ldi	r16, 0x00	; 0
     e0e:	10 e0       	ldi	r17, 0x00	; 0
  
  // luetaan 10 kertaa ja kytetn keskiarvoa
  // transienttilukemien eliminoimiseksi
  nValue = 0;
  for(int i=0; i < 10; i++)
   nValue += ReadADC();
     e10:	b3 df       	rcall	.-154    	; 0xd78 <ReadADC>
     e12:	08 0f       	add	r16, r24
     e14:	19 1f       	adc	r17, r25
     e16:	21 97       	sbiw	r28, 0x01	; 1
     e18:	d9 f7       	brne	.-10     	; 0xe10 <GetKey+0x1c>
     return NO_KEY;  
  
  // luetaan 10 kertaa ja kytetn keskiarvoa
  // transienttilukemien eliminoimiseksi
  nValue = 0;
  for(int i=0; i < 10; i++)
     e1a:	c8 01       	movw	r24, r16
   nValue += ReadADC();
  nValue /= 10; // keskiarvo
     e1c:	6a e0       	ldi	r22, 0x0A	; 10
     e1e:	70 e0       	ldi	r23, 0x00	; 0
     e20:	0e 94 76 21 	call	0x42ec	; 0x42ec <__divmodhi4>
     e24:	62 33       	cpi	r22, 0x32	; 50

  // tunnistetaan
  if (nValue < 50)
     e26:	71 05       	cpc	r23, r1
     e28:	94 f0       	brlt	.+36     	; 0xe4e <GetKey+0x5a>
     e2a:	66 3e       	cpi	r22, 0xE6	; 230
	  return IDK_RIGHT;
  else if (nValue < 230)
     e2c:	71 05       	cpc	r23, r1
     e2e:	8c f0       	brlt	.+34     	; 0xe52 <GetKey+0x5e>
     e30:	62 3c       	cpi	r22, 0xC2	; 194
	  return IDK_UP;
  else if (nValue < 450)
     e32:	81 e0       	ldi	r24, 0x01	; 1
     e34:	78 07       	cpc	r23, r24
     e36:	7c f0       	brlt	.+30     	; 0xe56 <GetKey+0x62>
     e38:	6a 38       	cpi	r22, 0x8A	; 138
	  return IDK_DOWN;
  else if (nValue < 650)
     e3a:	22 e0       	ldi	r18, 0x02	; 2
     e3c:	72 07       	cpc	r23, r18
     e3e:	6c f0       	brlt	.+26     	; 0xe5a <GetKey+0x66>
     e40:	64 38       	cpi	r22, 0x84	; 132
	  return IDK_LEFT;
  else if (nValue < 900)
     e42:	73 40       	sbci	r23, 0x03	; 3
     e44:	64 f0       	brlt	.+24     	; 0xe5e <GetKey+0x6a>
     e46:	83 e6       	ldi	r24, 0x63	; 99
	  return IDK_SELECT;
  else return NO_KEY; // ei yhtn alhaalla
     e48:	0b c0       	rjmp	.+22     	; 0xe60 <GetKey+0x6c>
     e4a:	83 e6       	ldi	r24, 0x63	; 99
  // jos mikn nppin ei ole alhaalla
  // saadaan 1023, mutta siirtymvaiheessa
  // saattaa tulla hieman pienempi arvoja
  // tulkitaan nekin ei nppiksi
  if (nValue > 900)
     return NO_KEY;  
     e4c:	09 c0       	rjmp	.+18     	; 0xe60 <GetKey+0x6c>
     e4e:	81 e0       	ldi	r24, 0x01	; 1
   nValue += ReadADC();
  nValue /= 10; // keskiarvo

  // tunnistetaan
  if (nValue < 50)
	  return IDK_RIGHT;
     e50:	07 c0       	rjmp	.+14     	; 0xe60 <GetKey+0x6c>
     e52:	82 e0       	ldi	r24, 0x02	; 2
  else if (nValue < 230)
	  return IDK_UP;
     e54:	05 c0       	rjmp	.+10     	; 0xe60 <GetKey+0x6c>
     e56:	83 e0       	ldi	r24, 0x03	; 3
  else if (nValue < 450)
	  return IDK_DOWN;
     e58:	03 c0       	rjmp	.+6      	; 0xe60 <GetKey+0x6c>
     e5a:	84 e0       	ldi	r24, 0x04	; 4
  else if (nValue < 650)
	  return IDK_LEFT;
     e5c:	01 c0       	rjmp	.+2      	; 0xe60 <GetKey+0x6c>
     e5e:	85 e0       	ldi	r24, 0x05	; 5
  else if (nValue < 900)
	  return IDK_SELECT;
     e60:	df 91       	pop	r29
  else return NO_KEY; // ei yhtn alhaalla
}
     e62:	cf 91       	pop	r28
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	08 95       	ret

00000e6a <lcd_write>:
     e6a:	66 23       	and	r22, r22
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) )
        lcd_putc(c);

}
     e6c:	31 f0       	breq	.+12     	; 0xe7a <lcd_write+0x10>
     e6e:	e2 e0       	ldi	r30, 0x02	; 2
     e70:	f1 e0       	ldi	r31, 0x01	; 1
     e72:	90 81       	ld	r25, Z
     e74:	90 62       	ori	r25, 0x20	; 32
     e76:	90 83       	st	Z, r25
     e78:	05 c0       	rjmp	.+10     	; 0xe84 <lcd_write+0x1a>
     e7a:	e2 e0       	ldi	r30, 0x02	; 2
     e7c:	f1 e0       	ldi	r31, 0x01	; 1
     e7e:	90 81       	ld	r25, Z
     e80:	9f 7d       	andi	r25, 0xDF	; 223
     e82:	90 83       	st	Z, r25
     e84:	41 11       	cpse	r20, r1
     e86:	3d c0       	rjmp	.+122    	; 0xf02 <lcd_write+0x98>
     e88:	88 23       	and	r24, r24
     e8a:	34 f4       	brge	.+12     	; 0xe98 <lcd_write+0x2e>
     e8c:	e2 e0       	ldi	r30, 0x02	; 2
     e8e:	f1 e0       	ldi	r31, 0x01	; 1
     e90:	90 81       	ld	r25, Z
     e92:	90 61       	ori	r25, 0x10	; 16
     e94:	90 83       	st	Z, r25
     e96:	05 c0       	rjmp	.+10     	; 0xea2 <lcd_write+0x38>
     e98:	e2 e0       	ldi	r30, 0x02	; 2
     e9a:	f1 e0       	ldi	r31, 0x01	; 1
     e9c:	90 81       	ld	r25, Z
     e9e:	9f 7e       	andi	r25, 0xEF	; 239
     ea0:	90 83       	st	Z, r25
     ea2:	86 ff       	sbrs	r24, 6
     ea4:	06 c0       	rjmp	.+12     	; 0xeb2 <lcd_write+0x48>
     ea6:	e2 e0       	ldi	r30, 0x02	; 2
     ea8:	f1 e0       	ldi	r31, 0x01	; 1
     eaa:	90 81       	ld	r25, Z
     eac:	98 60       	ori	r25, 0x08	; 8
     eae:	90 83       	st	Z, r25
     eb0:	05 c0       	rjmp	.+10     	; 0xebc <lcd_write+0x52>
     eb2:	e2 e0       	ldi	r30, 0x02	; 2
     eb4:	f1 e0       	ldi	r31, 0x01	; 1
     eb6:	90 81       	ld	r25, Z
     eb8:	97 7f       	andi	r25, 0xF7	; 247
     eba:	90 83       	st	Z, r25
     ebc:	85 ff       	sbrs	r24, 5
     ebe:	02 c0       	rjmp	.+4      	; 0xec4 <lcd_write+0x5a>
     ec0:	73 9a       	sbi	0x0e, 3	; 14
     ec2:	01 c0       	rjmp	.+2      	; 0xec6 <lcd_write+0x5c>
     ec4:	73 98       	cbi	0x0e, 3	; 14
     ec6:	84 ff       	sbrs	r24, 4
     ec8:	02 c0       	rjmp	.+4      	; 0xece <lcd_write+0x64>
     eca:	a5 9a       	sbi	0x14, 5	; 20
     ecc:	01 c0       	rjmp	.+2      	; 0xed0 <lcd_write+0x66>
     ece:	a5 98       	cbi	0x14, 5	; 20
     ed0:	e2 e0       	ldi	r30, 0x02	; 2
     ed2:	f1 e0       	ldi	r31, 0x01	; 1
     ed4:	90 81       	ld	r25, Z
     ed6:	9f 7b       	andi	r25, 0xBF	; 191
     ed8:	90 83       	st	Z, r25
     eda:	95 e0       	ldi	r25, 0x05	; 5
     edc:	9a 95       	dec	r25
     ede:	f1 f7       	brne	.-4      	; 0xedc <lcd_write+0x72>
     ee0:	00 00       	nop
     ee2:	90 81       	ld	r25, Z
     ee4:	90 64       	ori	r25, 0x40	; 64
     ee6:	90 83       	st	Z, r25
     ee8:	95 e0       	ldi	r25, 0x05	; 5
     eea:	9a 95       	dec	r25
     eec:	f1 f7       	brne	.-4      	; 0xeea <lcd_write+0x80>
     eee:	00 00       	nop
     ef0:	90 81       	ld	r25, Z
     ef2:	9f 7b       	andi	r25, 0xBF	; 191
     ef4:	90 83       	st	Z, r25
     ef6:	ef e9       	ldi	r30, 0x9F	; 159
     ef8:	ff e0       	ldi	r31, 0x0F	; 15
     efa:	31 97       	sbiw	r30, 0x01	; 1
     efc:	f1 f7       	brne	.-4      	; 0xefa <lcd_write+0x90>
     efe:	00 c0       	rjmp	.+0      	; 0xf00 <lcd_write+0x96>
     f00:	00 00       	nop
     f02:	83 ff       	sbrs	r24, 3
     f04:	06 c0       	rjmp	.+12     	; 0xf12 <lcd_write+0xa8>
     f06:	e2 e0       	ldi	r30, 0x02	; 2
     f08:	f1 e0       	ldi	r31, 0x01	; 1
     f0a:	90 81       	ld	r25, Z
     f0c:	90 61       	ori	r25, 0x10	; 16
     f0e:	90 83       	st	Z, r25
     f10:	05 c0       	rjmp	.+10     	; 0xf1c <lcd_write+0xb2>
     f12:	e2 e0       	ldi	r30, 0x02	; 2
     f14:	f1 e0       	ldi	r31, 0x01	; 1
     f16:	90 81       	ld	r25, Z
     f18:	9f 7e       	andi	r25, 0xEF	; 239
     f1a:	90 83       	st	Z, r25
     f1c:	82 ff       	sbrs	r24, 2
     f1e:	06 c0       	rjmp	.+12     	; 0xf2c <lcd_write+0xc2>
     f20:	e2 e0       	ldi	r30, 0x02	; 2
     f22:	f1 e0       	ldi	r31, 0x01	; 1
     f24:	90 81       	ld	r25, Z
     f26:	98 60       	ori	r25, 0x08	; 8
     f28:	90 83       	st	Z, r25
     f2a:	05 c0       	rjmp	.+10     	; 0xf36 <lcd_write+0xcc>
     f2c:	e2 e0       	ldi	r30, 0x02	; 2
     f2e:	f1 e0       	ldi	r31, 0x01	; 1
     f30:	90 81       	ld	r25, Z
     f32:	97 7f       	andi	r25, 0xF7	; 247
     f34:	90 83       	st	Z, r25
     f36:	81 ff       	sbrs	r24, 1
     f38:	02 c0       	rjmp	.+4      	; 0xf3e <lcd_write+0xd4>
     f3a:	73 9a       	sbi	0x0e, 3	; 14
     f3c:	01 c0       	rjmp	.+2      	; 0xf40 <lcd_write+0xd6>
     f3e:	73 98       	cbi	0x0e, 3	; 14
     f40:	80 ff       	sbrs	r24, 0
     f42:	02 c0       	rjmp	.+4      	; 0xf48 <lcd_write+0xde>
     f44:	a5 9a       	sbi	0x14, 5	; 20
     f46:	01 c0       	rjmp	.+2      	; 0xf4a <lcd_write+0xe0>
     f48:	a5 98       	cbi	0x14, 5	; 20
     f4a:	e2 e0       	ldi	r30, 0x02	; 2
     f4c:	f1 e0       	ldi	r31, 0x01	; 1
     f4e:	80 81       	ld	r24, Z
     f50:	8f 7b       	andi	r24, 0xBF	; 191
     f52:	80 83       	st	Z, r24
     f54:	85 e0       	ldi	r24, 0x05	; 5
     f56:	8a 95       	dec	r24
     f58:	f1 f7       	brne	.-4      	; 0xf56 <lcd_write+0xec>
     f5a:	00 00       	nop
     f5c:	80 81       	ld	r24, Z
     f5e:	80 64       	ori	r24, 0x40	; 64
     f60:	80 83       	st	Z, r24
     f62:	95 e0       	ldi	r25, 0x05	; 5
     f64:	9a 95       	dec	r25
     f66:	f1 f7       	brne	.-4      	; 0xf64 <lcd_write+0xfa>
     f68:	00 00       	nop
     f6a:	80 81       	ld	r24, Z
     f6c:	8f 7b       	andi	r24, 0xBF	; 191
     f6e:	80 83       	st	Z, r24
     f70:	8f e9       	ldi	r24, 0x9F	; 159
     f72:	9f e0       	ldi	r25, 0x0F	; 15
     f74:	01 97       	sbiw	r24, 0x01	; 1
     f76:	f1 f7       	brne	.-4      	; 0xf74 <lcd_write+0x10a>
     f78:	00 c0       	rjmp	.+0      	; 0xf7a <lcd_write+0x110>
     f7a:	00 00       	nop
     f7c:	a5 9a       	sbi	0x14, 5	; 20
     f7e:	73 9a       	sbi	0x0e, 3	; 14
     f80:	80 81       	ld	r24, Z
     f82:	88 60       	ori	r24, 0x08	; 8
     f84:	80 83       	st	Z, r24
     f86:	80 81       	ld	r24, Z
     f88:	80 61       	ori	r24, 0x10	; 16
     f8a:	80 83       	st	Z, r24
     f8c:	08 95       	ret

00000f8e <lcd_command>:
     f8e:	40 e0       	ldi	r20, 0x00	; 0
     f90:	60 e0       	ldi	r22, 0x00	; 0
     f92:	6b cf       	rjmp	.-298    	; 0xe6a <lcd_write>
     f94:	08 95       	ret

00000f96 <lcd_gotoxy>:
     f96:	cf 93       	push	r28
     f98:	df 93       	push	r29
     f9a:	d8 2f       	mov	r29, r24
     f9c:	c6 2f       	mov	r28, r22
     f9e:	82 e0       	ldi	r24, 0x02	; 2
     fa0:	f6 df       	rcall	.-20     	; 0xf8e <lcd_command>
     fa2:	c1 30       	cpi	r28, 0x01	; 1
     fa4:	09 f4       	brne	.+2      	; 0xfa8 <lcd_gotoxy+0x12>
     fa6:	d8 5d       	subi	r29, 0xD8	; 216
     fa8:	dd 23       	and	r29, r29
     faa:	31 f0       	breq	.+12     	; 0xfb8 <lcd_gotoxy+0x22>
     fac:	c0 e0       	ldi	r28, 0x00	; 0
     fae:	84 e1       	ldi	r24, 0x14	; 20
     fb0:	ee df       	rcall	.-36     	; 0xf8e <lcd_command>
     fb2:	cf 5f       	subi	r28, 0xFF	; 255
     fb4:	dc 13       	cpse	r29, r28
     fb6:	fb cf       	rjmp	.-10     	; 0xfae <lcd_gotoxy+0x18>
     fb8:	df 91       	pop	r29
     fba:	cf 91       	pop	r28
     fbc:	08 95       	ret

00000fbe <lcd_clrscr>:
     fbe:	81 e0       	ldi	r24, 0x01	; 1
     fc0:	e6 df       	rcall	.-52     	; 0xf8e <lcd_command>
     fc2:	8f ed       	ldi	r24, 0xDF	; 223
     fc4:	9e e2       	ldi	r25, 0x2E	; 46
     fc6:	01 97       	sbiw	r24, 0x01	; 1
     fc8:	f1 f7       	brne	.-4      	; 0xfc6 <lcd_clrscr+0x8>
     fca:	00 c0       	rjmp	.+0      	; 0xfcc <lcd_clrscr+0xe>
     fcc:	00 00       	nop
     fce:	08 95       	ret

00000fd0 <lcd_putc>:
     fd0:	40 e0       	ldi	r20, 0x00	; 0
     fd2:	61 e0       	ldi	r22, 0x01	; 1
     fd4:	4a cf       	rjmp	.-364    	; 0xe6a <lcd_write>
     fd6:	08 95       	ret

00000fd8 <lcd_puts>:
     fd8:	cf 93       	push	r28
     fda:	df 93       	push	r29
     fdc:	ec 01       	movw	r28, r24
     fde:	21 96       	adiw	r28, 0x01	; 1
     fe0:	fc 01       	movw	r30, r24
     fe2:	80 81       	ld	r24, Z
     fe4:	88 23       	and	r24, r24
     fe6:	21 f0       	breq	.+8      	; 0xff0 <lcd_puts+0x18>
     fe8:	f3 df       	rcall	.-26     	; 0xfd0 <lcd_putc>
     fea:	89 91       	ld	r24, Y+
     fec:	81 11       	cpse	r24, r1
     fee:	fc cf       	rjmp	.-8      	; 0xfe8 <lcd_puts+0x10>
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	08 95       	ret

00000ff6 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
     ff6:	cf 93       	push	r28
     ff8:	c8 2f       	mov	r28, r24
   //
   //  Initialize LCD to 4 bit I/O mode
   //

    // configure all port bits as output
   DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
     ffa:	e1 e0       	ldi	r30, 0x01	; 1
     ffc:	f1 e0       	ldi	r31, 0x01	; 1
     ffe:	80 81       	ld	r24, Z
    1000:	80 62       	ori	r24, 0x20	; 32
    1002:	80 83       	st	Z, r24
   //DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
   DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    1004:	80 81       	ld	r24, Z
    1006:	80 64       	ori	r24, 0x40	; 64
    1008:	80 83       	st	Z, r24
   DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
    100a:	9d 9a       	sbi	0x13, 5	; 19
   DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
    100c:	6b 9a       	sbi	0x0d, 3	; 13
   DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
    100e:	80 81       	ld	r24, Z
    1010:	88 60       	ori	r24, 0x08	; 8
    1012:	80 83       	st	Z, r24
   DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    1014:	80 81       	ld	r24, Z
    1016:	80 61       	ori	r24, 0x10	; 16
    1018:	80 83       	st	Z, r24
    101a:	2f ef       	ldi	r18, 0xFF	; 255
    101c:	8d ee       	ldi	r24, 0xED	; 237
    101e:	92 e0       	ldi	r25, 0x02	; 2
    1020:	21 50       	subi	r18, 0x01	; 1
    1022:	80 40       	sbci	r24, 0x00	; 0
    1024:	90 40       	sbci	r25, 0x00	; 0
    1026:	e1 f7       	brne	.-8      	; 0x1020 <lcd_init+0x2a>
    1028:	00 c0       	rjmp	.+0      	; 0x102a <lcd_init+0x34>
    102a:	00 00       	nop
   _delay_ms(60);     //  wait 50ms or more after power-on

   // reset the lcd circuit
 //  lcd_write(0x33, 0,0);
 //  _delay_ms(5);      // wait 5 ms
    lcd_rs_low();
    102c:	e2 e0       	ldi	r30, 0x02	; 2
    102e:	f1 e0       	ldi	r31, 0x01	; 1
    1030:	80 81       	ld	r24, Z
    1032:	8f 7d       	andi	r24, 0xDF	; 223
    1034:	80 83       	st	Z, r24
    lcd_e_low();
    1036:	80 81       	ld	r24, Z
    1038:	8f 7b       	andi	r24, 0xBF	; 191
    103a:	80 83       	st	Z, r24


   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
    103c:	41 e0       	ldi	r20, 0x01	; 1
    103e:	60 e0       	ldi	r22, 0x00	; 0
    1040:	83 e0       	ldi	r24, 0x03	; 3
    1042:	13 df       	rcall	.-474    	; 0xe6a <lcd_write>
    1044:	8f e1       	ldi	r24, 0x1F	; 31
    1046:	9e e4       	ldi	r25, 0x4E	; 78
    1048:	01 97       	sbiw	r24, 0x01	; 1
    104a:	f1 f7       	brne	.-4      	; 0x1048 <lcd_init+0x52>
    104c:	00 c0       	rjmp	.+0      	; 0x104e <lcd_init+0x58>
    104e:	00 00       	nop
   _delay_ms(5);      // wait 5 ms
   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
    1050:	41 e0       	ldi	r20, 0x01	; 1
    1052:	60 e0       	ldi	r22, 0x00	; 0
    1054:	83 e0       	ldi	r24, 0x03	; 3
    1056:	09 df       	rcall	.-494    	; 0xe6a <lcd_write>
    1058:	8f e9       	ldi	r24, 0x9F	; 159
    105a:	9f e0       	ldi	r25, 0x0F	; 15
    105c:	01 97       	sbiw	r24, 0x01	; 1
    105e:	f1 f7       	brne	.-4      	; 0x105c <lcd_init+0x66>
    1060:	00 c0       	rjmp	.+0      	; 0x1062 <lcd_init+0x6c>
    1062:	00 00       	nop
   _delay_ms(1);      // wait 1 ms
   // set the device to the 4-bit mode
   lcd_write(0x3, 0,1);
    1064:	41 e0       	ldi	r20, 0x01	; 1
    1066:	60 e0       	ldi	r22, 0x00	; 0
    1068:	83 e0       	ldi	r24, 0x03	; 3
    106a:	ff de       	rcall	.-514    	; 0xe6a <lcd_write>
    106c:	8f e9       	ldi	r24, 0x9F	; 159
    106e:	9f e0       	ldi	r25, 0x0F	; 15
    1070:	01 97       	sbiw	r24, 0x01	; 1
    1072:	f1 f7       	brne	.-4      	; 0x1070 <lcd_init+0x7a>
    1074:	00 c0       	rjmp	.+0      	; 0x1076 <lcd_init+0x80>
    1076:	00 00       	nop
   _delay_ms(1);      // wait 5 ms
   // finally, set to 4-bit interface
   lcd_write(0x02,0,1);
    1078:	41 e0       	ldi	r20, 0x01	; 1
    107a:	60 e0       	ldi	r22, 0x00	; 0
    107c:	82 e0       	ldi	r24, 0x02	; 2
    107e:	f5 de       	rcall	.-534    	; 0xe6a <lcd_write>

   // set 2 lines and 5x7 dots /character mode
   // NFXX
   //   N = 1 2 lines  F = 1 5x10   F = 0 5x7
   lcd_write(0x28,0,0);
    1080:	40 e0       	ldi	r20, 0x00	; 0
    1082:	60 e0       	ldi	r22, 0x00	; 0
    1084:	88 e2       	ldi	r24, 0x28	; 40

   // from now the LCD only accepts 4 bit I/O, we can use lcd_command()
    lcd_clrscr();                     // display clear
    1086:	f1 de       	rcall	.-542    	; 0xe6a <lcd_write>
    1088:	9a df       	rcall	.-204    	; 0xfbe <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);    // set entry mode
    108a:	86 e0       	ldi	r24, 0x06	; 6
    108c:	80 df       	rcall	.-256    	; 0xf8e <lcd_command>
    108e:	8c 2f       	mov	r24, r28
	lcd_command(dispAttr);
    1090:	7e df       	rcall	.-260    	; 0xf8e <lcd_command>
    1092:	cf 91       	pop	r28
    1094:	08 95       	ret

00001096 <crc8>:
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
    1096:	61 15       	cp	r22, r1
    1098:	71 05       	cpc	r23, r1
    109a:	a9 f0       	breq	.+42     	; 0x10c6 <crc8+0x30>
    109c:	fc 01       	movw	r30, r24
    109e:	68 0f       	add	r22, r24
    10a0:	79 1f       	adc	r23, r25
    10a2:	80 e0       	ldi	r24, 0x00	; 0
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
    10a4:	48 e1       	ldi	r20, 0x18	; 24
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
	{
		b = data[loop_count];
    10a6:	21 91       	ld	r18, Z+
    10a8:	98 e0       	ldi	r25, 0x08	; 8
		
		bit_counter = 8;
		do {
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
    10aa:	38 2f       	mov	r19, r24
    10ac:	32 27       	eor	r19, r18
    10ae:	30 ff       	sbrs	r19, 0
    10b0:	0c c0       	rjmp	.+24     	; 0x10ca <crc8+0x34>
				crc = crc ^ CRC8POLY;
    10b2:	84 27       	eor	r24, r20
			}
			crc = (crc >> 1) & 0x7F;
    10b4:	86 95       	lsr	r24
			if ( feedback_bit == 0x01 ) {
				crc = crc | 0x80;
    10b6:	80 68       	ori	r24, 0x80	; 128
			}
		
			b = b >> 1;
    10b8:	26 95       	lsr	r18
    10ba:	91 50       	subi	r25, 0x01	; 1
			bit_counter--;
		
		} while (bit_counter > 0);
    10bc:	b1 f7       	brne	.-20     	; 0x10aa <crc8+0x14>
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;

	for (loop_count = 0; loop_count != number_of_bytes_in_data; loop_count++)
    10be:	e6 17       	cp	r30, r22
    10c0:	f7 07       	cpc	r31, r23
    10c2:	89 f7       	brne	.-30     	; 0x10a6 <crc8+0x10>
    10c4:	08 95       	ret
	uint16_t loop_count;
	uint8_t  bit_counter;
	uint8_t  b;
	uint8_t  feedback_bit;
	
	crc = CRC8INIT;
    10c6:	80 e0       	ldi	r24, 0x00	; 0
			bit_counter--;
		
		} while (bit_counter > 0);
	}
	
	return crc;
    10c8:	08 95       	ret
			feedback_bit = (crc ^ b) & 0x01;
	
			if ( feedback_bit == 0x01 ) {
				crc = crc ^ CRC8POLY;
			}
			crc = (crc >> 1) & 0x7F;
    10ca:	86 95       	lsr	r24
    10cc:	f5 cf       	rjmp	.-22     	; 0x10b8 <crc8+0x22>

000010ce <read_scratchpad>:
//********************************************************//

uint8_t DS18X20_conversion_in_progress(void)
{
	return ow_bit_io( 1 ) ? DS18X20_CONVERSION_DONE : DS18X20_CONVERTING;
}
    10ce:	ef 92       	push	r14
    10d0:	ff 92       	push	r15
    10d2:	0f 93       	push	r16
    10d4:	1f 93       	push	r17
    10d6:	cf 93       	push	r28
    10d8:	df 93       	push	r29
    10da:	7b 01       	movw	r14, r22
    10dc:	04 2f       	mov	r16, r20
    10de:	bc 01       	movw	r22, r24
    10e0:	8e eb       	ldi	r24, 0xBE	; 190
    10e2:	dd d1       	rcall	.+954    	; 0x149e <ow_command>
    10e4:	00 23       	and	r16, r16
    10e6:	61 f0       	breq	.+24     	; 0x1100 <read_scratchpad+0x32>
    10e8:	e7 01       	movw	r28, r14
    10ea:	01 50       	subi	r16, 0x01	; 1
    10ec:	10 e0       	ldi	r17, 0x00	; 0
    10ee:	0f 5f       	subi	r16, 0xFF	; 255
    10f0:	1f 4f       	sbci	r17, 0xFF	; 255
    10f2:	0e 0d       	add	r16, r14
    10f4:	1f 1d       	adc	r17, r15
    10f6:	7c d1       	rcall	.+760    	; 0x13f0 <ow_byte_rd>
    10f8:	89 93       	st	Y+, r24
    10fa:	c0 17       	cp	r28, r16
    10fc:	d1 07       	cpc	r29, r17
    10fe:	d9 f7       	brne	.-10     	; 0x10f6 <read_scratchpad+0x28>
    1100:	69 e0       	ldi	r22, 0x09	; 9
    1102:	70 e0       	ldi	r23, 0x00	; 0
    1104:	c7 01       	movw	r24, r14
    1106:	c7 df       	rcall	.-114    	; 0x1096 <crc8>
    1108:	81 11       	cpse	r24, r1
    110a:	83 e0       	ldi	r24, 0x03	; 3
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	1f 91       	pop	r17
    1112:	0f 91       	pop	r16
    1114:	ff 90       	pop	r15
    1116:	ef 90       	pop	r14
    1118:	08 95       	ret

0000111a <DS18X20_find_sensor>:
    111a:	0f 93       	push	r16
    111c:	1f 93       	push	r17
    111e:	cf 93       	push	r28
    1120:	df 93       	push	r29
    1122:	ec 01       	movw	r28, r24
    1124:	8b 01       	movw	r16, r22
    1126:	b8 01       	movw	r22, r16
    1128:	88 81       	ld	r24, Y
    112a:	65 d1       	rcall	.+714    	; 0x13f6 <ow_rom_search>
    112c:	88 83       	st	Y, r24
    112e:	81 50       	subi	r24, 0x01	; 1
    1130:	8d 3f       	cpi	r24, 0xFD	; 253
    1132:	50 f4       	brcc	.+20     	; 0x1148 <DS18X20_find_sensor+0x2e>
    1134:	f8 01       	movw	r30, r16
    1136:	80 81       	ld	r24, Z
    1138:	88 32       	cpi	r24, 0x28	; 40
    113a:	41 f0       	breq	.+16     	; 0x114c <DS18X20_find_sensor+0x32>
    113c:	80 31       	cpi	r24, 0x10	; 16
    113e:	41 f0       	breq	.+16     	; 0x1150 <DS18X20_find_sensor+0x36>
    1140:	82 32       	cpi	r24, 0x22	; 34
    1142:	89 f7       	brne	.-30     	; 0x1126 <DS18X20_find_sensor+0xc>
    1144:	80 e0       	ldi	r24, 0x00	; 0
    1146:	05 c0       	rjmp	.+10     	; 0x1152 <DS18X20_find_sensor+0x38>
    1148:	81 e0       	ldi	r24, 0x01	; 1
    114a:	03 c0       	rjmp	.+6      	; 0x1152 <DS18X20_find_sensor+0x38>
    114c:	80 e0       	ldi	r24, 0x00	; 0
    114e:	01 c0       	rjmp	.+2      	; 0x1152 <DS18X20_find_sensor+0x38>
    1150:	80 e0       	ldi	r24, 0x00	; 0
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	1f 91       	pop	r17
    1158:	0f 91       	pop	r16
    115a:	08 95       	ret

0000115c <DS18X20_start_meas>:
    115c:	1f 93       	push	r17
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	18 2f       	mov	r17, r24
    1164:	eb 01       	movw	r28, r22
    1166:	cf d0       	rcall	.+414    	; 0x1306 <ow_reset>
    1168:	a7 d0       	rcall	.+334    	; 0x12b8 <ow_input_pin_state>
    116a:	88 23       	and	r24, r24
    116c:	61 f0       	breq	.+24     	; 0x1186 <DS18X20_start_meas+0x2a>
    116e:	11 30       	cpi	r17, 0x01	; 1
    1170:	29 f0       	breq	.+10     	; 0x117c <DS18X20_start_meas+0x20>
    1172:	be 01       	movw	r22, r28
    1174:	84 e4       	ldi	r24, 0x44	; 68
    1176:	96 d1       	rcall	.+812    	; 0x14a4 <ow_command_with_parasite_enable>
    1178:	80 e0       	ldi	r24, 0x00	; 0
    117a:	0e c0       	rjmp	.+28     	; 0x1198 <DS18X20_start_meas+0x3c>
    117c:	be 01       	movw	r22, r28
    117e:	84 e4       	ldi	r24, 0x44	; 68
    1180:	8e d1       	rcall	.+796    	; 0x149e <ow_command>
    1182:	80 e0       	ldi	r24, 0x00	; 0
    1184:	09 c0       	rjmp	.+18     	; 0x1198 <DS18X20_start_meas+0x3c>
    1186:	8d e4       	ldi	r24, 0x4D	; 77
    1188:	92 e0       	ldi	r25, 0x02	; 2
    118a:	9f 93       	push	r25
    118c:	8f 93       	push	r24
    118e:	0e 94 11 22 	call	0x4422	; 0x4422 <printf>
    1192:	0f 90       	pop	r0
    1194:	0f 90       	pop	r0
    1196:	82 e0       	ldi	r24, 0x02	; 2
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	1f 91       	pop	r17
    119e:	08 95       	ret

000011a0 <DS18X20_read_maxres>:

	return temperaturevalue;
}

uint8_t DS18X20_read_maxres( uint8_t id[], long *temperaturevalue )
{
    11a0:	ef 92       	push	r14
    11a2:	ff 92       	push	r15
    11a4:	0f 93       	push	r16
    11a6:	1f 93       	push	r17
    11a8:	cf 93       	push	r28
    11aa:	df 93       	push	r29
    11ac:	cd b7       	in	r28, 0x3d	; 61
    11ae:	de b7       	in	r29, 0x3e	; 62
    11b0:	29 97       	sbiw	r28, 0x09	; 9
    11b2:	0f b6       	in	r0, 0x3f	; 63
    11b4:	f8 94       	cli
    11b6:	de bf       	out	0x3e, r29	; 62
    11b8:	0f be       	out	0x3f, r0	; 63
    11ba:	cd bf       	out	0x3d, r28	; 61
    11bc:	7c 01       	movw	r14, r24
    11be:	8b 01       	movw	r16, r22
	uint8_t sp[DS18X20_SP_SIZE];
	uint8_t ret;
	
	ow_reset();
    11c0:	a2 d0       	rcall	.+324    	; 0x1306 <ow_reset>
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
    11c2:	49 e0       	ldi	r20, 0x09	; 9
    11c4:	be 01       	movw	r22, r28
    11c6:	6f 5f       	subi	r22, 0xFF	; 255
    11c8:	7f 4f       	sbci	r23, 0xFF	; 255
    11ca:	c7 01       	movw	r24, r14
    11cc:	80 df       	rcall	.-256    	; 0x10ce <read_scratchpad>
    11ce:	e8 2f       	mov	r30, r24
	if ( ret == DS18X20_OK ) {
    11d0:	81 11       	cpse	r24, r1
    11d2:	64 c0       	rjmp	.+200    	; 0x129c <DS18X20_read_maxres+0xfc>
{
	uint16_t measure;
	uint8_t  negative;
	int32_t  temperaturevalue;

	measure = sp[0] | (sp[1] << 8);
    11d4:	4a 81       	ldd	r20, Y+2	; 0x02
    11d6:	50 e0       	ldi	r21, 0x00	; 0
    11d8:	54 2f       	mov	r21, r20
    11da:	44 27       	eor	r20, r20
    11dc:	89 81       	ldd	r24, Y+1	; 0x01
    11de:	48 2b       	or	r20, r24
	//measure = 0xFF5E; // test -10.125
	//measure = 0xFE6F; // test -25.0625

	if( familycode == DS18S20_FAMILY_CODE ) {   // 9 -> 12 bit if 18S20
    11e0:	d7 01       	movw	r26, r14
    11e2:	8c 91       	ld	r24, X
    11e4:	80 31       	cpi	r24, 0x10	; 16
    11e6:	71 f4       	brne	.+28     	; 0x1204 <DS18X20_read_maxres+0x64>
		/* Extended measurements for DS18S20 contributed by Carsten Foss */
		measure &= (uint16_t)0xfffe;   // Discard LSB, needed for later extended precicion calc
    11e8:	4e 7f       	andi	r20, 0xFE	; 254
		measure <<= 3;                 // Convert to 12-bit, now degrees are in 1/16 degrees units
    11ea:	44 0f       	add	r20, r20
    11ec:	55 1f       	adc	r21, r21
    11ee:	44 0f       	add	r20, r20
    11f0:	55 1f       	adc	r21, r21
    11f2:	44 0f       	add	r20, r20
    11f4:	55 1f       	adc	r21, r21
		measure += ( 16 - sp[6] ) - 4; // Add the compensation and remember to subtract 0.25 degree (4/16)
    11f6:	2f 81       	ldd	r18, Y+7	; 0x07
    11f8:	8c e0       	ldi	r24, 0x0C	; 12
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	82 1b       	sub	r24, r18
    11fe:	91 09       	sbc	r25, r1
    1200:	48 0f       	add	r20, r24
    1202:	59 1f       	adc	r21, r25
	}

	// Tarkastetaan onko negatiivinen 
	if ( measure & 0x8000 )  {
    1204:	55 23       	and	r21, r21
    1206:	6c f5       	brge	.+90     	; 0x1262 <DS18X20_read_maxres+0xc2>
		negative = 1;       // merkataan negatiivinen
		measure ^= 0xffff;  // muunna positiiviseksi => (kahden kmplementti)++
		measure++;
    1208:	51 95       	neg	r21
    120a:	41 95       	neg	r20
    120c:	51 09       	sbc	r21, r1
	}
	else {
		negative = 0;
	}	

	temperaturevalue  = (measure >> 4);
    120e:	9a 01       	movw	r18, r20
    1210:	32 95       	swap	r19
    1212:	22 95       	swap	r18
    1214:	2f 70       	andi	r18, 0x0F	; 15
    1216:	23 27       	eor	r18, r19
    1218:	3f 70       	andi	r19, 0x0F	; 15
    121a:	23 27       	eor	r18, r19
	temperaturevalue *= 10000;
    121c:	a0 e1       	ldi	r26, 0x10	; 16
    121e:	b7 e2       	ldi	r27, 0x27	; 39
    1220:	0e 94 cf 21 	call	0x439e	; 0x439e <__umulhisi3>
	temperaturevalue +=( measure & 0x000F ) * DS18X20_FRACCONV;
    1224:	4f 70       	andi	r20, 0x0F	; 15
    1226:	55 27       	eor	r21, r21
    1228:	a1 e7       	ldi	r26, 0x71	; 113
    122a:	b2 e0       	ldi	r27, 0x02	; 2
    122c:	4a 9f       	mul	r20, r26
    122e:	90 01       	movw	r18, r0
    1230:	4b 9f       	mul	r20, r27
    1232:	30 0d       	add	r19, r0
    1234:	5a 9f       	mul	r21, r26
    1236:	30 0d       	add	r19, r0
    1238:	11 24       	eor	r1, r1
    123a:	dc 01       	movw	r26, r24
    123c:	cb 01       	movw	r24, r22
    123e:	82 0f       	add	r24, r18
    1240:	93 1f       	adc	r25, r19
    1242:	a1 1d       	adc	r26, r1
    1244:	b1 1d       	adc	r27, r1

	if ( negative ) {
		temperaturevalue = -temperaturevalue;
    1246:	44 27       	eor	r20, r20
    1248:	55 27       	eor	r21, r21
    124a:	ba 01       	movw	r22, r20
    124c:	48 1b       	sub	r20, r24
    124e:	59 0b       	sbc	r21, r25
    1250:	6a 0b       	sbc	r22, r26
    1252:	7b 0b       	sbc	r23, r27
	uint8_t ret;
	
	ow_reset();
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
	if ( ret == DS18X20_OK ) {
		*temperaturevalue = DS18X20_raw_to_maxres( id[0], sp );
    1254:	d8 01       	movw	r26, r16
    1256:	4d 93       	st	X+, r20
    1258:	5d 93       	st	X+, r21
    125a:	6d 93       	st	X+, r22
    125c:	7c 93       	st	X, r23
    125e:	13 97       	sbiw	r26, 0x03	; 3
	}
	return ret;
    1260:	1d c0       	rjmp	.+58     	; 0x129c <DS18X20_read_maxres+0xfc>
	}
	else {
		negative = 0;
	}	

	temperaturevalue  = (measure >> 4);
    1262:	9a 01       	movw	r18, r20
    1264:	32 95       	swap	r19
    1266:	22 95       	swap	r18
    1268:	2f 70       	andi	r18, 0x0F	; 15
    126a:	23 27       	eor	r18, r19
    126c:	3f 70       	andi	r19, 0x0F	; 15
    126e:	23 27       	eor	r18, r19
	temperaturevalue *= 10000;
    1270:	a0 e1       	ldi	r26, 0x10	; 16
    1272:	b7 e2       	ldi	r27, 0x27	; 39
    1274:	0e 94 cf 21 	call	0x439e	; 0x439e <__umulhisi3>
	temperaturevalue +=( measure & 0x000F ) * DS18X20_FRACCONV;
    1278:	4f 70       	andi	r20, 0x0F	; 15
    127a:	55 27       	eor	r21, r21
    127c:	a1 e7       	ldi	r26, 0x71	; 113
    127e:	b2 e0       	ldi	r27, 0x02	; 2
    1280:	4a 9f       	mul	r20, r26
    1282:	90 01       	movw	r18, r0
    1284:	4b 9f       	mul	r20, r27
    1286:	30 0d       	add	r19, r0
    1288:	5a 9f       	mul	r21, r26
    128a:	30 0d       	add	r19, r0
    128c:	11 24       	eor	r1, r1
    128e:	ab 01       	movw	r20, r22
    1290:	bc 01       	movw	r22, r24
    1292:	42 0f       	add	r20, r18
    1294:	53 1f       	adc	r21, r19
    1296:	61 1d       	adc	r22, r1
    1298:	71 1d       	adc	r23, r1
    129a:	dc cf       	rjmp	.-72     	; 0x1254 <DS18X20_read_maxres+0xb4>
	ret = read_scratchpad( id, sp, DS18X20_SP_SIZE );
	if ( ret == DS18X20_OK ) {
		*temperaturevalue = DS18X20_raw_to_maxres( id[0], sp );
	}
	return ret;
}
    129c:	8e 2f       	mov	r24, r30
    129e:	29 96       	adiw	r28, 0x09	; 9
    12a0:	0f b6       	in	r0, 0x3f	; 63
    12a2:	f8 94       	cli
    12a4:	de bf       	out	0x3e, r29	; 62
    12a6:	0f be       	out	0x3f, r0	; 63
    12a8:	cd bf       	out	0x3d, r28	; 61
    12aa:	df 91       	pop	r29
    12ac:	cf 91       	pop	r28
    12ae:	1f 91       	pop	r17
    12b0:	0f 91       	pop	r16
    12b2:	ff 90       	pop	r15
    12b4:	ef 90       	pop	r14
    12b6:	08 95       	ret

000012b8 <ow_input_pin_state>:
	OW_DIR_OUT();
}

void ow_parasite_disable(void)
{
	OW_DIR_IN();
    12b8:	8f b1       	in	r24, 0x0f	; 15
    12ba:	80 78       	andi	r24, 0x80	; 128
    12bc:	08 95       	ret

000012be <ow_parasite_enable>:
    12be:	8f 9a       	sbi	0x11, 7	; 17
    12c0:	87 9a       	sbi	0x10, 7	; 16
    12c2:	08 95       	ret

000012c4 <ow_bit_io_intern>:
    12c4:	cf 93       	push	r28
    12c6:	c8 2f       	mov	r28, r24
    12c8:	f8 94       	cli
    12ca:	87 9a       	sbi	0x10, 7	; 16
    12cc:	8a e0       	ldi	r24, 0x0A	; 10
    12ce:	8a 95       	dec	r24
    12d0:	f1 f7       	brne	.-4      	; 0x12ce <ow_bit_io_intern+0xa>
    12d2:	00 c0       	rjmp	.+0      	; 0x12d4 <ow_bit_io_intern+0x10>
    12d4:	c1 11       	cpse	r28, r1
    12d6:	87 98       	cbi	0x10, 7	; 16
    12d8:	85 e4       	ldi	r24, 0x45	; 69
    12da:	8a 95       	dec	r24
    12dc:	f1 f7       	brne	.-4      	; 0x12da <ow_bit_io_intern+0x16>
    12de:	00 00       	nop
    12e0:	8f b1       	in	r24, 0x0f	; 15
    12e2:	88 0f       	add	r24, r24
    12e4:	88 0b       	sbc	r24, r24
    12e6:	c8 23       	and	r28, r24
    12e8:	85 ee       	ldi	r24, 0xE5	; 229
    12ea:	8a 95       	dec	r24
    12ec:	f1 f7       	brne	.-4      	; 0x12ea <ow_bit_io_intern+0x26>
    12ee:	00 00       	nop
    12f0:	87 98       	cbi	0x10, 7	; 16
    12f2:	61 11       	cpse	r22, r1
    12f4:	e4 df       	rcall	.-56     	; 0x12be <ow_parasite_enable>
    12f6:	85 e3       	ldi	r24, 0x35	; 53
    12f8:	8a 95       	dec	r24
    12fa:	f1 f7       	brne	.-4      	; 0x12f8 <ow_bit_io_intern+0x34>
    12fc:	00 00       	nop
    12fe:	78 94       	sei
    1300:	8c 2f       	mov	r24, r28
    1302:	cf 91       	pop	r28
    1304:	08 95       	ret

00001306 <ow_reset>:

uint8_t ow_reset(void)
{
	uint8_t err;
	
	OW_OUT_LOW();
    1306:	8f 98       	cbi	0x11, 7	; 17
	OW_DIR_OUT();            // Vedetn OW-Pinni alas: 480us
    1308:	87 9a       	sbi	0x10, 7	; 16
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    130a:	8f e7       	ldi	r24, 0x7F	; 127
    130c:	97 e0       	ldi	r25, 0x07	; 7
    130e:	01 97       	sbiw	r24, 0x01	; 1
    1310:	f1 f7       	brne	.-4      	; 0x130e <ow_reset+0x8>
    1312:	00 c0       	rjmp	.+0      	; 0x1314 <ow_reset+0xe>
    1314:	00 00       	nop
	_delay_us(480);

    cli();
    1316:	f8 94       	cli
	// Asetetaan pinni sisntuloksi - odotetaan, ett orjat vetvt alas
	OW_DIR_IN(); // sisntulo
    1318:	87 98       	cbi	0x10, 7	; 16
    131a:	ef ef       	ldi	r30, 0xFF	; 255
    131c:	f0 e0       	ldi	r31, 0x00	; 0
    131e:	31 97       	sbiw	r30, 0x01	; 1
    1320:	f1 f7       	brne	.-4      	; 0x131e <ow_reset+0x18>
    1322:	00 c0       	rjmp	.+0      	; 0x1324 <ow_reset+0x1e>
    1324:	00 00       	nop
	
	_delay_us(64);       // was 66
	err = OW_GET_IN();   // ei laitteita havaittu
    1326:	8f b1       	in	r24, 0x0f	; 15
    1328:	ef e7       	ldi	r30, 0x7F	; 127
    132a:	f6 e0       	ldi	r31, 0x06	; 6
    132c:	31 97       	sbiw	r30, 0x01	; 1
    132e:	f1 f7       	brne	.-4      	; 0x132c <ow_reset+0x26>
    1330:	00 c0       	rjmp	.+0      	; 0x1332 <ow_reset+0x2c>
    1332:	00 00       	nop
	
	// Viiveen jlkeen orjien tulisi vapauttaa linja
	// ja sisntulo-pinni palaa takaisin yltilaan ylsvetovastuksen toimesta
	
	_delay_us(480 - 64);       // was 480-66
	if( OW_GET_IN() == 0 ) {
    1334:	7f 9b       	sbis	0x0f, 7	; 15
    1336:	02 c0       	rjmp	.+4      	; 0x133c <ow_reset+0x36>
    cli();
	// Asetetaan pinni sisntuloksi - odotetaan, ett orjat vetvt alas
	OW_DIR_IN(); // sisntulo
	
	_delay_us(64);       // was 66
	err = OW_GET_IN();   // ei laitteita havaittu
    1338:	80 78       	andi	r24, 0x80	; 128
    133a:	01 c0       	rjmp	.+2      	; 0x133e <ow_reset+0x38>
	// Viiveen jlkeen orjien tulisi vapauttaa linja
	// ja sisntulo-pinni palaa takaisin yltilaan ylsvetovastuksen toimesta
	
	_delay_us(480 - 64);       // was 480-66
	if( OW_GET_IN() == 0 ) {
		err = 1;             // short circuit, expected low but got high
    133c:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	sei();
    133e:	78 94       	sei
	return err;
}
    1340:	08 95       	ret

00001342 <ow_bit_io>:
	return b;
}

uint8_t ow_bit_io( uint8_t b )
{
	return ow_bit_io_intern( b & 1, 0 );
    1342:	60 e0       	ldi	r22, 0x00	; 0
    1344:	81 70       	andi	r24, 0x01	; 1
    1346:	be cf       	rjmp	.-132    	; 0x12c4 <ow_bit_io_intern>
}
    1348:	08 95       	ret

0000134a <ow_byte_wr>:

uint8_t ow_byte_wr( uint8_t b )
{
    134a:	cf 93       	push	r28
    134c:	df 93       	push	r29
    134e:	c8 2f       	mov	r28, r24
    1350:	d8 e0       	ldi	r29, 0x08	; 8
	uint8_t i = 8, j;
	
	do {
		j = ow_bit_io( b & 1 );
    1352:	8c 2f       	mov	r24, r28
    1354:	81 70       	andi	r24, 0x01	; 1
    1356:	f5 df       	rcall	.-22     	; 0x1342 <ow_bit_io>
		b >>= 1;
    1358:	c6 95       	lsr	r28
		if( j ) {
    135a:	81 11       	cpse	r24, r1
			b |= 0x80;
    135c:	c0 68       	ori	r28, 0x80	; 128
    135e:	d1 50       	subi	r29, 0x01	; 1
		}
	} while( --i );
    1360:	c1 f7       	brne	.-16     	; 0x1352 <ow_byte_wr+0x8>
	
	return b;
}
    1362:	8c 2f       	mov	r24, r28
    1364:	df 91       	pop	r29
    1366:	cf 91       	pop	r28
    1368:	08 95       	ret

0000136a <ow_byte_wr_with_parasite_enable>:

uint8_t ow_byte_wr_with_parasite_enable( uint8_t b )
{
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	c8 2f       	mov	r28, r24
	uint8_t i = 8, j;
    1370:	d8 e0       	ldi	r29, 0x08	; 8
	
	do {
		if ( i != 1 ) {
    1372:	d1 30       	cpi	r29, 0x01	; 1
    1374:	41 f0       	breq	.+16     	; 0x1386 <ow_byte_wr_with_parasite_enable+0x1c>
			j = ow_bit_io_intern( b & 1, 0 );
    1376:	60 e0       	ldi	r22, 0x00	; 0
    1378:	8c 2f       	mov	r24, r28
    137a:	81 70       	andi	r24, 0x01	; 1
    137c:	a3 df       	rcall	.-186    	; 0x12c4 <ow_bit_io_intern>
		} else {
			j = ow_bit_io_intern( b & 1, 1 );
		}
		b >>= 1;
    137e:	c6 95       	lsr	r28
		if( j ) {
    1380:	81 11       	cpse	r24, r1
    1382:	08 c0       	rjmp	.+16     	; 0x1394 <ow_byte_wr_with_parasite_enable+0x2a>
    1384:	08 c0       	rjmp	.+16     	; 0x1396 <ow_byte_wr_with_parasite_enable+0x2c>
	
	do {
		if ( i != 1 ) {
			j = ow_bit_io_intern( b & 1, 0 );
		} else {
			j = ow_bit_io_intern( b & 1, 1 );
    1386:	61 e0       	ldi	r22, 0x01	; 1
    1388:	8c 2f       	mov	r24, r28
    138a:	81 70       	andi	r24, 0x01	; 1
    138c:	9b df       	rcall	.-202    	; 0x12c4 <ow_bit_io_intern>
		}
		b >>= 1;
    138e:	c6 95       	lsr	r28
		if( j ) {
    1390:	88 23       	and	r24, r24
    1392:	19 f0       	breq	.+6      	; 0x139a <ow_byte_wr_with_parasite_enable+0x30>
			b |= 0x80;
    1394:	c0 68       	ori	r28, 0x80	; 128
		}
	} while( --i );
    1396:	d1 50       	subi	r29, 0x01	; 1
    1398:	61 f7       	brne	.-40     	; 0x1372 <ow_byte_wr_with_parasite_enable+0x8>
	
	return b;
}
    139a:	8c 2f       	mov	r24, r28
    139c:	df 91       	pop	r29
    139e:	cf 91       	pop	r28
    13a0:	08 95       	ret

000013a2 <ow_command_intern>:
	return next_diff;                   // jatketaan etsint
}


static void ow_command_intern( uint8_t command, uint8_t *id, uint8_t with_parasite_enable )
{
    13a2:	ef 92       	push	r14
    13a4:	ff 92       	push	r15
    13a6:	0f 93       	push	r16
    13a8:	1f 93       	push	r17
    13aa:	cf 93       	push	r28
    13ac:	df 93       	push	r29
    13ae:	e8 2e       	mov	r14, r24
    13b0:	eb 01       	movw	r28, r22
    13b2:	f4 2e       	mov	r15, r20
	uint8_t i;

	ow_reset();
    13b4:	a8 df       	rcall	.-176    	; 0x1306 <ow_reset>

	if( id ) {
    13b6:	20 97       	sbiw	r28, 0x00	; 0
    13b8:	59 f0       	breq	.+22     	; 0x13d0 <ow_command_intern+0x2e>
		ow_byte_wr( OW_MATCH_ROM );     // yksittiselle laitteelle, osoitetaan tietty anturia
    13ba:	85 e5       	ldi	r24, 0x55	; 85
    13bc:	c6 df       	rcall	.-116    	; 0x134a <ow_byte_wr>
    13be:	8e 01       	movw	r16, r28
    13c0:	08 5f       	subi	r16, 0xF8	; 248
    13c2:	1f 4f       	sbci	r17, 0xFF	; 255
		i = OW_ROMCODE_SIZE;			
		do {
			ow_byte_wr( *id );
    13c4:	89 91       	ld	r24, Y+
    13c6:	c1 df       	rcall	.-126    	; 0x134a <ow_byte_wr>
    13c8:	c0 17       	cp	r28, r16
			id++;
		} while( --i );
    13ca:	d1 07       	cpc	r29, r17
    13cc:	d9 f7       	brne	.-10     	; 0x13c4 <ow_command_intern+0x22>
    13ce:	02 c0       	rjmp	.+4      	; 0x13d4 <ow_command_intern+0x32>
	} 
	else {
		ow_byte_wr( OW_SKIP_ROM );      // kaikille laitteille, sstetn aikaa vylll, 
    13d0:	8c ec       	ldi	r24, 0xCC	; 204
    13d2:	bb df       	rcall	.-138    	; 0x134a <ow_byte_wr>
										// jossa vain yksi anturi
	}									 
	
	if ( with_parasite_enable  ) {
    13d4:	ff 20       	and	r15, r15
    13d6:	19 f0       	breq	.+6      	; 0x13de <ow_command_intern+0x3c>
		ow_byte_wr_with_parasite_enable( command );
    13d8:	8e 2d       	mov	r24, r14
    13da:	c7 df       	rcall	.-114    	; 0x136a <ow_byte_wr_with_parasite_enable>
    13dc:	02 c0       	rjmp	.+4      	; 0x13e2 <ow_command_intern+0x40>
	} else {
		ow_byte_wr( command );
    13de:	8e 2d       	mov	r24, r14
    13e0:	b4 df       	rcall	.-152    	; 0x134a <ow_byte_wr>
    13e2:	df 91       	pop	r29
	}
}
    13e4:	cf 91       	pop	r28
    13e6:	1f 91       	pop	r17
    13e8:	0f 91       	pop	r16
    13ea:	ff 90       	pop	r15
    13ec:	ef 90       	pop	r14
    13ee:	08 95       	ret

000013f0 <ow_byte_rd>:
    13f0:	8f ef       	ldi	r24, 0xFF	; 255

uint8_t ow_byte_rd( void )
{
	// read by sending only "1"s, so bus gets released
	// after the init low-pulse in every slot
	return ow_byte_wr( 0xFF ); 
    13f2:	ab cf       	rjmp	.-170    	; 0x134a <ow_byte_wr>
}
    13f4:	08 95       	ret

000013f6 <ow_rom_search>:


uint8_t ow_rom_search( uint8_t diff, uint8_t *id )
{
    13f6:	df 92       	push	r13
    13f8:	ef 92       	push	r14
    13fa:	ff 92       	push	r15
    13fc:	0f 93       	push	r16
    13fe:	1f 93       	push	r17
    1400:	cf 93       	push	r28
    1402:	df 93       	push	r29
    1404:	d8 2e       	mov	r13, r24
    1406:	8b 01       	movw	r16, r22
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) {
    1408:	7e df       	rcall	.-260    	; 0x1306 <ow_reset>
    140a:	81 11       	cpse	r24, r1
    140c:	28 c0       	rjmp	.+80     	; 0x145e <ow_rom_search+0x68>
		return OW_PRESENCE_ERR;         // error, no device found <--- early exit!
	}
	
	ow_byte_wr( OW_SEARCH_ROM );        // ROM search komento
    140e:	80 ef       	ldi	r24, 0xF0	; 240
    1410:	9c df       	rcall	.-200    	; 0x134a <ow_byte_wr>
	next_diff = OW_LAST_DEVICE;         // unchanged on last device
    1412:	e1 2c       	mov	r14, r1
	
	i = OW_ROMCODE_SIZE * 8;            // 8 tavua
    1414:	c0 e4       	ldi	r28, 0x40	; 64
    1416:	0f 2e       	mov	r0, r31
    1418:	f8 ef       	ldi	r31, 0xF8	; 248
    141a:	ff 2e       	mov	r15, r31
    141c:	f0 2d       	mov	r31, r0
	
	do {
		j = 8;                          // 8 bitti
		do {
			b = ow_bit_io( 1 );         // lue bitti
    141e:	fc 0e       	add	r15, r28
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	8f df       	rcall	.-226    	; 0x1342 <ow_bit_io>
			if( ow_bit_io( 1 ) ) {      // lue komplementti bitti
    1424:	d8 2f       	mov	r29, r24
    1426:	81 e0       	ldi	r24, 0x01	; 1
    1428:	8c df       	rcall	.-232    	; 0x1342 <ow_bit_io>
    142a:	88 23       	and	r24, r24
    142c:	19 f0       	breq	.+6      	; 0x1434 <ow_rom_search+0x3e>
				if( b ) {               // 0b11
    142e:	dd 23       	and	r29, r29
    1430:	d1 f0       	breq	.+52     	; 0x1466 <ow_rom_search+0x70>
    1432:	17 c0       	rjmp	.+46     	; 0x1462 <ow_rom_search+0x6c>
					return OW_DATA_ERR; // data error <--- early exit!
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
    1434:	d1 11       	cpse	r29, r1
    1436:	23 c0       	rjmp	.+70     	; 0x147e <ow_rom_search+0x88>
					if( diff > i || ((*id & 1) && diff != i) ) {
    1438:	cd 15       	cp	r28, r13
    143a:	e0 f0       	brcs	.+56     	; 0x1474 <ow_rom_search+0x7e>
    143c:	f8 01       	movw	r30, r16
    143e:	80 81       	ld	r24, Z
    1440:	80 ff       	sbrs	r24, 0
    1442:	11 c0       	rjmp	.+34     	; 0x1466 <ow_rom_search+0x70>
    1444:	cd 11       	cpse	r28, r13
    1446:	19 c0       	rjmp	.+50     	; 0x147a <ow_rom_search+0x84>
    1448:	0e c0       	rjmp	.+28     	; 0x1466 <ow_rom_search+0x70>
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
			}
			
			i--;
    144a:	c1 50       	subi	r28, 0x01	; 1
			
		} while( --j );
    144c:	fc 12       	cpse	r15, r28
    144e:	e8 cf       	rjmp	.-48     	; 0x1420 <ow_rom_search+0x2a>
		
		id++;                           // seuraava tavu
    1450:	0f 5f       	subi	r16, 0xFF	; 255
    1452:	1f 4f       	sbci	r17, 0xFF	; 255
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
			}
			
			i--;
    1454:	cf 2d       	mov	r28, r15
			
		} while( --j );
		
		id++;                           // seuraava tavu
	
	} while( i );
    1456:	f1 10       	cpse	r15, r1
    1458:	de cf       	rjmp	.-68     	; 0x1416 <ow_rom_search+0x20>
    145a:	8e 2d       	mov	r24, r14
    145c:	18 c0       	rjmp	.+48     	; 0x148e <ow_rom_search+0x98>
{
	uint8_t i, j, next_diff;
	uint8_t b;
	
	if( ow_reset() ) {
		return OW_PRESENCE_ERR;         // error, no device found <--- early exit!
    145e:	8f ef       	ldi	r24, 0xFF	; 255
		j = 8;                          // 8 bitti
		do {
			b = ow_bit_io( 1 );         // lue bitti
			if( ow_bit_io( 1 ) ) {      // lue komplementti bitti
				if( b ) {               // 0b11
					return OW_DATA_ERR; // data error <--- early exit!
    1460:	16 c0       	rjmp	.+44     	; 0x148e <ow_rom_search+0x98>
    1462:	8e ef       	ldi	r24, 0xFE	; 254
						b = 1;          // nyt 1
						next_diff = i;  // next pass 0
					}
				}
			}
			ow_bit_io( b );             // kirjoita bitti
    1464:	14 c0       	rjmp	.+40     	; 0x148e <ow_rom_search+0x98>
    1466:	80 e0       	ldi	r24, 0x00	; 0
    1468:	6c df       	rcall	.-296    	; 0x1342 <ow_bit_io>
			*id >>= 1;
    146a:	f8 01       	movw	r30, r16
    146c:	90 81       	ld	r25, Z
    146e:	96 95       	lsr	r25
    1470:	90 83       	st	Z, r25
    1472:	eb cf       	rjmp	.-42     	; 0x144a <ow_rom_search+0x54>
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
						next_diff = i;  // next pass 0
    1474:	ec 2e       	mov	r14, r28
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
    1476:	d1 e0       	ldi	r29, 0x01	; 1
						next_diff = i;  // next pass 0
    1478:	02 c0       	rjmp	.+4      	; 0x147e <ow_rom_search+0x88>
				}
			}
			else {
				if( !b ) {              // 0b00 = 2 devices
					if( diff > i || ((*id & 1) && diff != i) ) {
						b = 1;          // nyt 1
    147a:	ec 2e       	mov	r14, r28
						next_diff = i;  // next pass 0
					}
				}
			}
			ow_bit_io( b );             // kirjoita bitti
    147c:	d1 e0       	ldi	r29, 0x01	; 1
    147e:	8d 2f       	mov	r24, r29
    1480:	60 df       	rcall	.-320    	; 0x1342 <ow_bit_io>
			*id >>= 1;
			if( b ) {
				*id |= 0x80;            // talleta bitti
    1482:	f8 01       	movw	r30, r16
    1484:	90 81       	ld	r25, Z
    1486:	96 95       	lsr	r25
    1488:	90 68       	ori	r25, 0x80	; 128
    148a:	90 83       	st	Z, r25
    148c:	de cf       	rjmp	.-68     	; 0x144a <ow_rom_search+0x54>
		id++;                           // seuraava tavu
	
	} while( i );
	
	return next_diff;                   // jatketaan etsint
}
    148e:	df 91       	pop	r29
    1490:	cf 91       	pop	r28
    1492:	1f 91       	pop	r17
    1494:	0f 91       	pop	r16
    1496:	ff 90       	pop	r15
    1498:	ef 90       	pop	r14
    149a:	df 90       	pop	r13
    149c:	08 95       	ret

0000149e <ow_command>:
	}
}

void ow_command( uint8_t command, uint8_t *id )
{
	ow_command_intern( command, id, 0);
    149e:	40 e0       	ldi	r20, 0x00	; 0
    14a0:	80 cf       	rjmp	.-256    	; 0x13a2 <ow_command_intern>
    14a2:	08 95       	ret

000014a4 <ow_command_with_parasite_enable>:
}

void ow_command_with_parasite_enable( uint8_t command, uint8_t *id )
{
	ow_command_intern( command, id, 1 );
    14a4:	41 e0       	ldi	r20, 0x01	; 1
    14a6:	7d cf       	rjmp	.-262    	; 0x13a2 <ow_command_intern>
    14a8:	08 95       	ret

000014aa <search_sensors>:
}

uint8_t search_sensors(void)
{
    14aa:	cf 92       	push	r12
    14ac:	df 92       	push	r13
    14ae:	ff 92       	push	r15
    14b0:	0f 93       	push	r16
    14b2:	1f 93       	push	r17
    14b4:	cf 93       	push	r28
    14b6:	df 93       	push	r29
    14b8:	cd b7       	in	r28, 0x3d	; 61
    14ba:	de b7       	in	r29, 0x3e	; 62
    14bc:	29 97       	sbiw	r28, 0x09	; 9
    14be:	0f b6       	in	r0, 0x3f	; 63
    14c0:	f8 94       	cli
    14c2:	de bf       	out	0x3e, r29	; 62
    14c4:	0f be       	out	0x3f, r0	; 63
    14c6:	cd bf       	out	0x3d, r28	; 61
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    14c8:	2f ef       	ldi	r18, 0xFF	; 255
    14ca:	89 eb       	ldi	r24, 0xB9	; 185
    14cc:	9b ed       	ldi	r25, 0xDB	; 219
    14ce:	21 50       	subi	r18, 0x01	; 1
    14d0:	80 40       	sbci	r24, 0x00	; 0
    14d2:	90 40       	sbci	r25, 0x00	; 0
    14d4:	e1 f7       	brne	.-8      	; 0x14ce <search_sensors+0x24>
    14d6:	00 c0       	rjmp	.+0      	; 0x14d8 <search_sensors+0x2e>
    14d8:	00 00       	nop
	uint8_t id[OW_ROMCODE_SIZE];
	uint8_t diff, numberOfSensors;
	
	_delay_ms(1500*3);

	ow_reset();
    14da:	15 df       	rcall	.-470    	; 0x1306 <ow_reset>

	numberOfSensors = 0;
	
	diff = OW_SEARCH_FIRST;
    14dc:	8f ef       	ldi	r24, 0xFF	; 255
    14de:	89 87       	std	Y+9, r24	; 0x09
    14e0:	0f 2e       	mov	r0, r31
    14e2:	ff ee       	ldi	r31, 0xEF	; 239
    14e4:	cf 2e       	mov	r12, r31
    14e6:	f5 e1       	ldi	r31, 0x15	; 21
    14e8:	df 2e       	mov	r13, r31
    14ea:	f0 2d       	mov	r31, r0
    14ec:	f1 2c       	mov	r15, r1
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
		DS18X20_find_sensor( &diff, &id[0] );
    14ee:	8e 01       	movw	r16, r28
    14f0:	07 5f       	subi	r16, 0xF7	; 247
    14f2:	1f 4f       	sbci	r17, 0xFF	; 255
    14f4:	be 01       	movw	r22, r28
    14f6:	6f 5f       	subi	r22, 0xFF	; 255
    14f8:	7f 4f       	sbci	r23, 0xFF	; 255
    14fa:	c8 01       	movw	r24, r16
    14fc:	0e de       	rcall	.-996    	; 0x111a <DS18X20_find_sensor>
	
		if (diff != OW_PRESENCE_ERR)
    14fe:	99 85       	ldd	r25, Y+9	; 0x09
    1500:	9f 3f       	cpi	r25, 0xFF	; 255
    1502:	89 f0       	breq	.+34     	; 0x1526 <search_sensors+0x7c>
    1504:	fe 01       	movw	r30, r28
    1506:	31 96       	adiw	r30, 0x01	; 1
    1508:	d6 01       	movw	r26, r12
		{
		  for ( i=0; i < OW_ROMCODE_SIZE; i++ )
		    	getSensorIDs[numberOfSensors][i] = id[i];
    150a:	81 91       	ld	r24, Z+
    150c:	8d 93       	st	X+, r24
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
		DS18X20_find_sensor( &diff, &id[0] );
	
		if (diff != OW_PRESENCE_ERR)
		{
		  for ( i=0; i < OW_ROMCODE_SIZE; i++ )
    150e:	e0 17       	cp	r30, r16
    1510:	f1 07       	cpc	r31, r17
    1512:	d9 f7       	brne	.-10     	; 0x150a <search_sensors+0x60>
		    	getSensorIDs[numberOfSensors][i] = id[i];
	  	
		  numberOfSensors++;
    1514:	f3 94       	inc	r15
	ow_reset();

	numberOfSensors = 0;
	
	diff = OW_SEARCH_FIRST;
	while ( diff != OW_LAST_DEVICE && numberOfSensors < MAXSENSORS ) {
    1516:	99 23       	and	r25, r25
    1518:	31 f0       	breq	.+12     	; 0x1526 <search_sensors+0x7c>
    151a:	28 e0       	ldi	r18, 0x08	; 8
    151c:	c2 0e       	add	r12, r18
    151e:	d1 1c       	adc	r13, r1
    1520:	88 e0       	ldi	r24, 0x08	; 8
    1522:	f8 12       	cpse	r15, r24
    1524:	e7 cf       	rjmp	.-50     	; 0x14f4 <search_sensors+0x4a>
		else
		  break;
	}
	
	return numberOfSensors;
}
    1526:	8f 2d       	mov	r24, r15
    1528:	29 96       	adiw	r28, 0x09	; 9
    152a:	0f b6       	in	r0, 0x3f	; 63
    152c:	f8 94       	cli
    152e:	de bf       	out	0x3e, r29	; 62
    1530:	0f be       	out	0x3f, r0	; 63
    1532:	cd bf       	out	0x3d, r28	; 61
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	1f 91       	pop	r17
    153a:	0f 91       	pop	r16
    153c:	ff 90       	pop	r15
    153e:	df 90       	pop	r13
    1540:	cf 90       	pop	r12
    1542:	08 95       	ret

00001544 <GetSensorCount>:

unsigned char GetSensorCount(void)
{
  return search_sensors();
    1544:	b2 cf       	rjmp	.-156    	; 0x14aa <search_sensors>
}
    1546:	08 95       	ret

00001548 <GetTemperature>:

long    GetTemperature( unsigned nSensor)
{ long temperature;
    1548:	0f 93       	push	r16
    154a:	1f 93       	push	r17
    154c:	cf 93       	push	r28
    154e:	df 93       	push	r29
    1550:	00 d0       	rcall	.+0      	; 0x1552 <GetTemperature+0xa>
    1552:	1f 92       	push	r1
    1554:	cd b7       	in	r28, 0x3d	; 61
    1556:	de b7       	in	r29, 0x3e	; 62
    1558:	8c 01       	movw	r16, r24
   
   DS18X20_start_meas( DS18X20_POWER_PARASITE, NULL );
    155a:	60 e0       	ldi	r22, 0x00	; 0
    155c:	70 e0       	ldi	r23, 0x00	; 0
    155e:	80 e0       	ldi	r24, 0x00	; 0
    1560:	fd dd       	rcall	.-1030   	; 0x115c <DS18X20_start_meas>
    1562:	2f ef       	ldi	r18, 0xFF	; 255
    1564:	8e e9       	ldi	r24, 0x9E	; 158
    1566:	94 e2       	ldi	r25, 0x24	; 36
    1568:	21 50       	subi	r18, 0x01	; 1
    156a:	80 40       	sbci	r24, 0x00	; 0
    156c:	90 40       	sbci	r25, 0x00	; 0
    156e:	e1 f7       	brne	.-8      	; 0x1568 <GetTemperature+0x20>
    1570:	00 c0       	rjmp	.+0      	; 0x1572 <GetTemperature+0x2a>
    1572:	00 00       	nop
	  
   _delay_ms( DS18B20_TCONV_12BIT );

   DS18X20_read_maxres( &getSensorIDs[nSensor][0], &temperature );
    1574:	c8 01       	movw	r24, r16
    1576:	88 0f       	add	r24, r24
    1578:	99 1f       	adc	r25, r25
    157a:	88 0f       	add	r24, r24
    157c:	99 1f       	adc	r25, r25
    157e:	88 0f       	add	r24, r24
    1580:	99 1f       	adc	r25, r25
    1582:	be 01       	movw	r22, r28
    1584:	6f 5f       	subi	r22, 0xFF	; 255
    1586:	7f 4f       	sbci	r23, 0xFF	; 255
    1588:	81 51       	subi	r24, 0x11	; 17
    158a:	9a 4e       	sbci	r25, 0xEA	; 234
    158c:	09 de       	rcall	.-1006   	; 0x11a0 <DS18X20_read_maxres>
   return temperature;
    158e:	69 81       	ldd	r22, Y+1	; 0x01
    1590:	7a 81       	ldd	r23, Y+2	; 0x02
    1592:	8b 81       	ldd	r24, Y+3	; 0x03
    1594:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1596:	0f 90       	pop	r0
    1598:	0f 90       	pop	r0
    159a:	0f 90       	pop	r0
    159c:	0f 90       	pop	r0
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	1f 91       	pop	r17
    15a4:	0f 91       	pop	r16
    15a6:	08 95       	ret

000015a8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    15a8:	cf 93       	push	r28
    15aa:	df 93       	push	r29
    15ac:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    15ae:	0e 94 06 16 	call	0x2c0c	; 0x2c0c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    15b2:	80 91 65 03 	lds	r24, 0x0365	; 0x800365 <pucAlignedHeap.2023>
    15b6:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <pucAlignedHeap.2023+0x1>
    15ba:	89 2b       	or	r24, r25
    15bc:	31 f4       	brne	.+12     	; 0x15ca <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    15be:	8a e6       	ldi	r24, 0x6A	; 106
    15c0:	93 e0       	ldi	r25, 0x03	; 3
    15c2:	90 93 66 03 	sts	0x0366, r25	; 0x800366 <pucAlignedHeap.2023+0x1>
    15c6:	80 93 65 03 	sts	0x0365, r24	; 0x800365 <pucAlignedHeap.2023>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    15ca:	20 91 67 03 	lds	r18, 0x0367	; 0x800367 <xNextFreeByte>
    15ce:	30 91 68 03 	lds	r19, 0x0368	; 0x800368 <xNextFreeByte+0x1>
    15d2:	c9 01       	movw	r24, r18
    15d4:	8c 0f       	add	r24, r28
    15d6:	9d 1f       	adc	r25, r29
    15d8:	8f 3f       	cpi	r24, 0xFF	; 255
    15da:	41 e1       	ldi	r20, 0x11	; 17
    15dc:	94 07       	cpc	r25, r20
    15de:	70 f4       	brcc	.+28     	; 0x15fc <pvPortMalloc+0x54>
    15e0:	28 17       	cp	r18, r24
    15e2:	39 07       	cpc	r19, r25
    15e4:	70 f4       	brcc	.+28     	; 0x1602 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    15e6:	c0 91 65 03 	lds	r28, 0x0365	; 0x800365 <pucAlignedHeap.2023>
    15ea:	d0 91 66 03 	lds	r29, 0x0366	; 0x800366 <pucAlignedHeap.2023+0x1>
    15ee:	c2 0f       	add	r28, r18
    15f0:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    15f2:	90 93 68 03 	sts	0x0368, r25	; 0x800368 <xNextFreeByte+0x1>
    15f6:	80 93 67 03 	sts	0x0367, r24	; 0x800367 <xNextFreeByte>
    15fa:	05 c0       	rjmp	.+10     	; 0x1606 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    15fc:	c0 e0       	ldi	r28, 0x00	; 0
    15fe:	d0 e0       	ldi	r29, 0x00	; 0
    1600:	02 c0       	rjmp	.+4      	; 0x1606 <pvPortMalloc+0x5e>
    1602:	c0 e0       	ldi	r28, 0x00	; 0
    1604:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1606:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    160a:	ce 01       	movw	r24, r28
    160c:	df 91       	pop	r29
    160e:	cf 91       	pop	r28
    1610:	08 95       	ret

00001612 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1612:	08 95       	ret

00001614 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1614:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1616:	03 96       	adiw	r24, 0x03	; 3
    1618:	92 83       	std	Z+2, r25	; 0x02
    161a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    161c:	2f ef       	ldi	r18, 0xFF	; 255
    161e:	3f ef       	ldi	r19, 0xFF	; 255
    1620:	34 83       	std	Z+4, r19	; 0x04
    1622:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1624:	96 83       	std	Z+6, r25	; 0x06
    1626:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1628:	90 87       	std	Z+8, r25	; 0x08
    162a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    162c:	10 82       	st	Z, r1
    162e:	08 95       	ret

00001630 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1630:	fc 01       	movw	r30, r24
    1632:	11 86       	std	Z+9, r1	; 0x09
    1634:	10 86       	std	Z+8, r1	; 0x08
    1636:	08 95       	ret

00001638 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1638:	cf 93       	push	r28
    163a:	df 93       	push	r29
    163c:	9c 01       	movw	r18, r24
    163e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1640:	dc 01       	movw	r26, r24
    1642:	11 96       	adiw	r26, 0x01	; 1
    1644:	cd 91       	ld	r28, X+
    1646:	dc 91       	ld	r29, X
    1648:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    164a:	d3 83       	std	Z+3, r29	; 0x03
    164c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    164e:	8c 81       	ldd	r24, Y+4	; 0x04
    1650:	9d 81       	ldd	r25, Y+5	; 0x05
    1652:	95 83       	std	Z+5, r25	; 0x05
    1654:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1656:	8c 81       	ldd	r24, Y+4	; 0x04
    1658:	9d 81       	ldd	r25, Y+5	; 0x05
    165a:	dc 01       	movw	r26, r24
    165c:	13 96       	adiw	r26, 0x03	; 3
    165e:	7c 93       	st	X, r23
    1660:	6e 93       	st	-X, r22
    1662:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1664:	7d 83       	std	Y+5, r23	; 0x05
    1666:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1668:	31 87       	std	Z+9, r19	; 0x09
    166a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    166c:	f9 01       	movw	r30, r18
    166e:	80 81       	ld	r24, Z
    1670:	8f 5f       	subi	r24, 0xFF	; 255
    1672:	80 83       	st	Z, r24
}
    1674:	df 91       	pop	r29
    1676:	cf 91       	pop	r28
    1678:	08 95       	ret

0000167a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    167a:	cf 93       	push	r28
    167c:	df 93       	push	r29
    167e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1680:	48 81       	ld	r20, Y
    1682:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1684:	4f 3f       	cpi	r20, 0xFF	; 255
    1686:	2f ef       	ldi	r18, 0xFF	; 255
    1688:	52 07       	cpc	r21, r18
    168a:	21 f4       	brne	.+8      	; 0x1694 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    168c:	fc 01       	movw	r30, r24
    168e:	a7 81       	ldd	r26, Z+7	; 0x07
    1690:	b0 85       	ldd	r27, Z+8	; 0x08
    1692:	0d c0       	rjmp	.+26     	; 0x16ae <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1694:	dc 01       	movw	r26, r24
    1696:	13 96       	adiw	r26, 0x03	; 3
    1698:	01 c0       	rjmp	.+2      	; 0x169c <vListInsert+0x22>
    169a:	df 01       	movw	r26, r30
    169c:	12 96       	adiw	r26, 0x02	; 2
    169e:	ed 91       	ld	r30, X+
    16a0:	fc 91       	ld	r31, X
    16a2:	13 97       	sbiw	r26, 0x03	; 3
    16a4:	20 81       	ld	r18, Z
    16a6:	31 81       	ldd	r19, Z+1	; 0x01
    16a8:	42 17       	cp	r20, r18
    16aa:	53 07       	cpc	r21, r19
    16ac:	b0 f7       	brcc	.-20     	; 0x169a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    16ae:	12 96       	adiw	r26, 0x02	; 2
    16b0:	ed 91       	ld	r30, X+
    16b2:	fc 91       	ld	r31, X
    16b4:	13 97       	sbiw	r26, 0x03	; 3
    16b6:	fb 83       	std	Y+3, r31	; 0x03
    16b8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    16ba:	d5 83       	std	Z+5, r29	; 0x05
    16bc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    16be:	bd 83       	std	Y+5, r27	; 0x05
    16c0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    16c2:	13 96       	adiw	r26, 0x03	; 3
    16c4:	dc 93       	st	X, r29
    16c6:	ce 93       	st	-X, r28
    16c8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16ca:	99 87       	std	Y+9, r25	; 0x09
    16cc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    16ce:	fc 01       	movw	r30, r24
    16d0:	20 81       	ld	r18, Z
    16d2:	2f 5f       	subi	r18, 0xFF	; 255
    16d4:	20 83       	st	Z, r18
}
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	08 95       	ret

000016dc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    16dc:	cf 93       	push	r28
    16de:	df 93       	push	r29
    16e0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    16e2:	a0 85       	ldd	r26, Z+8	; 0x08
    16e4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    16e6:	c2 81       	ldd	r28, Z+2	; 0x02
    16e8:	d3 81       	ldd	r29, Z+3	; 0x03
    16ea:	84 81       	ldd	r24, Z+4	; 0x04
    16ec:	95 81       	ldd	r25, Z+5	; 0x05
    16ee:	9d 83       	std	Y+5, r25	; 0x05
    16f0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    16f2:	c4 81       	ldd	r28, Z+4	; 0x04
    16f4:	d5 81       	ldd	r29, Z+5	; 0x05
    16f6:	82 81       	ldd	r24, Z+2	; 0x02
    16f8:	93 81       	ldd	r25, Z+3	; 0x03
    16fa:	9b 83       	std	Y+3, r25	; 0x03
    16fc:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    16fe:	11 96       	adiw	r26, 0x01	; 1
    1700:	8d 91       	ld	r24, X+
    1702:	9c 91       	ld	r25, X
    1704:	12 97       	sbiw	r26, 0x02	; 2
    1706:	e8 17       	cp	r30, r24
    1708:	f9 07       	cpc	r31, r25
    170a:	31 f4       	brne	.+12     	; 0x1718 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    170c:	84 81       	ldd	r24, Z+4	; 0x04
    170e:	95 81       	ldd	r25, Z+5	; 0x05
    1710:	12 96       	adiw	r26, 0x02	; 2
    1712:	9c 93       	st	X, r25
    1714:	8e 93       	st	-X, r24
    1716:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1718:	11 86       	std	Z+9, r1	; 0x09
    171a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    171c:	8c 91       	ld	r24, X
    171e:	81 50       	subi	r24, 0x01	; 1
    1720:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1722:	df 91       	pop	r29
    1724:	cf 91       	pop	r28
    1726:	08 95       	ret

00001728 <pxPortInitialiseStack>:

#elif defined( portUSE_TIMER0 )
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts

#elif defined( portUSE_TIMER1 )
	portTIMSK &= ~( _BV(OCIE1B)|_BV(OCIE1A)|_BV(TOIE1) );	// disable all Timer1 interrupts
    1728:	31 e1       	ldi	r19, 0x11	; 17
    172a:	fc 01       	movw	r30, r24
    172c:	30 83       	st	Z, r19
    172e:	31 97       	sbiw	r30, 0x01	; 1
    1730:	22 e2       	ldi	r18, 0x22	; 34
    1732:	20 83       	st	Z, r18
    1734:	31 97       	sbiw	r30, 0x01	; 1
    1736:	a3 e3       	ldi	r26, 0x33	; 51
    1738:	a0 83       	st	Z, r26
    173a:	31 97       	sbiw	r30, 0x01	; 1
    173c:	60 83       	st	Z, r22
    173e:	31 97       	sbiw	r30, 0x01	; 1
    1740:	70 83       	st	Z, r23
    1742:	31 97       	sbiw	r30, 0x01	; 1
    1744:	10 82       	st	Z, r1
    1746:	31 97       	sbiw	r30, 0x01	; 1
    1748:	10 82       	st	Z, r1
    174a:	31 97       	sbiw	r30, 0x01	; 1
    174c:	60 e8       	ldi	r22, 0x80	; 128
    174e:	60 83       	st	Z, r22
    1750:	31 97       	sbiw	r30, 0x01	; 1
    1752:	10 82       	st	Z, r1
    1754:	31 97       	sbiw	r30, 0x01	; 1
    1756:	10 82       	st	Z, r1
    1758:	31 97       	sbiw	r30, 0x01	; 1
    175a:	10 82       	st	Z, r1
    175c:	31 97       	sbiw	r30, 0x01	; 1
    175e:	62 e0       	ldi	r22, 0x02	; 2
    1760:	60 83       	st	Z, r22
    1762:	31 97       	sbiw	r30, 0x01	; 1
    1764:	63 e0       	ldi	r22, 0x03	; 3
    1766:	60 83       	st	Z, r22
    1768:	31 97       	sbiw	r30, 0x01	; 1
    176a:	64 e0       	ldi	r22, 0x04	; 4
    176c:	60 83       	st	Z, r22
    176e:	31 97       	sbiw	r30, 0x01	; 1
    1770:	65 e0       	ldi	r22, 0x05	; 5
    1772:	60 83       	st	Z, r22
    1774:	31 97       	sbiw	r30, 0x01	; 1
    1776:	66 e0       	ldi	r22, 0x06	; 6
    1778:	60 83       	st	Z, r22
    177a:	31 97       	sbiw	r30, 0x01	; 1
    177c:	67 e0       	ldi	r22, 0x07	; 7
    177e:	60 83       	st	Z, r22
    1780:	31 97       	sbiw	r30, 0x01	; 1
    1782:	68 e0       	ldi	r22, 0x08	; 8
    1784:	60 83       	st	Z, r22
    1786:	31 97       	sbiw	r30, 0x01	; 1
    1788:	69 e0       	ldi	r22, 0x09	; 9
    178a:	60 83       	st	Z, r22
    178c:	31 97       	sbiw	r30, 0x01	; 1
    178e:	60 e1       	ldi	r22, 0x10	; 16
    1790:	60 83       	st	Z, r22
    1792:	31 97       	sbiw	r30, 0x01	; 1
    1794:	30 83       	st	Z, r19
    1796:	31 97       	sbiw	r30, 0x01	; 1
    1798:	32 e1       	ldi	r19, 0x12	; 18
    179a:	30 83       	st	Z, r19
    179c:	31 97       	sbiw	r30, 0x01	; 1
    179e:	33 e1       	ldi	r19, 0x13	; 19
    17a0:	30 83       	st	Z, r19
    17a2:	31 97       	sbiw	r30, 0x01	; 1
    17a4:	34 e1       	ldi	r19, 0x14	; 20
    17a6:	30 83       	st	Z, r19
    17a8:	31 97       	sbiw	r30, 0x01	; 1
    17aa:	35 e1       	ldi	r19, 0x15	; 21
    17ac:	30 83       	st	Z, r19
    17ae:	31 97       	sbiw	r30, 0x01	; 1
    17b0:	36 e1       	ldi	r19, 0x16	; 22
    17b2:	30 83       	st	Z, r19
    17b4:	31 97       	sbiw	r30, 0x01	; 1
    17b6:	37 e1       	ldi	r19, 0x17	; 23
    17b8:	30 83       	st	Z, r19
    17ba:	31 97       	sbiw	r30, 0x01	; 1
    17bc:	38 e1       	ldi	r19, 0x18	; 24
    17be:	30 83       	st	Z, r19
    17c0:	31 97       	sbiw	r30, 0x01	; 1
    17c2:	39 e1       	ldi	r19, 0x19	; 25
    17c4:	30 83       	st	Z, r19
    17c6:	31 97       	sbiw	r30, 0x01	; 1
    17c8:	30 e2       	ldi	r19, 0x20	; 32
    17ca:	30 83       	st	Z, r19
    17cc:	31 97       	sbiw	r30, 0x01	; 1
    17ce:	31 e2       	ldi	r19, 0x21	; 33
    17d0:	30 83       	st	Z, r19
    17d2:	31 97       	sbiw	r30, 0x01	; 1
    17d4:	20 83       	st	Z, r18
    17d6:	31 97       	sbiw	r30, 0x01	; 1
    17d8:	23 e2       	ldi	r18, 0x23	; 35
    17da:	20 83       	st	Z, r18
    17dc:	31 97       	sbiw	r30, 0x01	; 1
    17de:	40 83       	st	Z, r20
    17e0:	31 97       	sbiw	r30, 0x01	; 1
    17e2:	50 83       	st	Z, r21
    17e4:	31 97       	sbiw	r30, 0x01	; 1
    17e6:	26 e2       	ldi	r18, 0x26	; 38
    17e8:	20 83       	st	Z, r18
    17ea:	31 97       	sbiw	r30, 0x01	; 1
    17ec:	27 e2       	ldi	r18, 0x27	; 39
    17ee:	20 83       	st	Z, r18
    17f0:	31 97       	sbiw	r30, 0x01	; 1
    17f2:	28 e2       	ldi	r18, 0x28	; 40
    17f4:	20 83       	st	Z, r18
    17f6:	31 97       	sbiw	r30, 0x01	; 1
    17f8:	29 e2       	ldi	r18, 0x29	; 41
    17fa:	20 83       	st	Z, r18
    17fc:	31 97       	sbiw	r30, 0x01	; 1
    17fe:	20 e3       	ldi	r18, 0x30	; 48
    1800:	20 83       	st	Z, r18
    1802:	31 97       	sbiw	r30, 0x01	; 1
    1804:	21 e3       	ldi	r18, 0x31	; 49
    1806:	20 83       	st	Z, r18
    1808:	89 97       	sbiw	r24, 0x29	; 41
    180a:	08 95       	ret

0000180c <xPortStartScheduler>:
    180c:	88 ec       	ldi	r24, 0xC8	; 200
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	90 93 30 16 	sts	0x1630, r25	; 0x801630 <portTickRateHz+0x1>
    1814:	80 93 2f 16 	sts	0x162F, r24	; 0x80162f <portTickRateHz>
    1818:	90 93 32 16 	sts	0x1632, r25	; 0x801632 <ticksRemainingInSec+0x1>
    181c:	80 93 31 16 	sts	0x1631, r24	; 0x801631 <ticksRemainingInSec>
    1820:	84 e0       	ldi	r24, 0x04	; 4
    1822:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1826:	81 ee       	ldi	r24, 0xE1	; 225
    1828:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    182c:	8b e0       	ldi	r24, 0x0B	; 11
    182e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    1832:	ef e6       	ldi	r30, 0x6F	; 111
    1834:	f0 e0       	ldi	r31, 0x00	; 0
    1836:	80 81       	ld	r24, Z
    1838:	82 60       	ori	r24, 0x02	; 2
    183a:	80 83       	st	Z, r24
    183c:	a0 91 cb 15 	lds	r26, 0x15CB	; 0x8015cb <pxCurrentTCB>
    1840:	b0 91 cc 15 	lds	r27, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    1844:	cd 91       	ld	r28, X+
    1846:	cd bf       	out	0x3d, r28	; 61
    1848:	dd 91       	ld	r29, X+
    184a:	de bf       	out	0x3e, r29	; 62
    184c:	ff 91       	pop	r31
    184e:	ef 91       	pop	r30
    1850:	df 91       	pop	r29
    1852:	cf 91       	pop	r28
    1854:	bf 91       	pop	r27
    1856:	af 91       	pop	r26
    1858:	9f 91       	pop	r25
    185a:	8f 91       	pop	r24
    185c:	7f 91       	pop	r23
    185e:	6f 91       	pop	r22
    1860:	5f 91       	pop	r21
    1862:	4f 91       	pop	r20
    1864:	3f 91       	pop	r19
    1866:	2f 91       	pop	r18
    1868:	1f 91       	pop	r17
    186a:	0f 91       	pop	r16
    186c:	ff 90       	pop	r15
    186e:	ef 90       	pop	r14
    1870:	df 90       	pop	r13
    1872:	cf 90       	pop	r12
    1874:	bf 90       	pop	r11
    1876:	af 90       	pop	r10
    1878:	9f 90       	pop	r9
    187a:	8f 90       	pop	r8
    187c:	7f 90       	pop	r7
    187e:	6f 90       	pop	r6
    1880:	5f 90       	pop	r5
    1882:	4f 90       	pop	r4
    1884:	3f 90       	pop	r3
    1886:	2f 90       	pop	r2
    1888:	1f 90       	pop	r1
    188a:	0f 90       	pop	r0
    188c:	0c be       	out	0x3c, r0	; 60
    188e:	0f 90       	pop	r0
    1890:	0b be       	out	0x3b, r0	; 59
    1892:	0f 90       	pop	r0
    1894:	0f be       	out	0x3f, r0	; 63
    1896:	0f 90       	pop	r0
    1898:	08 95       	ret
    189a:	81 e0       	ldi	r24, 0x01	; 1
    189c:	08 95       	ret

0000189e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    189e:	0f 92       	push	r0
    18a0:	0f b6       	in	r0, 0x3f	; 63
    18a2:	f8 94       	cli
    18a4:	0f 92       	push	r0
    18a6:	0b b6       	in	r0, 0x3b	; 59
    18a8:	0f 92       	push	r0
    18aa:	0c b6       	in	r0, 0x3c	; 60
    18ac:	0f 92       	push	r0
    18ae:	1f 92       	push	r1
    18b0:	11 24       	eor	r1, r1
    18b2:	2f 92       	push	r2
    18b4:	3f 92       	push	r3
    18b6:	4f 92       	push	r4
    18b8:	5f 92       	push	r5
    18ba:	6f 92       	push	r6
    18bc:	7f 92       	push	r7
    18be:	8f 92       	push	r8
    18c0:	9f 92       	push	r9
    18c2:	af 92       	push	r10
    18c4:	bf 92       	push	r11
    18c6:	cf 92       	push	r12
    18c8:	df 92       	push	r13
    18ca:	ef 92       	push	r14
    18cc:	ff 92       	push	r15
    18ce:	0f 93       	push	r16
    18d0:	1f 93       	push	r17
    18d2:	2f 93       	push	r18
    18d4:	3f 93       	push	r19
    18d6:	4f 93       	push	r20
    18d8:	5f 93       	push	r21
    18da:	6f 93       	push	r22
    18dc:	7f 93       	push	r23
    18de:	8f 93       	push	r24
    18e0:	9f 93       	push	r25
    18e2:	af 93       	push	r26
    18e4:	bf 93       	push	r27
    18e6:	cf 93       	push	r28
    18e8:	df 93       	push	r29
    18ea:	ef 93       	push	r30
    18ec:	ff 93       	push	r31
    18ee:	a0 91 cb 15 	lds	r26, 0x15CB	; 0x8015cb <pxCurrentTCB>
    18f2:	b0 91 cc 15 	lds	r27, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    18f6:	0d b6       	in	r0, 0x3d	; 61
    18f8:	0d 92       	st	X+, r0
    18fa:	0e b6       	in	r0, 0x3e	; 62
    18fc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    18fe:	0e 94 39 18 	call	0x3072	; 0x3072 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1902:	a0 91 cb 15 	lds	r26, 0x15CB	; 0x8015cb <pxCurrentTCB>
    1906:	b0 91 cc 15 	lds	r27, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    190a:	cd 91       	ld	r28, X+
    190c:	cd bf       	out	0x3d, r28	; 61
    190e:	dd 91       	ld	r29, X+
    1910:	de bf       	out	0x3e, r29	; 62
    1912:	ff 91       	pop	r31
    1914:	ef 91       	pop	r30
    1916:	df 91       	pop	r29
    1918:	cf 91       	pop	r28
    191a:	bf 91       	pop	r27
    191c:	af 91       	pop	r26
    191e:	9f 91       	pop	r25
    1920:	8f 91       	pop	r24
    1922:	7f 91       	pop	r23
    1924:	6f 91       	pop	r22
    1926:	5f 91       	pop	r21
    1928:	4f 91       	pop	r20
    192a:	3f 91       	pop	r19
    192c:	2f 91       	pop	r18
    192e:	1f 91       	pop	r17
    1930:	0f 91       	pop	r16
    1932:	ff 90       	pop	r15
    1934:	ef 90       	pop	r14
    1936:	df 90       	pop	r13
    1938:	cf 90       	pop	r12
    193a:	bf 90       	pop	r11
    193c:	af 90       	pop	r10
    193e:	9f 90       	pop	r9
    1940:	8f 90       	pop	r8
    1942:	7f 90       	pop	r7
    1944:	6f 90       	pop	r6
    1946:	5f 90       	pop	r5
    1948:	4f 90       	pop	r4
    194a:	3f 90       	pop	r3
    194c:	2f 90       	pop	r2
    194e:	1f 90       	pop	r1
    1950:	0f 90       	pop	r0
    1952:	0c be       	out	0x3c, r0	; 60
    1954:	0f 90       	pop	r0
    1956:	0b be       	out	0x3b, r0	; 59
    1958:	0f 90       	pop	r0
    195a:	0f be       	out	0x3f, r0	; 63
    195c:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    195e:	08 95       	ret

00001960 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1960:	0f 92       	push	r0
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	0f 92       	push	r0
    1968:	0b b6       	in	r0, 0x3b	; 59
    196a:	0f 92       	push	r0
    196c:	0c b6       	in	r0, 0x3c	; 60
    196e:	0f 92       	push	r0
    1970:	1f 92       	push	r1
    1972:	11 24       	eor	r1, r1
    1974:	2f 92       	push	r2
    1976:	3f 92       	push	r3
    1978:	4f 92       	push	r4
    197a:	5f 92       	push	r5
    197c:	6f 92       	push	r6
    197e:	7f 92       	push	r7
    1980:	8f 92       	push	r8
    1982:	9f 92       	push	r9
    1984:	af 92       	push	r10
    1986:	bf 92       	push	r11
    1988:	cf 92       	push	r12
    198a:	df 92       	push	r13
    198c:	ef 92       	push	r14
    198e:	ff 92       	push	r15
    1990:	0f 93       	push	r16
    1992:	1f 93       	push	r17
    1994:	2f 93       	push	r18
    1996:	3f 93       	push	r19
    1998:	4f 93       	push	r20
    199a:	5f 93       	push	r21
    199c:	6f 93       	push	r22
    199e:	7f 93       	push	r23
    19a0:	8f 93       	push	r24
    19a2:	9f 93       	push	r25
    19a4:	af 93       	push	r26
    19a6:	bf 93       	push	r27
    19a8:	cf 93       	push	r28
    19aa:	df 93       	push	r29
    19ac:	ef 93       	push	r30
    19ae:	ff 93       	push	r31
    19b0:	a0 91 cb 15 	lds	r26, 0x15CB	; 0x8015cb <pxCurrentTCB>
    19b4:	b0 91 cc 15 	lds	r27, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    19b8:	0d b6       	in	r0, 0x3d	; 61
    19ba:	0d 92       	st	X+, r0
    19bc:	0e b6       	in	r0, 0x3e	; 62
    19be:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    19c0:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    19c2:	80 91 31 16 	lds	r24, 0x1631	; 0x801631 <ticksRemainingInSec>
    19c6:	90 91 32 16 	lds	r25, 0x1632	; 0x801632 <ticksRemainingInSec+0x1>
    19ca:	01 97       	sbiw	r24, 0x01	; 1
    19cc:	90 93 32 16 	sts	0x1632, r25	; 0x801632 <ticksRemainingInSec+0x1>
    19d0:	80 93 31 16 	sts	0x1631, r24	; 0x801631 <ticksRemainingInSec>
    19d4:	89 2b       	or	r24, r25
    19d6:	51 f4       	brne	.+20     	; 0x19ec <vPortYieldFromTick+0x8c>
	{
		system_tick();
    19d8:	0e 94 15 02 	call	0x42a	; 0x42a <system_tick>
		ticksRemainingInSec = portTickRateHz;
    19dc:	80 91 2f 16 	lds	r24, 0x162F	; 0x80162f <portTickRateHz>
    19e0:	90 91 30 16 	lds	r25, 0x1630	; 0x801630 <portTickRateHz+0x1>
    19e4:	90 93 32 16 	sts	0x1632, r25	; 0x801632 <ticksRemainingInSec+0x1>
    19e8:	80 93 31 16 	sts	0x1631, r24	; 0x801631 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    19ec:	0e 94 60 17 	call	0x2ec0	; 0x2ec0 <xTaskIncrementTick>
    19f0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    19f2:	0e 94 39 18 	call	0x3072	; 0x3072 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    19f6:	a0 91 cb 15 	lds	r26, 0x15CB	; 0x8015cb <pxCurrentTCB>
    19fa:	b0 91 cc 15 	lds	r27, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    19fe:	cd 91       	ld	r28, X+
    1a00:	cd bf       	out	0x3d, r28	; 61
    1a02:	dd 91       	ld	r29, X+
    1a04:	de bf       	out	0x3e, r29	; 62
    1a06:	ff 91       	pop	r31
    1a08:	ef 91       	pop	r30
    1a0a:	df 91       	pop	r29
    1a0c:	cf 91       	pop	r28
    1a0e:	bf 91       	pop	r27
    1a10:	af 91       	pop	r26
    1a12:	9f 91       	pop	r25
    1a14:	8f 91       	pop	r24
    1a16:	7f 91       	pop	r23
    1a18:	6f 91       	pop	r22
    1a1a:	5f 91       	pop	r21
    1a1c:	4f 91       	pop	r20
    1a1e:	3f 91       	pop	r19
    1a20:	2f 91       	pop	r18
    1a22:	1f 91       	pop	r17
    1a24:	0f 91       	pop	r16
    1a26:	ff 90       	pop	r15
    1a28:	ef 90       	pop	r14
    1a2a:	df 90       	pop	r13
    1a2c:	cf 90       	pop	r12
    1a2e:	bf 90       	pop	r11
    1a30:	af 90       	pop	r10
    1a32:	9f 90       	pop	r9
    1a34:	8f 90       	pop	r8
    1a36:	7f 90       	pop	r7
    1a38:	6f 90       	pop	r6
    1a3a:	5f 90       	pop	r5
    1a3c:	4f 90       	pop	r4
    1a3e:	3f 90       	pop	r3
    1a40:	2f 90       	pop	r2
    1a42:	1f 90       	pop	r1
    1a44:	0f 90       	pop	r0
    1a46:	0c be       	out	0x3c, r0	; 60
    1a48:	0f 90       	pop	r0
    1a4a:	0b be       	out	0x3b, r0	; 59
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63
    1a50:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1a52:	08 95       	ret

00001a54 <__vector_17>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    1a54:	85 df       	rcall	.-246    	; 0x1960 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1a56:	18 95       	reti

00001a58 <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a58:	0f 93       	push	r16
    1a5a:	1f 93       	push	r17
    1a5c:	cf 93       	push	r28
    1a5e:	df 93       	push	r29
    1a60:	08 2f       	mov	r16, r24
    1a62:	16 2f       	mov	r17, r22
    1a64:	66 23       	and	r22, r22
    1a66:	09 f4       	brne	.+2      	; 0x1a6a <xQueueGenericCreate+0x12>
    1a68:	38 c0       	rjmp	.+112    	; 0x1ada <xQueueGenericCreate+0x82>
    1a6a:	86 9f       	mul	r24, r22
    1a6c:	c0 01       	movw	r24, r0
    1a6e:	11 24       	eor	r1, r1
    1a70:	80 96       	adiw	r24, 0x20	; 32
    1a72:	9a dd       	rcall	.-1228   	; 0x15a8 <pvPortMalloc>
    1a74:	ec 01       	movw	r28, r24
    1a76:	00 97       	sbiw	r24, 0x00	; 0
    1a78:	21 f4       	brne	.+8      	; 0x1a82 <xQueueGenericCreate+0x2a>
    1a7a:	36 c0       	rjmp	.+108    	; 0x1ae8 <xQueueGenericCreate+0x90>
    1a7c:	d9 83       	std	Y+1, r29	; 0x01
    1a7e:	c8 83       	st	Y, r28
    1a80:	03 c0       	rjmp	.+6      	; 0x1a88 <xQueueGenericCreate+0x30>
    1a82:	4f 96       	adiw	r24, 0x1f	; 31
    1a84:	99 83       	std	Y+1, r25	; 0x01
    1a86:	88 83       	st	Y, r24
    1a88:	0b 8f       	std	Y+27, r16	; 0x1b
    1a8a:	1c 8f       	std	Y+28, r17	; 0x1c
    1a8c:	0f b6       	in	r0, 0x3f	; 63
    1a8e:	f8 94       	cli
    1a90:	0f 92       	push	r0
    1a92:	48 81       	ld	r20, Y
    1a94:	59 81       	ldd	r21, Y+1	; 0x01
    1a96:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1a98:	30 e0       	ldi	r19, 0x00	; 0
    1a9a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1a9c:	62 9f       	mul	r22, r18
    1a9e:	c0 01       	movw	r24, r0
    1aa0:	63 9f       	mul	r22, r19
    1aa2:	90 0d       	add	r25, r0
    1aa4:	11 24       	eor	r1, r1
    1aa6:	ba 01       	movw	r22, r20
    1aa8:	68 0f       	add	r22, r24
    1aaa:	79 1f       	adc	r23, r25
    1aac:	7b 83       	std	Y+3, r23	; 0x03
    1aae:	6a 83       	std	Y+2, r22	; 0x02
    1ab0:	1a 8e       	std	Y+26, r1	; 0x1a
    1ab2:	5d 83       	std	Y+5, r21	; 0x05
    1ab4:	4c 83       	std	Y+4, r20	; 0x04
    1ab6:	82 1b       	sub	r24, r18
    1ab8:	93 0b       	sbc	r25, r19
    1aba:	84 0f       	add	r24, r20
    1abc:	95 1f       	adc	r25, r21
    1abe:	9f 83       	std	Y+7, r25	; 0x07
    1ac0:	8e 83       	std	Y+6, r24	; 0x06
    1ac2:	8f ef       	ldi	r24, 0xFF	; 255
    1ac4:	8d 8f       	std	Y+29, r24	; 0x1d
    1ac6:	8e 8f       	std	Y+30, r24	; 0x1e
    1ac8:	ce 01       	movw	r24, r28
    1aca:	08 96       	adiw	r24, 0x08	; 8
    1acc:	a3 dd       	rcall	.-1210   	; 0x1614 <vListInitialise>
    1ace:	ce 01       	movw	r24, r28
    1ad0:	41 96       	adiw	r24, 0x11	; 17
    1ad2:	a0 dd       	rcall	.-1216   	; 0x1614 <vListInitialise>
    1ad4:	0f 90       	pop	r0
    1ad6:	0f be       	out	0x3f, r0	; 63
    1ad8:	07 c0       	rjmp	.+14     	; 0x1ae8 <xQueueGenericCreate+0x90>
    1ada:	8f e1       	ldi	r24, 0x1F	; 31
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	64 dd       	rcall	.-1336   	; 0x15a8 <pvPortMalloc>
    1ae0:	ec 01       	movw	r28, r24
    1ae2:	89 2b       	or	r24, r25
    1ae4:	09 f0       	breq	.+2      	; 0x1ae8 <xQueueGenericCreate+0x90>
    1ae6:	ca cf       	rjmp	.-108    	; 0x1a7c <xQueueGenericCreate+0x24>
    1ae8:	ce 01       	movw	r24, r28
    1aea:	df 91       	pop	r29
    1aec:	cf 91       	pop	r28
    1aee:	1f 91       	pop	r17
    1af0:	0f 91       	pop	r16
    1af2:	08 95       	ret

00001af4 <xQueueGenericSend>:
    1af4:	6f 92       	push	r6
    1af6:	7f 92       	push	r7
    1af8:	8f 92       	push	r8
    1afa:	9f 92       	push	r9
    1afc:	af 92       	push	r10
    1afe:	bf 92       	push	r11
    1b00:	cf 92       	push	r12
    1b02:	df 92       	push	r13
    1b04:	ef 92       	push	r14
    1b06:	ff 92       	push	r15
    1b08:	0f 93       	push	r16
    1b0a:	1f 93       	push	r17
    1b0c:	cf 93       	push	r28
    1b0e:	df 93       	push	r29
    1b10:	00 d0       	rcall	.+0      	; 0x1b12 <xQueueGenericSend+0x1e>
    1b12:	1f 92       	push	r1
    1b14:	1f 92       	push	r1
    1b16:	cd b7       	in	r28, 0x3d	; 61
    1b18:	de b7       	in	r29, 0x3e	; 62
    1b1a:	8c 01       	movw	r16, r24
    1b1c:	5b 01       	movw	r10, r22
    1b1e:	5d 83       	std	Y+5, r21	; 0x05
    1b20:	4c 83       	std	Y+4, r20	; 0x04
    1b22:	72 2e       	mov	r7, r18
    1b24:	81 2c       	mov	r8, r1
    1b26:	66 24       	eor	r6, r6
    1b28:	63 94       	inc	r6
    1b2a:	99 24       	eor	r9, r9
    1b2c:	9a 94       	dec	r9
    1b2e:	7c 01       	movw	r14, r24
    1b30:	88 e0       	ldi	r24, 0x08	; 8
    1b32:	e8 0e       	add	r14, r24
    1b34:	f1 1c       	adc	r15, r1
    1b36:	68 01       	movw	r12, r16
    1b38:	e1 e1       	ldi	r30, 0x11	; 17
    1b3a:	ce 0e       	add	r12, r30
    1b3c:	d1 1c       	adc	r13, r1
    1b3e:	0f b6       	in	r0, 0x3f	; 63
    1b40:	f8 94       	cli
    1b42:	0f 92       	push	r0
    1b44:	f8 01       	movw	r30, r16
    1b46:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b48:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b4a:	98 17       	cp	r25, r24
    1b4c:	20 f0       	brcs	.+8      	; 0x1b56 <xQueueGenericSend+0x62>
    1b4e:	f2 e0       	ldi	r31, 0x02	; 2
    1b50:	7f 12       	cpse	r7, r31
    1b52:	6e c0       	rjmp	.+220    	; 0x1c30 <xQueueGenericSend+0x13c>
    1b54:	79 c1       	rjmp	.+754    	; 0x1e48 <xQueueGenericSend+0x354>
    1b56:	f8 01       	movw	r30, r16
    1b58:	44 8d       	ldd	r20, Z+28	; 0x1c
    1b5a:	41 11       	cpse	r20, r1
    1b5c:	15 c0       	rjmp	.+42     	; 0x1b88 <xQueueGenericSend+0x94>
    1b5e:	f8 01       	movw	r30, r16
    1b60:	80 81       	ld	r24, Z
    1b62:	91 81       	ldd	r25, Z+1	; 0x01
    1b64:	89 2b       	or	r24, r25
    1b66:	09 f0       	breq	.+2      	; 0x1b6a <xQueueGenericSend+0x76>
    1b68:	75 c1       	rjmp	.+746    	; 0x1e54 <xQueueGenericSend+0x360>
    1b6a:	82 81       	ldd	r24, Z+2	; 0x02
    1b6c:	93 81       	ldd	r25, Z+3	; 0x03
    1b6e:	0e 94 f5 19 	call	0x33ea	; 0x33ea <xTaskPriorityDisinherit>
    1b72:	f8 01       	movw	r30, r16
    1b74:	13 82       	std	Z+3, r1	; 0x03
    1b76:	12 82       	std	Z+2, r1	; 0x02
    1b78:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b7a:	9f 5f       	subi	r25, 0xFF	; 255
    1b7c:	92 8f       	std	Z+26, r25	; 0x1a
    1b7e:	91 89       	ldd	r25, Z+17	; 0x11
    1b80:	99 23       	and	r25, r25
    1b82:	09 f4       	brne	.+2      	; 0x1b86 <xQueueGenericSend+0x92>
    1b84:	4f c0       	rjmp	.+158    	; 0x1c24 <xQueueGenericSend+0x130>
    1b86:	46 c0       	rjmp	.+140    	; 0x1c14 <xQueueGenericSend+0x120>
    1b88:	71 10       	cpse	r7, r1
    1b8a:	1a c0       	rjmp	.+52     	; 0x1bc0 <xQueueGenericSend+0xcc>
    1b8c:	50 e0       	ldi	r21, 0x00	; 0
    1b8e:	b5 01       	movw	r22, r10
    1b90:	f8 01       	movw	r30, r16
    1b92:	84 81       	ldd	r24, Z+4	; 0x04
    1b94:	95 81       	ldd	r25, Z+5	; 0x05
    1b96:	0e 94 de 21 	call	0x43bc	; 0x43bc <memcpy>
    1b9a:	f8 01       	movw	r30, r16
    1b9c:	24 8d       	ldd	r18, Z+28	; 0x1c
    1b9e:	84 81       	ldd	r24, Z+4	; 0x04
    1ba0:	95 81       	ldd	r25, Z+5	; 0x05
    1ba2:	82 0f       	add	r24, r18
    1ba4:	91 1d       	adc	r25, r1
    1ba6:	95 83       	std	Z+5, r25	; 0x05
    1ba8:	84 83       	std	Z+4, r24	; 0x04
    1baa:	22 81       	ldd	r18, Z+2	; 0x02
    1bac:	33 81       	ldd	r19, Z+3	; 0x03
    1bae:	82 17       	cp	r24, r18
    1bb0:	93 07       	cpc	r25, r19
    1bb2:	08 f4       	brcc	.+2      	; 0x1bb6 <xQueueGenericSend+0xc2>
    1bb4:	4f c1       	rjmp	.+670    	; 0x1e54 <xQueueGenericSend+0x360>
    1bb6:	80 81       	ld	r24, Z
    1bb8:	91 81       	ldd	r25, Z+1	; 0x01
    1bba:	95 83       	std	Z+5, r25	; 0x05
    1bbc:	84 83       	std	Z+4, r24	; 0x04
    1bbe:	4a c1       	rjmp	.+660    	; 0x1e54 <xQueueGenericSend+0x360>
    1bc0:	50 e0       	ldi	r21, 0x00	; 0
    1bc2:	b5 01       	movw	r22, r10
    1bc4:	f8 01       	movw	r30, r16
    1bc6:	86 81       	ldd	r24, Z+6	; 0x06
    1bc8:	97 81       	ldd	r25, Z+7	; 0x07
    1bca:	0e 94 de 21 	call	0x43bc	; 0x43bc <memcpy>
    1bce:	f8 01       	movw	r30, r16
    1bd0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	91 95       	neg	r25
    1bd6:	81 95       	neg	r24
    1bd8:	91 09       	sbc	r25, r1
    1bda:	26 81       	ldd	r18, Z+6	; 0x06
    1bdc:	37 81       	ldd	r19, Z+7	; 0x07
    1bde:	28 0f       	add	r18, r24
    1be0:	39 1f       	adc	r19, r25
    1be2:	37 83       	std	Z+7, r19	; 0x07
    1be4:	26 83       	std	Z+6, r18	; 0x06
    1be6:	40 81       	ld	r20, Z
    1be8:	51 81       	ldd	r21, Z+1	; 0x01
    1bea:	24 17       	cp	r18, r20
    1bec:	35 07       	cpc	r19, r21
    1bee:	30 f4       	brcc	.+12     	; 0x1bfc <xQueueGenericSend+0x108>
    1bf0:	22 81       	ldd	r18, Z+2	; 0x02
    1bf2:	33 81       	ldd	r19, Z+3	; 0x03
    1bf4:	82 0f       	add	r24, r18
    1bf6:	93 1f       	adc	r25, r19
    1bf8:	97 83       	std	Z+7, r25	; 0x07
    1bfa:	86 83       	std	Z+6, r24	; 0x06
    1bfc:	f2 e0       	ldi	r31, 0x02	; 2
    1bfe:	7f 12       	cpse	r7, r31
    1c00:	29 c1       	rjmp	.+594    	; 0x1e54 <xQueueGenericSend+0x360>
    1c02:	f8 01       	movw	r30, r16
    1c04:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c06:	88 23       	and	r24, r24
    1c08:	09 f4       	brne	.+2      	; 0x1c0c <xQueueGenericSend+0x118>
    1c0a:	24 c1       	rjmp	.+584    	; 0x1e54 <xQueueGenericSend+0x360>
    1c0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c0e:	81 50       	subi	r24, 0x01	; 1
    1c10:	82 8f       	std	Z+26, r24	; 0x1a
    1c12:	20 c1       	rjmp	.+576    	; 0x1e54 <xQueueGenericSend+0x360>
    1c14:	c8 01       	movw	r24, r16
    1c16:	41 96       	adiw	r24, 0x11	; 17
    1c18:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1c1c:	81 30       	cpi	r24, 0x01	; 1
    1c1e:	21 f4       	brne	.+8      	; 0x1c28 <xQueueGenericSend+0x134>
    1c20:	3e de       	rcall	.-900    	; 0x189e <vPortYield>
    1c22:	02 c0       	rjmp	.+4      	; 0x1c28 <xQueueGenericSend+0x134>
    1c24:	81 11       	cpse	r24, r1
    1c26:	3b de       	rcall	.-906    	; 0x189e <vPortYield>
    1c28:	0f 90       	pop	r0
    1c2a:	0f be       	out	0x3f, r0	; 63
    1c2c:	81 e0       	ldi	r24, 0x01	; 1
    1c2e:	1a c1       	rjmp	.+564    	; 0x1e64 <xQueueGenericSend+0x370>
    1c30:	8c 81       	ldd	r24, Y+4	; 0x04
    1c32:	9d 81       	ldd	r25, Y+5	; 0x05
    1c34:	89 2b       	or	r24, r25
    1c36:	21 f4       	brne	.+8      	; 0x1c40 <xQueueGenericSend+0x14c>
    1c38:	0f 90       	pop	r0
    1c3a:	0f be       	out	0x3f, r0	; 63
    1c3c:	80 e0       	ldi	r24, 0x00	; 0
    1c3e:	12 c1       	rjmp	.+548    	; 0x1e64 <xQueueGenericSend+0x370>
    1c40:	81 10       	cpse	r8, r1
    1c42:	05 c0       	rjmp	.+10     	; 0x1c4e <xQueueGenericSend+0x15a>
    1c44:	ce 01       	movw	r24, r28
    1c46:	01 96       	adiw	r24, 0x01	; 1
    1c48:	0e 94 49 19 	call	0x3292	; 0x3292 <vTaskSetTimeOutState>
    1c4c:	86 2c       	mov	r8, r6
    1c4e:	0f 90       	pop	r0
    1c50:	0f be       	out	0x3f, r0	; 63
    1c52:	dc d7       	rcall	.+4024   	; 0x2c0c <vTaskSuspendAll>
    1c54:	0f b6       	in	r0, 0x3f	; 63
    1c56:	f8 94       	cli
    1c58:	0f 92       	push	r0
    1c5a:	f8 01       	movw	r30, r16
    1c5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c60:	09 f4       	brne	.+2      	; 0x1c64 <xQueueGenericSend+0x170>
    1c62:	15 8e       	std	Z+29, r1	; 0x1d
    1c64:	f8 01       	movw	r30, r16
    1c66:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c68:	8f 3f       	cpi	r24, 0xFF	; 255
    1c6a:	09 f4       	brne	.+2      	; 0x1c6e <xQueueGenericSend+0x17a>
    1c6c:	16 8e       	std	Z+30, r1	; 0x1e
    1c6e:	0f 90       	pop	r0
    1c70:	0f be       	out	0x3f, r0	; 63
    1c72:	be 01       	movw	r22, r28
    1c74:	6c 5f       	subi	r22, 0xFC	; 252
    1c76:	7f 4f       	sbci	r23, 0xFF	; 255
    1c78:	ce 01       	movw	r24, r28
    1c7a:	01 96       	adiw	r24, 0x01	; 1
    1c7c:	0e 94 54 19 	call	0x32a8	; 0x32a8 <xTaskCheckForTimeOut>
    1c80:	81 11       	cpse	r24, r1
    1c82:	94 c0       	rjmp	.+296    	; 0x1dac <xQueueGenericSend+0x2b8>
    1c84:	0f b6       	in	r0, 0x3f	; 63
    1c86:	f8 94       	cli
    1c88:	0f 92       	push	r0
    1c8a:	f8 01       	movw	r30, r16
    1c8c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c8e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c90:	0f 90       	pop	r0
    1c92:	0f be       	out	0x3f, r0	; 63
    1c94:	98 13       	cpse	r25, r24
    1c96:	49 c0       	rjmp	.+146    	; 0x1d2a <xQueueGenericSend+0x236>
    1c98:	6c 81       	ldd	r22, Y+4	; 0x04
    1c9a:	7d 81       	ldd	r23, Y+5	; 0x05
    1c9c:	c7 01       	movw	r24, r14
    1c9e:	0e 94 a6 18 	call	0x314c	; 0x314c <vTaskPlaceOnEventList>
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	0f 92       	push	r0
    1ca8:	f8 01       	movw	r30, r16
    1caa:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cac:	18 16       	cp	r1, r24
    1cae:	ac f4       	brge	.+42     	; 0x1cda <xQueueGenericSend+0x1e6>
    1cb0:	81 89       	ldd	r24, Z+17	; 0x11
    1cb2:	81 11       	cpse	r24, r1
    1cb4:	05 c0       	rjmp	.+10     	; 0x1cc0 <xQueueGenericSend+0x1cc>
    1cb6:	11 c0       	rjmp	.+34     	; 0x1cda <xQueueGenericSend+0x1e6>
    1cb8:	f8 01       	movw	r30, r16
    1cba:	81 89       	ldd	r24, Z+17	; 0x11
    1cbc:	88 23       	and	r24, r24
    1cbe:	69 f0       	breq	.+26     	; 0x1cda <xQueueGenericSend+0x1e6>
    1cc0:	c6 01       	movw	r24, r12
    1cc2:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1cc6:	81 11       	cpse	r24, r1
    1cc8:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    1ccc:	f8 01       	movw	r30, r16
    1cce:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cd0:	81 50       	subi	r24, 0x01	; 1
    1cd2:	86 8f       	std	Z+30, r24	; 0x1e
    1cd4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cd6:	18 16       	cp	r1, r24
    1cd8:	7c f3       	brlt	.-34     	; 0x1cb8 <xQueueGenericSend+0x1c4>
    1cda:	f8 01       	movw	r30, r16
    1cdc:	96 8e       	std	Z+30, r9	; 0x1e
    1cde:	0f 90       	pop	r0
    1ce0:	0f be       	out	0x3f, r0	; 63
    1ce2:	0f b6       	in	r0, 0x3f	; 63
    1ce4:	f8 94       	cli
    1ce6:	0f 92       	push	r0
    1ce8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cea:	18 16       	cp	r1, r24
    1cec:	ac f4       	brge	.+42     	; 0x1d18 <xQueueGenericSend+0x224>
    1cee:	80 85       	ldd	r24, Z+8	; 0x08
    1cf0:	81 11       	cpse	r24, r1
    1cf2:	05 c0       	rjmp	.+10     	; 0x1cfe <xQueueGenericSend+0x20a>
    1cf4:	11 c0       	rjmp	.+34     	; 0x1d18 <xQueueGenericSend+0x224>
    1cf6:	f8 01       	movw	r30, r16
    1cf8:	80 85       	ldd	r24, Z+8	; 0x08
    1cfa:	88 23       	and	r24, r24
    1cfc:	69 f0       	breq	.+26     	; 0x1d18 <xQueueGenericSend+0x224>
    1cfe:	c7 01       	movw	r24, r14
    1d00:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1d04:	81 11       	cpse	r24, r1
    1d06:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    1d0a:	f8 01       	movw	r30, r16
    1d0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d0e:	81 50       	subi	r24, 0x01	; 1
    1d10:	85 8f       	std	Z+29, r24	; 0x1d
    1d12:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d14:	18 16       	cp	r1, r24
    1d16:	7c f3       	brlt	.-34     	; 0x1cf6 <xQueueGenericSend+0x202>
    1d18:	f8 01       	movw	r30, r16
    1d1a:	95 8e       	std	Z+29, r9	; 0x1d
    1d1c:	0f 90       	pop	r0
    1d1e:	0f be       	out	0x3f, r0	; 63
    1d20:	7b d7       	rcall	.+3830   	; 0x2c18 <xTaskResumeAll>
    1d22:	81 11       	cpse	r24, r1
    1d24:	0c cf       	rjmp	.-488    	; 0x1b3e <xQueueGenericSend+0x4a>
    1d26:	bb dd       	rcall	.-1162   	; 0x189e <vPortYield>
    1d28:	0a cf       	rjmp	.-492    	; 0x1b3e <xQueueGenericSend+0x4a>
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	f8 94       	cli
    1d2e:	0f 92       	push	r0
    1d30:	f8 01       	movw	r30, r16
    1d32:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d34:	18 16       	cp	r1, r24
    1d36:	ac f4       	brge	.+42     	; 0x1d62 <xQueueGenericSend+0x26e>
    1d38:	81 89       	ldd	r24, Z+17	; 0x11
    1d3a:	81 11       	cpse	r24, r1
    1d3c:	05 c0       	rjmp	.+10     	; 0x1d48 <xQueueGenericSend+0x254>
    1d3e:	11 c0       	rjmp	.+34     	; 0x1d62 <xQueueGenericSend+0x26e>
    1d40:	f8 01       	movw	r30, r16
    1d42:	81 89       	ldd	r24, Z+17	; 0x11
    1d44:	88 23       	and	r24, r24
    1d46:	69 f0       	breq	.+26     	; 0x1d62 <xQueueGenericSend+0x26e>
    1d48:	c6 01       	movw	r24, r12
    1d4a:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1d4e:	81 11       	cpse	r24, r1
    1d50:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    1d54:	f8 01       	movw	r30, r16
    1d56:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d58:	81 50       	subi	r24, 0x01	; 1
    1d5a:	86 8f       	std	Z+30, r24	; 0x1e
    1d5c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d5e:	18 16       	cp	r1, r24
    1d60:	7c f3       	brlt	.-34     	; 0x1d40 <xQueueGenericSend+0x24c>
    1d62:	f8 01       	movw	r30, r16
    1d64:	96 8e       	std	Z+30, r9	; 0x1e
    1d66:	0f 90       	pop	r0
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	0f b6       	in	r0, 0x3f	; 63
    1d6c:	f8 94       	cli
    1d6e:	0f 92       	push	r0
    1d70:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d72:	18 16       	cp	r1, r24
    1d74:	ac f4       	brge	.+42     	; 0x1da0 <xQueueGenericSend+0x2ac>
    1d76:	80 85       	ldd	r24, Z+8	; 0x08
    1d78:	81 11       	cpse	r24, r1
    1d7a:	05 c0       	rjmp	.+10     	; 0x1d86 <xQueueGenericSend+0x292>
    1d7c:	11 c0       	rjmp	.+34     	; 0x1da0 <xQueueGenericSend+0x2ac>
    1d7e:	f8 01       	movw	r30, r16
    1d80:	80 85       	ldd	r24, Z+8	; 0x08
    1d82:	88 23       	and	r24, r24
    1d84:	69 f0       	breq	.+26     	; 0x1da0 <xQueueGenericSend+0x2ac>
    1d86:	c7 01       	movw	r24, r14
    1d88:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1d8c:	81 11       	cpse	r24, r1
    1d8e:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    1d92:	f8 01       	movw	r30, r16
    1d94:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d96:	81 50       	subi	r24, 0x01	; 1
    1d98:	85 8f       	std	Z+29, r24	; 0x1d
    1d9a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d9c:	18 16       	cp	r1, r24
    1d9e:	7c f3       	brlt	.-34     	; 0x1d7e <xQueueGenericSend+0x28a>
    1da0:	f8 01       	movw	r30, r16
    1da2:	95 8e       	std	Z+29, r9	; 0x1d
    1da4:	0f 90       	pop	r0
    1da6:	0f be       	out	0x3f, r0	; 63
    1da8:	37 d7       	rcall	.+3694   	; 0x2c18 <xTaskResumeAll>
    1daa:	c9 ce       	rjmp	.-622    	; 0x1b3e <xQueueGenericSend+0x4a>
    1dac:	0f b6       	in	r0, 0x3f	; 63
    1dae:	f8 94       	cli
    1db0:	0f 92       	push	r0
    1db2:	f8 01       	movw	r30, r16
    1db4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1db6:	18 16       	cp	r1, r24
    1db8:	d4 f4       	brge	.+52     	; 0x1dee <xQueueGenericSend+0x2fa>
    1dba:	81 89       	ldd	r24, Z+17	; 0x11
    1dbc:	81 11       	cpse	r24, r1
    1dbe:	06 c0       	rjmp	.+12     	; 0x1dcc <xQueueGenericSend+0x2d8>
    1dc0:	16 c0       	rjmp	.+44     	; 0x1dee <xQueueGenericSend+0x2fa>
    1dc2:	f8 01       	movw	r30, r16
    1dc4:	81 89       	ldd	r24, Z+17	; 0x11
    1dc6:	81 11       	cpse	r24, r1
    1dc8:	05 c0       	rjmp	.+10     	; 0x1dd4 <xQueueGenericSend+0x2e0>
    1dca:	11 c0       	rjmp	.+34     	; 0x1dee <xQueueGenericSend+0x2fa>
    1dcc:	78 01       	movw	r14, r16
    1dce:	f1 e1       	ldi	r31, 0x11	; 17
    1dd0:	ef 0e       	add	r14, r31
    1dd2:	f1 1c       	adc	r15, r1
    1dd4:	c7 01       	movw	r24, r14
    1dd6:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1dda:	81 11       	cpse	r24, r1
    1ddc:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    1de0:	f8 01       	movw	r30, r16
    1de2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1de4:	81 50       	subi	r24, 0x01	; 1
    1de6:	86 8f       	std	Z+30, r24	; 0x1e
    1de8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dea:	18 16       	cp	r1, r24
    1dec:	54 f3       	brlt	.-44     	; 0x1dc2 <xQueueGenericSend+0x2ce>
    1dee:	8f ef       	ldi	r24, 0xFF	; 255
    1df0:	f8 01       	movw	r30, r16
    1df2:	86 8f       	std	Z+30, r24	; 0x1e
    1df4:	0f 90       	pop	r0
    1df6:	0f be       	out	0x3f, r0	; 63
    1df8:	0f b6       	in	r0, 0x3f	; 63
    1dfa:	f8 94       	cli
    1dfc:	0f 92       	push	r0
    1dfe:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e00:	18 16       	cp	r1, r24
    1e02:	d4 f4       	brge	.+52     	; 0x1e38 <xQueueGenericSend+0x344>
    1e04:	80 85       	ldd	r24, Z+8	; 0x08
    1e06:	81 11       	cpse	r24, r1
    1e08:	06 c0       	rjmp	.+12     	; 0x1e16 <xQueueGenericSend+0x322>
    1e0a:	16 c0       	rjmp	.+44     	; 0x1e38 <xQueueGenericSend+0x344>
    1e0c:	f8 01       	movw	r30, r16
    1e0e:	80 85       	ldd	r24, Z+8	; 0x08
    1e10:	81 11       	cpse	r24, r1
    1e12:	05 c0       	rjmp	.+10     	; 0x1e1e <xQueueGenericSend+0x32a>
    1e14:	11 c0       	rjmp	.+34     	; 0x1e38 <xQueueGenericSend+0x344>
    1e16:	78 01       	movw	r14, r16
    1e18:	f8 e0       	ldi	r31, 0x08	; 8
    1e1a:	ef 0e       	add	r14, r31
    1e1c:	f1 1c       	adc	r15, r1
    1e1e:	c7 01       	movw	r24, r14
    1e20:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1e24:	81 11       	cpse	r24, r1
    1e26:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    1e2a:	f8 01       	movw	r30, r16
    1e2c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e2e:	81 50       	subi	r24, 0x01	; 1
    1e30:	85 8f       	std	Z+29, r24	; 0x1d
    1e32:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e34:	18 16       	cp	r1, r24
    1e36:	54 f3       	brlt	.-44     	; 0x1e0c <xQueueGenericSend+0x318>
    1e38:	8f ef       	ldi	r24, 0xFF	; 255
    1e3a:	f8 01       	movw	r30, r16
    1e3c:	85 8f       	std	Z+29, r24	; 0x1d
    1e3e:	0f 90       	pop	r0
    1e40:	0f be       	out	0x3f, r0	; 63
    1e42:	ea d6       	rcall	.+3540   	; 0x2c18 <xTaskResumeAll>
    1e44:	80 e0       	ldi	r24, 0x00	; 0
    1e46:	0e c0       	rjmp	.+28     	; 0x1e64 <xQueueGenericSend+0x370>
    1e48:	f8 01       	movw	r30, r16
    1e4a:	44 8d       	ldd	r20, Z+28	; 0x1c
    1e4c:	44 23       	and	r20, r20
    1e4e:	09 f4       	brne	.+2      	; 0x1e52 <xQueueGenericSend+0x35e>
    1e50:	86 ce       	rjmp	.-756    	; 0x1b5e <xQueueGenericSend+0x6a>
    1e52:	b6 ce       	rjmp	.-660    	; 0x1bc0 <xQueueGenericSend+0xcc>
    1e54:	f8 01       	movw	r30, r16
    1e56:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e58:	8f 5f       	subi	r24, 0xFF	; 255
    1e5a:	82 8f       	std	Z+26, r24	; 0x1a
    1e5c:	81 89       	ldd	r24, Z+17	; 0x11
    1e5e:	81 11       	cpse	r24, r1
    1e60:	d9 ce       	rjmp	.-590    	; 0x1c14 <xQueueGenericSend+0x120>
    1e62:	e2 ce       	rjmp	.-572    	; 0x1c28 <xQueueGenericSend+0x134>
    1e64:	0f 90       	pop	r0
    1e66:	0f 90       	pop	r0
    1e68:	0f 90       	pop	r0
    1e6a:	0f 90       	pop	r0
    1e6c:	0f 90       	pop	r0
    1e6e:	df 91       	pop	r29
    1e70:	cf 91       	pop	r28
    1e72:	1f 91       	pop	r17
    1e74:	0f 91       	pop	r16
    1e76:	ff 90       	pop	r15
    1e78:	ef 90       	pop	r14
    1e7a:	df 90       	pop	r13
    1e7c:	cf 90       	pop	r12
    1e7e:	bf 90       	pop	r11
    1e80:	af 90       	pop	r10
    1e82:	9f 90       	pop	r9
    1e84:	8f 90       	pop	r8
    1e86:	7f 90       	pop	r7
    1e88:	6f 90       	pop	r6
    1e8a:	08 95       	ret

00001e8c <xQueueGive>:
    1e8c:	9f 92       	push	r9
    1e8e:	af 92       	push	r10
    1e90:	bf 92       	push	r11
    1e92:	cf 92       	push	r12
    1e94:	df 92       	push	r13
    1e96:	ef 92       	push	r14
    1e98:	ff 92       	push	r15
    1e9a:	0f 93       	push	r16
    1e9c:	1f 93       	push	r17
    1e9e:	cf 93       	push	r28
    1ea0:	df 93       	push	r29
    1ea2:	00 d0       	rcall	.+0      	; 0x1ea4 <xQueueGive+0x18>
    1ea4:	1f 92       	push	r1
    1ea6:	1f 92       	push	r1
    1ea8:	cd b7       	in	r28, 0x3d	; 61
    1eaa:	de b7       	in	r29, 0x3e	; 62
    1eac:	8c 01       	movw	r16, r24
    1eae:	7d 83       	std	Y+5, r23	; 0x05
    1eb0:	6c 83       	std	Y+4, r22	; 0x04
    1eb2:	a1 2c       	mov	r10, r1
    1eb4:	99 24       	eor	r9, r9
    1eb6:	93 94       	inc	r9
    1eb8:	bb 24       	eor	r11, r11
    1eba:	ba 94       	dec	r11
    1ebc:	7c 01       	movw	r14, r24
    1ebe:	88 e0       	ldi	r24, 0x08	; 8
    1ec0:	e8 0e       	add	r14, r24
    1ec2:	f1 1c       	adc	r15, r1
    1ec4:	68 01       	movw	r12, r16
    1ec6:	e1 e1       	ldi	r30, 0x11	; 17
    1ec8:	ce 0e       	add	r12, r30
    1eca:	d1 1c       	adc	r13, r1
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	0f 92       	push	r0
    1ed2:	f8 01       	movw	r30, r16
    1ed4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ed6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ed8:	98 17       	cp	r25, r24
    1eda:	00 f5       	brcc	.+64     	; 0x1f1c <xQueueGive+0x90>
    1edc:	80 81       	ld	r24, Z
    1ede:	91 81       	ldd	r25, Z+1	; 0x01
    1ee0:	89 2b       	or	r24, r25
    1ee2:	09 f0       	breq	.+2      	; 0x1ee6 <xQueueGive+0x5a>
    1ee4:	27 c1       	rjmp	.+590    	; 0x2134 <xQueueGive+0x2a8>
    1ee6:	82 81       	ldd	r24, Z+2	; 0x02
    1ee8:	93 81       	ldd	r25, Z+3	; 0x03
    1eea:	0e 94 f5 19 	call	0x33ea	; 0x33ea <xTaskPriorityDisinherit>
    1eee:	f8 01       	movw	r30, r16
    1ef0:	13 82       	std	Z+3, r1	; 0x03
    1ef2:	12 82       	std	Z+2, r1	; 0x02
    1ef4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ef6:	9f 5f       	subi	r25, 0xFF	; 255
    1ef8:	92 8f       	std	Z+26, r25	; 0x1a
    1efa:	91 89       	ldd	r25, Z+17	; 0x11
    1efc:	99 23       	and	r25, r25
    1efe:	41 f0       	breq	.+16     	; 0x1f10 <xQueueGive+0x84>
    1f00:	c8 01       	movw	r24, r16
    1f02:	41 96       	adiw	r24, 0x11	; 17
    1f04:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1f08:	81 30       	cpi	r24, 0x01	; 1
    1f0a:	21 f4       	brne	.+8      	; 0x1f14 <xQueueGive+0x88>
    1f0c:	c8 dc       	rcall	.-1648   	; 0x189e <vPortYield>
    1f0e:	02 c0       	rjmp	.+4      	; 0x1f14 <xQueueGive+0x88>
    1f10:	81 11       	cpse	r24, r1
    1f12:	c5 dc       	rcall	.-1654   	; 0x189e <vPortYield>
    1f14:	0f 90       	pop	r0
    1f16:	0f be       	out	0x3f, r0	; 63
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	14 c1       	rjmp	.+552    	; 0x2144 <xQueueGive+0x2b8>
    1f1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f20:	89 2b       	or	r24, r25
    1f22:	21 f4       	brne	.+8      	; 0x1f2c <xQueueGive+0xa0>
    1f24:	0f 90       	pop	r0
    1f26:	0f be       	out	0x3f, r0	; 63
    1f28:	80 e0       	ldi	r24, 0x00	; 0
    1f2a:	0c c1       	rjmp	.+536    	; 0x2144 <xQueueGive+0x2b8>
    1f2c:	a1 10       	cpse	r10, r1
    1f2e:	05 c0       	rjmp	.+10     	; 0x1f3a <xQueueGive+0xae>
    1f30:	ce 01       	movw	r24, r28
    1f32:	01 96       	adiw	r24, 0x01	; 1
    1f34:	0e 94 49 19 	call	0x3292	; 0x3292 <vTaskSetTimeOutState>
    1f38:	a9 2c       	mov	r10, r9
    1f3a:	0f 90       	pop	r0
    1f3c:	0f be       	out	0x3f, r0	; 63
    1f3e:	66 d6       	rcall	.+3276   	; 0x2c0c <vTaskSuspendAll>
    1f40:	0f b6       	in	r0, 0x3f	; 63
    1f42:	f8 94       	cli
    1f44:	0f 92       	push	r0
    1f46:	f8 01       	movw	r30, r16
    1f48:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f4a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f4c:	09 f4       	brne	.+2      	; 0x1f50 <xQueueGive+0xc4>
    1f4e:	15 8e       	std	Z+29, r1	; 0x1d
    1f50:	f8 01       	movw	r30, r16
    1f52:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f54:	8f 3f       	cpi	r24, 0xFF	; 255
    1f56:	09 f4       	brne	.+2      	; 0x1f5a <xQueueGive+0xce>
    1f58:	16 8e       	std	Z+30, r1	; 0x1e
    1f5a:	0f 90       	pop	r0
    1f5c:	0f be       	out	0x3f, r0	; 63
    1f5e:	be 01       	movw	r22, r28
    1f60:	6c 5f       	subi	r22, 0xFC	; 252
    1f62:	7f 4f       	sbci	r23, 0xFF	; 255
    1f64:	ce 01       	movw	r24, r28
    1f66:	01 96       	adiw	r24, 0x01	; 1
    1f68:	0e 94 54 19 	call	0x32a8	; 0x32a8 <xTaskCheckForTimeOut>
    1f6c:	81 11       	cpse	r24, r1
    1f6e:	94 c0       	rjmp	.+296    	; 0x2098 <xQueueGive+0x20c>
    1f70:	0f b6       	in	r0, 0x3f	; 63
    1f72:	f8 94       	cli
    1f74:	0f 92       	push	r0
    1f76:	f8 01       	movw	r30, r16
    1f78:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f7a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f7c:	0f 90       	pop	r0
    1f7e:	0f be       	out	0x3f, r0	; 63
    1f80:	98 13       	cpse	r25, r24
    1f82:	49 c0       	rjmp	.+146    	; 0x2016 <xQueueGive+0x18a>
    1f84:	6c 81       	ldd	r22, Y+4	; 0x04
    1f86:	7d 81       	ldd	r23, Y+5	; 0x05
    1f88:	c7 01       	movw	r24, r14
    1f8a:	0e 94 a6 18 	call	0x314c	; 0x314c <vTaskPlaceOnEventList>
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	0f 92       	push	r0
    1f94:	f8 01       	movw	r30, r16
    1f96:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f98:	18 16       	cp	r1, r24
    1f9a:	ac f4       	brge	.+42     	; 0x1fc6 <xQueueGive+0x13a>
    1f9c:	81 89       	ldd	r24, Z+17	; 0x11
    1f9e:	81 11       	cpse	r24, r1
    1fa0:	05 c0       	rjmp	.+10     	; 0x1fac <xQueueGive+0x120>
    1fa2:	11 c0       	rjmp	.+34     	; 0x1fc6 <xQueueGive+0x13a>
    1fa4:	f8 01       	movw	r30, r16
    1fa6:	81 89       	ldd	r24, Z+17	; 0x11
    1fa8:	88 23       	and	r24, r24
    1faa:	69 f0       	breq	.+26     	; 0x1fc6 <xQueueGive+0x13a>
    1fac:	c6 01       	movw	r24, r12
    1fae:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1fb2:	81 11       	cpse	r24, r1
    1fb4:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    1fb8:	f8 01       	movw	r30, r16
    1fba:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fbc:	81 50       	subi	r24, 0x01	; 1
    1fbe:	86 8f       	std	Z+30, r24	; 0x1e
    1fc0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fc2:	18 16       	cp	r1, r24
    1fc4:	7c f3       	brlt	.-34     	; 0x1fa4 <xQueueGive+0x118>
    1fc6:	f8 01       	movw	r30, r16
    1fc8:	b6 8e       	std	Z+30, r11	; 0x1e
    1fca:	0f 90       	pop	r0
    1fcc:	0f be       	out	0x3f, r0	; 63
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	f8 94       	cli
    1fd2:	0f 92       	push	r0
    1fd4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fd6:	18 16       	cp	r1, r24
    1fd8:	ac f4       	brge	.+42     	; 0x2004 <xQueueGive+0x178>
    1fda:	80 85       	ldd	r24, Z+8	; 0x08
    1fdc:	81 11       	cpse	r24, r1
    1fde:	05 c0       	rjmp	.+10     	; 0x1fea <xQueueGive+0x15e>
    1fe0:	11 c0       	rjmp	.+34     	; 0x2004 <xQueueGive+0x178>
    1fe2:	f8 01       	movw	r30, r16
    1fe4:	80 85       	ldd	r24, Z+8	; 0x08
    1fe6:	88 23       	and	r24, r24
    1fe8:	69 f0       	breq	.+26     	; 0x2004 <xQueueGive+0x178>
    1fea:	c7 01       	movw	r24, r14
    1fec:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    1ff0:	81 11       	cpse	r24, r1
    1ff2:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    1ff6:	f8 01       	movw	r30, r16
    1ff8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ffa:	81 50       	subi	r24, 0x01	; 1
    1ffc:	85 8f       	std	Z+29, r24	; 0x1d
    1ffe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2000:	18 16       	cp	r1, r24
    2002:	7c f3       	brlt	.-34     	; 0x1fe2 <xQueueGive+0x156>
    2004:	f8 01       	movw	r30, r16
    2006:	b5 8e       	std	Z+29, r11	; 0x1d
    2008:	0f 90       	pop	r0
    200a:	0f be       	out	0x3f, r0	; 63
    200c:	05 d6       	rcall	.+3082   	; 0x2c18 <xTaskResumeAll>
    200e:	81 11       	cpse	r24, r1
    2010:	5d cf       	rjmp	.-326    	; 0x1ecc <xQueueGive+0x40>
    2012:	45 dc       	rcall	.-1910   	; 0x189e <vPortYield>
    2014:	5b cf       	rjmp	.-330    	; 0x1ecc <xQueueGive+0x40>
    2016:	0f b6       	in	r0, 0x3f	; 63
    2018:	f8 94       	cli
    201a:	0f 92       	push	r0
    201c:	f8 01       	movw	r30, r16
    201e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2020:	18 16       	cp	r1, r24
    2022:	ac f4       	brge	.+42     	; 0x204e <xQueueGive+0x1c2>
    2024:	81 89       	ldd	r24, Z+17	; 0x11
    2026:	81 11       	cpse	r24, r1
    2028:	05 c0       	rjmp	.+10     	; 0x2034 <xQueueGive+0x1a8>
    202a:	11 c0       	rjmp	.+34     	; 0x204e <xQueueGive+0x1c2>
    202c:	f8 01       	movw	r30, r16
    202e:	81 89       	ldd	r24, Z+17	; 0x11
    2030:	88 23       	and	r24, r24
    2032:	69 f0       	breq	.+26     	; 0x204e <xQueueGive+0x1c2>
    2034:	c6 01       	movw	r24, r12
    2036:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    203a:	81 11       	cpse	r24, r1
    203c:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    2040:	f8 01       	movw	r30, r16
    2042:	86 8d       	ldd	r24, Z+30	; 0x1e
    2044:	81 50       	subi	r24, 0x01	; 1
    2046:	86 8f       	std	Z+30, r24	; 0x1e
    2048:	86 8d       	ldd	r24, Z+30	; 0x1e
    204a:	18 16       	cp	r1, r24
    204c:	7c f3       	brlt	.-34     	; 0x202c <xQueueGive+0x1a0>
    204e:	f8 01       	movw	r30, r16
    2050:	b6 8e       	std	Z+30, r11	; 0x1e
    2052:	0f 90       	pop	r0
    2054:	0f be       	out	0x3f, r0	; 63
    2056:	0f b6       	in	r0, 0x3f	; 63
    2058:	f8 94       	cli
    205a:	0f 92       	push	r0
    205c:	85 8d       	ldd	r24, Z+29	; 0x1d
    205e:	18 16       	cp	r1, r24
    2060:	ac f4       	brge	.+42     	; 0x208c <xQueueGive+0x200>
    2062:	80 85       	ldd	r24, Z+8	; 0x08
    2064:	81 11       	cpse	r24, r1
    2066:	05 c0       	rjmp	.+10     	; 0x2072 <xQueueGive+0x1e6>
    2068:	11 c0       	rjmp	.+34     	; 0x208c <xQueueGive+0x200>
    206a:	f8 01       	movw	r30, r16
    206c:	80 85       	ldd	r24, Z+8	; 0x08
    206e:	88 23       	and	r24, r24
    2070:	69 f0       	breq	.+26     	; 0x208c <xQueueGive+0x200>
    2072:	c7 01       	movw	r24, r14
    2074:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    2078:	81 11       	cpse	r24, r1
    207a:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    207e:	f8 01       	movw	r30, r16
    2080:	85 8d       	ldd	r24, Z+29	; 0x1d
    2082:	81 50       	subi	r24, 0x01	; 1
    2084:	85 8f       	std	Z+29, r24	; 0x1d
    2086:	85 8d       	ldd	r24, Z+29	; 0x1d
    2088:	18 16       	cp	r1, r24
    208a:	7c f3       	brlt	.-34     	; 0x206a <xQueueGive+0x1de>
    208c:	f8 01       	movw	r30, r16
    208e:	b5 8e       	std	Z+29, r11	; 0x1d
    2090:	0f 90       	pop	r0
    2092:	0f be       	out	0x3f, r0	; 63
    2094:	c1 d5       	rcall	.+2946   	; 0x2c18 <xTaskResumeAll>
    2096:	1a cf       	rjmp	.-460    	; 0x1ecc <xQueueGive+0x40>
    2098:	0f b6       	in	r0, 0x3f	; 63
    209a:	f8 94       	cli
    209c:	0f 92       	push	r0
    209e:	f8 01       	movw	r30, r16
    20a0:	86 8d       	ldd	r24, Z+30	; 0x1e
    20a2:	18 16       	cp	r1, r24
    20a4:	d4 f4       	brge	.+52     	; 0x20da <xQueueGive+0x24e>
    20a6:	81 89       	ldd	r24, Z+17	; 0x11
    20a8:	81 11       	cpse	r24, r1
    20aa:	06 c0       	rjmp	.+12     	; 0x20b8 <xQueueGive+0x22c>
    20ac:	16 c0       	rjmp	.+44     	; 0x20da <xQueueGive+0x24e>
    20ae:	f8 01       	movw	r30, r16
    20b0:	81 89       	ldd	r24, Z+17	; 0x11
    20b2:	81 11       	cpse	r24, r1
    20b4:	05 c0       	rjmp	.+10     	; 0x20c0 <xQueueGive+0x234>
    20b6:	11 c0       	rjmp	.+34     	; 0x20da <xQueueGive+0x24e>
    20b8:	78 01       	movw	r14, r16
    20ba:	f1 e1       	ldi	r31, 0x11	; 17
    20bc:	ef 0e       	add	r14, r31
    20be:	f1 1c       	adc	r15, r1
    20c0:	c7 01       	movw	r24, r14
    20c2:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    20c6:	81 11       	cpse	r24, r1
    20c8:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    20cc:	f8 01       	movw	r30, r16
    20ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    20d0:	81 50       	subi	r24, 0x01	; 1
    20d2:	86 8f       	std	Z+30, r24	; 0x1e
    20d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    20d6:	18 16       	cp	r1, r24
    20d8:	54 f3       	brlt	.-44     	; 0x20ae <xQueueGive+0x222>
    20da:	8f ef       	ldi	r24, 0xFF	; 255
    20dc:	f8 01       	movw	r30, r16
    20de:	86 8f       	std	Z+30, r24	; 0x1e
    20e0:	0f 90       	pop	r0
    20e2:	0f be       	out	0x3f, r0	; 63
    20e4:	0f b6       	in	r0, 0x3f	; 63
    20e6:	f8 94       	cli
    20e8:	0f 92       	push	r0
    20ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    20ec:	18 16       	cp	r1, r24
    20ee:	d4 f4       	brge	.+52     	; 0x2124 <xQueueGive+0x298>
    20f0:	80 85       	ldd	r24, Z+8	; 0x08
    20f2:	81 11       	cpse	r24, r1
    20f4:	06 c0       	rjmp	.+12     	; 0x2102 <xQueueGive+0x276>
    20f6:	16 c0       	rjmp	.+44     	; 0x2124 <xQueueGive+0x298>
    20f8:	f8 01       	movw	r30, r16
    20fa:	80 85       	ldd	r24, Z+8	; 0x08
    20fc:	81 11       	cpse	r24, r1
    20fe:	05 c0       	rjmp	.+10     	; 0x210a <xQueueGive+0x27e>
    2100:	11 c0       	rjmp	.+34     	; 0x2124 <xQueueGive+0x298>
    2102:	78 01       	movw	r14, r16
    2104:	f8 e0       	ldi	r31, 0x08	; 8
    2106:	ef 0e       	add	r14, r31
    2108:	f1 1c       	adc	r15, r1
    210a:	c7 01       	movw	r24, r14
    210c:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    2110:	81 11       	cpse	r24, r1
    2112:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskMissedYield>
    2116:	f8 01       	movw	r30, r16
    2118:	85 8d       	ldd	r24, Z+29	; 0x1d
    211a:	81 50       	subi	r24, 0x01	; 1
    211c:	85 8f       	std	Z+29, r24	; 0x1d
    211e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2120:	18 16       	cp	r1, r24
    2122:	54 f3       	brlt	.-44     	; 0x20f8 <xQueueGive+0x26c>
    2124:	8f ef       	ldi	r24, 0xFF	; 255
    2126:	f8 01       	movw	r30, r16
    2128:	85 8f       	std	Z+29, r24	; 0x1d
    212a:	0f 90       	pop	r0
    212c:	0f be       	out	0x3f, r0	; 63
    212e:	74 d5       	rcall	.+2792   	; 0x2c18 <xTaskResumeAll>
    2130:	80 e0       	ldi	r24, 0x00	; 0
    2132:	08 c0       	rjmp	.+16     	; 0x2144 <xQueueGive+0x2b8>
    2134:	f8 01       	movw	r30, r16
    2136:	82 8d       	ldd	r24, Z+26	; 0x1a
    2138:	8f 5f       	subi	r24, 0xFF	; 255
    213a:	82 8f       	std	Z+26, r24	; 0x1a
    213c:	81 89       	ldd	r24, Z+17	; 0x11
    213e:	81 11       	cpse	r24, r1
    2140:	df ce       	rjmp	.-578    	; 0x1f00 <xQueueGive+0x74>
    2142:	e8 ce       	rjmp	.-560    	; 0x1f14 <xQueueGive+0x88>
    2144:	0f 90       	pop	r0
    2146:	0f 90       	pop	r0
    2148:	0f 90       	pop	r0
    214a:	0f 90       	pop	r0
    214c:	0f 90       	pop	r0
    214e:	df 91       	pop	r29
    2150:	cf 91       	pop	r28
    2152:	1f 91       	pop	r17
    2154:	0f 91       	pop	r16
    2156:	ff 90       	pop	r15
    2158:	ef 90       	pop	r14
    215a:	df 90       	pop	r13
    215c:	cf 90       	pop	r12
    215e:	bf 90       	pop	r11
    2160:	af 90       	pop	r10
    2162:	9f 90       	pop	r9
    2164:	08 95       	ret

00002166 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2166:	cf 93       	push	r28
    2168:	df 93       	push	r29
    216a:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    216c:	92 8d       	ldd	r25, Z+26	; 0x1a
    216e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2170:	98 17       	cp	r25, r24
    2172:	d0 f4       	brcc	.+52     	; 0x21a8 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    2174:	82 8d       	ldd	r24, Z+26	; 0x1a
    2176:	8f 5f       	subi	r24, 0xFF	; 255
    2178:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    217a:	86 8d       	ldd	r24, Z+30	; 0x1e
    217c:	8f 3f       	cpi	r24, 0xFF	; 255
    217e:	79 f4       	brne	.+30     	; 0x219e <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2180:	81 89       	ldd	r24, Z+17	; 0x11
    2182:	88 23       	and	r24, r24
    2184:	99 f0       	breq	.+38     	; 0x21ac <xQueueGiveFromISR+0x46>
    2186:	eb 01       	movw	r28, r22
    2188:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    218a:	41 96       	adiw	r24, 0x11	; 17
    218c:	0e 94 01 19 	call	0x3202	; 0x3202 <xTaskRemoveFromEventList>
    2190:	88 23       	and	r24, r24
    2192:	71 f0       	breq	.+28     	; 0x21b0 <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2194:	20 97       	sbiw	r28, 0x00	; 0
    2196:	71 f0       	breq	.+28     	; 0x21b4 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2198:	81 e0       	ldi	r24, 0x01	; 1
    219a:	88 83       	st	Y, r24
    219c:	0c c0       	rjmp	.+24     	; 0x21b6 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    219e:	86 8d       	ldd	r24, Z+30	; 0x1e
    21a0:	8f 5f       	subi	r24, 0xFF	; 255
    21a2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    21a4:	81 e0       	ldi	r24, 0x01	; 1
    21a6:	07 c0       	rjmp	.+14     	; 0x21b6 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    21a8:	80 e0       	ldi	r24, 0x00	; 0
    21aa:	05 c0       	rjmp	.+10     	; 0x21b6 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    21ac:	81 e0       	ldi	r24, 0x01	; 1
    21ae:	03 c0       	rjmp	.+6      	; 0x21b6 <xQueueGiveFromISR+0x50>
    21b0:	81 e0       	ldi	r24, 0x01	; 1
    21b2:	01 c0       	rjmp	.+2      	; 0x21b6 <xQueueGiveFromISR+0x50>
    21b4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    21b6:	df 91       	pop	r29
    21b8:	cf 91       	pop	r28
    21ba:	08 95       	ret

000021bc <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    21bc:	6f 92       	push	r6
    21be:	7f 92       	push	r7
    21c0:	8f 92       	push	r8
    21c2:	9f 92       	push	r9
    21c4:	af 92       	push	r10
    21c6:	bf 92       	push	r11
    21c8:	cf 92       	push	r12
    21ca:	df 92       	push	r13
    21cc:	ef 92       	push	r14
    21ce:	ff 92       	push	r15
    21d0:	0f 93       	push	r16
    21d2:	1f 93       	push	r17
    21d4:	cf 93       	push	r28
    21d6:	df 93       	push	r29
    21d8:	00 d0       	rcall	.+0      	; 0x21da <xQueueGenericReceive+0x1e>
    21da:	1f 92       	push	r1
    21dc:	1f 92       	push	r1
    21de:	cd b7       	in	r28, 0x3d	; 61
    21e0:	de b7       	in	r29, 0x3e	; 62
    21e2:	8c 01       	movw	r16, r24
    21e4:	5b 01       	movw	r10, r22
    21e6:	5d 83       	std	Y+5, r21	; 0x05
    21e8:	4c 83       	std	Y+4, r20	; 0x04
    21ea:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    21ec:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    21ee:	77 24       	eor	r7, r7
    21f0:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    21f2:	99 24       	eor	r9, r9
    21f4:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    21f6:	6c 01       	movw	r12, r24
    21f8:	88 e0       	ldi	r24, 0x08	; 8
    21fa:	c8 0e       	add	r12, r24
    21fc:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21fe:	78 01       	movw	r14, r16
    2200:	e1 e1       	ldi	r30, 0x11	; 17
    2202:	ee 0e       	add	r14, r30
    2204:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2206:	0f b6       	in	r0, 0x3f	; 63
    2208:	f8 94       	cli
    220a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    220c:	f8 01       	movw	r30, r16
    220e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2210:	88 23       	and	r24, r24
    2212:	09 f4       	brne	.+2      	; 0x2216 <__stack+0x17>
    2214:	43 c0       	rjmp	.+134    	; 0x229c <__stack+0x9d>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2216:	e6 80       	ldd	r14, Z+6	; 0x06
    2218:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    221a:	44 8d       	ldd	r20, Z+28	; 0x1c
    221c:	44 23       	and	r20, r20
    221e:	a9 f0       	breq	.+42     	; 0x224a <__stack+0x4b>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2220:	50 e0       	ldi	r21, 0x00	; 0
    2222:	c7 01       	movw	r24, r14
    2224:	84 0f       	add	r24, r20
    2226:	95 1f       	adc	r25, r21
    2228:	97 83       	std	Z+7, r25	; 0x07
    222a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    222c:	22 81       	ldd	r18, Z+2	; 0x02
    222e:	33 81       	ldd	r19, Z+3	; 0x03
    2230:	82 17       	cp	r24, r18
    2232:	93 07       	cpc	r25, r19
    2234:	20 f0       	brcs	.+8      	; 0x223e <__stack+0x3f>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2236:	80 81       	ld	r24, Z
    2238:	91 81       	ldd	r25, Z+1	; 0x01
    223a:	97 83       	std	Z+7, r25	; 0x07
    223c:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    223e:	f8 01       	movw	r30, r16
    2240:	66 81       	ldd	r22, Z+6	; 0x06
    2242:	77 81       	ldd	r23, Z+7	; 0x07
    2244:	c5 01       	movw	r24, r10
    2246:	0e 94 de 21 	call	0x43bc	; 0x43bc <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    224a:	61 10       	cpse	r6, r1
    224c:	18 c0       	rjmp	.+48     	; 0x227e <__stack+0x7f>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    224e:	f8 01       	movw	r30, r16
    2250:	82 8d       	ldd	r24, Z+26	; 0x1a
    2252:	81 50       	subi	r24, 0x01	; 1
    2254:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2256:	80 81       	ld	r24, Z
    2258:	91 81       	ldd	r25, Z+1	; 0x01
    225a:	89 2b       	or	r24, r25
    225c:	29 f4       	brne	.+10     	; 0x2268 <__stack+0x69>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    225e:	0e 94 35 1a 	call	0x346a	; 0x346a <pvTaskIncrementMutexHeldCount>
    2262:	f8 01       	movw	r30, r16
    2264:	93 83       	std	Z+3, r25	; 0x03
    2266:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2268:	f8 01       	movw	r30, r16
    226a:	80 85       	ldd	r24, Z+8	; 0x08
    226c:	88 23       	and	r24, r24
    226e:	91 f0       	breq	.+36     	; 0x2294 <__stack+0x95>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2270:	c8 01       	movw	r24, r16
    2272:	08 96       	adiw	r24, 0x08	; 8
    2274:	c6 d7       	rcall	.+3980   	; 0x3202 <xTaskRemoveFromEventList>
    2276:	81 30       	cpi	r24, 0x01	; 1
    2278:	69 f4       	brne	.+26     	; 0x2294 <__stack+0x95>
						{
							queueYIELD_IF_USING_PREEMPTION();
    227a:	11 db       	rcall	.-2526   	; 0x189e <vPortYield>
    227c:	0b c0       	rjmp	.+22     	; 0x2294 <__stack+0x95>
    227e:	f8 01       	movw	r30, r16
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2280:	f7 82       	std	Z+7, r15	; 0x07
    2282:	e6 82       	std	Z+6, r14	; 0x06
    2284:	81 89       	ldd	r24, Z+17	; 0x11

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2286:	88 23       	and	r24, r24
    2288:	29 f0       	breq	.+10     	; 0x2294 <__stack+0x95>
    228a:	c8 01       	movw	r24, r16
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    228c:	41 96       	adiw	r24, 0x11	; 17
    228e:	b9 d7       	rcall	.+3954   	; 0x3202 <xTaskRemoveFromEventList>
    2290:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2292:	05 db       	rcall	.-2550   	; 0x189e <vPortYield>
    2294:	0f 90       	pop	r0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	81 e0       	ldi	r24, 0x01	; 1
				return pdPASS;
    229a:	08 c1       	rjmp	.+528    	; 0x24ac <__stack+0x2ad>
    229c:	8c 81       	ldd	r24, Y+4	; 0x04
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    229e:	9d 81       	ldd	r25, Y+5	; 0x05
    22a0:	89 2b       	or	r24, r25
    22a2:	21 f4       	brne	.+8      	; 0x22ac <__stack+0xad>
    22a4:	0f 90       	pop	r0
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    22a6:	0f be       	out	0x3f, r0	; 63
    22a8:	80 e0       	ldi	r24, 0x00	; 0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    22aa:	00 c1       	rjmp	.+512    	; 0x24ac <__stack+0x2ad>
    22ac:	81 10       	cpse	r8, r1
				}
				else if( xEntryTimeSet == pdFALSE )
    22ae:	04 c0       	rjmp	.+8      	; 0x22b8 <__stack+0xb9>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    22b0:	ce 01       	movw	r24, r28
    22b2:	01 96       	adiw	r24, 0x01	; 1
    22b4:	ee d7       	rcall	.+4060   	; 0x3292 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    22b6:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    22b8:	0f 90       	pop	r0
    22ba:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    22bc:	a7 d4       	rcall	.+2382   	; 0x2c0c <vTaskSuspendAll>
    22be:	0f b6       	in	r0, 0x3f	; 63
		prvLockQueue( pxQueue );
    22c0:	f8 94       	cli
    22c2:	0f 92       	push	r0
    22c4:	f8 01       	movw	r30, r16
    22c6:	85 8d       	ldd	r24, Z+29	; 0x1d
    22c8:	8f 3f       	cpi	r24, 0xFF	; 255
    22ca:	09 f4       	brne	.+2      	; 0x22ce <__stack+0xcf>
    22cc:	15 8e       	std	Z+29, r1	; 0x1d
    22ce:	f8 01       	movw	r30, r16
    22d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    22d2:	8f 3f       	cpi	r24, 0xFF	; 255
    22d4:	09 f4       	brne	.+2      	; 0x22d8 <__stack+0xd9>
    22d6:	16 8e       	std	Z+30, r1	; 0x1e
    22d8:	0f 90       	pop	r0
    22da:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    22dc:	be 01       	movw	r22, r28
    22de:	6c 5f       	subi	r22, 0xFC	; 252
    22e0:	7f 4f       	sbci	r23, 0xFF	; 255
    22e2:	ce 01       	movw	r24, r28
    22e4:	01 96       	adiw	r24, 0x01	; 1
    22e6:	e0 d7       	rcall	.+4032   	; 0x32a8 <xTaskCheckForTimeOut>
    22e8:	81 11       	cpse	r24, r1
    22ea:	97 c0       	rjmp	.+302    	; 0x241a <__stack+0x21b>
    22ec:	0f b6       	in	r0, 0x3f	; 63

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    22ee:	f8 94       	cli
    22f0:	0f 92       	push	r0
    22f2:	f8 01       	movw	r30, r16
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    22f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    22f6:	0f 90       	pop	r0
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    22f8:	0f be       	out	0x3f, r0	; 63
    22fa:	81 11       	cpse	r24, r1
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22fc:	51 c0       	rjmp	.+162    	; 0x23a0 <__stack+0x1a1>
    22fe:	80 81       	ld	r24, Z
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2300:	91 81       	ldd	r25, Z+1	; 0x01
    2302:	89 2b       	or	r24, r25
    2304:	49 f4       	brne	.+18     	; 0x2318 <__stack+0x119>
    2306:	0f b6       	in	r0, 0x3f	; 63
					{
						taskENTER_CRITICAL();
    2308:	f8 94       	cli
    230a:	0f 92       	push	r0
    230c:	82 81       	ldd	r24, Z+2	; 0x02
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    230e:	93 81       	ldd	r25, Z+3	; 0x03
    2310:	0e 94 93 19 	call	0x3326	; 0x3326 <vTaskPriorityInherit>
    2314:	0f 90       	pop	r0
						}
						taskEXIT_CRITICAL();
    2316:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2318:	6c 81       	ldd	r22, Y+4	; 0x04
    231a:	7d 81       	ldd	r23, Y+5	; 0x05
    231c:	c7 01       	movw	r24, r14
    231e:	16 d7       	rcall	.+3628   	; 0x314c <vTaskPlaceOnEventList>
    2320:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2322:	f8 94       	cli
    2324:	0f 92       	push	r0
    2326:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2328:	86 8d       	ldd	r24, Z+30	; 0x1e
    232a:	18 16       	cp	r1, r24
    232c:	9c f4       	brge	.+38     	; 0x2354 <__stack+0x155>
    232e:	81 89       	ldd	r24, Z+17	; 0x11
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2330:	81 11       	cpse	r24, r1
    2332:	05 c0       	rjmp	.+10     	; 0x233e <__stack+0x13f>
    2334:	0f c0       	rjmp	.+30     	; 0x2354 <__stack+0x155>
    2336:	f8 01       	movw	r30, r16
    2338:	81 89       	ldd	r24, Z+17	; 0x11
    233a:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    233c:	59 f0       	breq	.+22     	; 0x2354 <__stack+0x155>
    233e:	c7 01       	movw	r24, r14
    2340:	60 d7       	rcall	.+3776   	; 0x3202 <xTaskRemoveFromEventList>
    2342:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2344:	ec d7       	rcall	.+4056   	; 0x331e <vTaskMissedYield>
    2346:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2348:	86 8d       	ldd	r24, Z+30	; 0x1e
    234a:	81 50       	subi	r24, 0x01	; 1
    234c:	86 8f       	std	Z+30, r24	; 0x1e
    234e:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2350:	18 16       	cp	r1, r24
    2352:	8c f3       	brlt	.-30     	; 0x2336 <__stack+0x137>
    2354:	f8 01       	movw	r30, r16
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2356:	96 8e       	std	Z+30, r9	; 0x1e
    2358:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    235a:	0f be       	out	0x3f, r0	; 63
    235c:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    235e:	f8 94       	cli
    2360:	0f 92       	push	r0
    2362:	85 8d       	ldd	r24, Z+29	; 0x1d
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2364:	18 16       	cp	r1, r24
    2366:	9c f4       	brge	.+38     	; 0x238e <__stack+0x18f>
    2368:	80 85       	ldd	r24, Z+8	; 0x08
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    236a:	81 11       	cpse	r24, r1
    236c:	05 c0       	rjmp	.+10     	; 0x2378 <__stack+0x179>
    236e:	0f c0       	rjmp	.+30     	; 0x238e <__stack+0x18f>
    2370:	f8 01       	movw	r30, r16
    2372:	80 85       	ldd	r24, Z+8	; 0x08
    2374:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2376:	59 f0       	breq	.+22     	; 0x238e <__stack+0x18f>
    2378:	c6 01       	movw	r24, r12
    237a:	43 d7       	rcall	.+3718   	; 0x3202 <xTaskRemoveFromEventList>
    237c:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    237e:	cf d7       	rcall	.+3998   	; 0x331e <vTaskMissedYield>
    2380:	f8 01       	movw	r30, r16
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2382:	85 8d       	ldd	r24, Z+29	; 0x1d
    2384:	81 50       	subi	r24, 0x01	; 1
    2386:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2388:	85 8d       	ldd	r24, Z+29	; 0x1d
    238a:	18 16       	cp	r1, r24
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    238c:	8c f3       	brlt	.-30     	; 0x2370 <__stack+0x171>
    238e:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    2390:	95 8e       	std	Z+29, r9	; 0x1d
    2392:	0f 90       	pop	r0
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    2394:	0f be       	out	0x3f, r0	; 63
    2396:	40 d4       	rcall	.+2176   	; 0x2c18 <xTaskResumeAll>
    2398:	81 11       	cpse	r24, r1
    239a:	35 cf       	rjmp	.-406    	; 0x2206 <__stack+0x7>
				{
					portYIELD_WITHIN_API();
    239c:	80 da       	rcall	.-2816   	; 0x189e <vPortYield>
    239e:	33 cf       	rjmp	.-410    	; 0x2206 <__stack+0x7>
    23a0:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    23a2:	f8 94       	cli
    23a4:	0f 92       	push	r0
    23a6:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    23a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    23aa:	18 16       	cp	r1, r24
    23ac:	9c f4       	brge	.+38     	; 0x23d4 <__stack+0x1d5>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23ae:	81 89       	ldd	r24, Z+17	; 0x11
    23b0:	81 11       	cpse	r24, r1
    23b2:	05 c0       	rjmp	.+10     	; 0x23be <__stack+0x1bf>
    23b4:	0f c0       	rjmp	.+30     	; 0x23d4 <__stack+0x1d5>
    23b6:	f8 01       	movw	r30, r16
    23b8:	81 89       	ldd	r24, Z+17	; 0x11
    23ba:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23bc:	59 f0       	breq	.+22     	; 0x23d4 <__stack+0x1d5>
    23be:	c7 01       	movw	r24, r14
    23c0:	20 d7       	rcall	.+3648   	; 0x3202 <xTaskRemoveFromEventList>
    23c2:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    23c4:	ac d7       	rcall	.+3928   	; 0x331e <vTaskMissedYield>
    23c6:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    23c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    23ca:	81 50       	subi	r24, 0x01	; 1
    23cc:	86 8f       	std	Z+30, r24	; 0x1e
    23ce:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    23d0:	18 16       	cp	r1, r24
    23d2:	8c f3       	brlt	.-30     	; 0x23b6 <__stack+0x1b7>
    23d4:	f8 01       	movw	r30, r16
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    23d6:	96 8e       	std	Z+30, r9	; 0x1e
    23d8:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    23da:	0f be       	out	0x3f, r0	; 63
    23dc:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    23de:	f8 94       	cli
    23e0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    23e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    23e4:	18 16       	cp	r1, r24
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    23e6:	9c f4       	brge	.+38     	; 0x240e <__stack+0x20f>
    23e8:	80 85       	ldd	r24, Z+8	; 0x08
    23ea:	81 11       	cpse	r24, r1
    23ec:	05 c0       	rjmp	.+10     	; 0x23f8 <__stack+0x1f9>
    23ee:	0f c0       	rjmp	.+30     	; 0x240e <__stack+0x20f>
    23f0:	f8 01       	movw	r30, r16
    23f2:	80 85       	ldd	r24, Z+8	; 0x08
    23f4:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23f6:	59 f0       	breq	.+22     	; 0x240e <__stack+0x20f>
    23f8:	c6 01       	movw	r24, r12
    23fa:	03 d7       	rcall	.+3590   	; 0x3202 <xTaskRemoveFromEventList>
				{
					vTaskMissedYield();
    23fc:	81 11       	cpse	r24, r1
    23fe:	8f d7       	rcall	.+3870   	; 0x331e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2400:	f8 01       	movw	r30, r16
    2402:	85 8d       	ldd	r24, Z+29	; 0x1d
    2404:	81 50       	subi	r24, 0x01	; 1
    2406:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2408:	85 8d       	ldd	r24, Z+29	; 0x1d
    240a:	18 16       	cp	r1, r24
    240c:	8c f3       	brlt	.-30     	; 0x23f0 <__stack+0x1f1>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    240e:	f8 01       	movw	r30, r16
    2410:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    2412:	0f 90       	pop	r0
    2414:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    2416:	00 d4       	rcall	.+2048   	; 0x2c18 <xTaskResumeAll>
    2418:	f6 ce       	rjmp	.-532    	; 0x2206 <__stack+0x7>
    241a:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    241c:	f8 94       	cli
    241e:	0f 92       	push	r0
    2420:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2422:	86 8d       	ldd	r24, Z+30	; 0x1e
    2424:	18 16       	cp	r1, r24
    2426:	c4 f4       	brge	.+48     	; 0x2458 <__stack+0x259>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2428:	81 89       	ldd	r24, Z+17	; 0x11
    242a:	81 11       	cpse	r24, r1
    242c:	06 c0       	rjmp	.+12     	; 0x243a <__stack+0x23b>
    242e:	14 c0       	rjmp	.+40     	; 0x2458 <__stack+0x259>
    2430:	f8 01       	movw	r30, r16
    2432:	81 89       	ldd	r24, Z+17	; 0x11
    2434:	81 11       	cpse	r24, r1
    2436:	05 c0       	rjmp	.+10     	; 0x2442 <__stack+0x243>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2438:	0f c0       	rjmp	.+30     	; 0x2458 <__stack+0x259>
    243a:	78 01       	movw	r14, r16
    243c:	f1 e1       	ldi	r31, 0x11	; 17
    243e:	ef 0e       	add	r14, r31
    2440:	f1 1c       	adc	r15, r1
    2442:	c7 01       	movw	r24, r14
    2444:	de d6       	rcall	.+3516   	; 0x3202 <xTaskRemoveFromEventList>
    2446:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2448:	6a d7       	rcall	.+3796   	; 0x331e <vTaskMissedYield>
    244a:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    244c:	86 8d       	ldd	r24, Z+30	; 0x1e
    244e:	81 50       	subi	r24, 0x01	; 1
    2450:	86 8f       	std	Z+30, r24	; 0x1e
    2452:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2454:	18 16       	cp	r1, r24
    2456:	64 f3       	brlt	.-40     	; 0x2430 <__stack+0x231>
    2458:	8f ef       	ldi	r24, 0xFF	; 255
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    245a:	f8 01       	movw	r30, r16
    245c:	86 8f       	std	Z+30, r24	; 0x1e
    245e:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    2460:	0f be       	out	0x3f, r0	; 63
    2462:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2464:	f8 94       	cli
    2466:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2468:	85 8d       	ldd	r24, Z+29	; 0x1d
    246a:	18 16       	cp	r1, r24
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    246c:	c4 f4       	brge	.+48     	; 0x249e <__stack+0x29f>
    246e:	80 85       	ldd	r24, Z+8	; 0x08
    2470:	81 11       	cpse	r24, r1
    2472:	06 c0       	rjmp	.+12     	; 0x2480 <__stack+0x281>
    2474:	14 c0       	rjmp	.+40     	; 0x249e <__stack+0x29f>
    2476:	f8 01       	movw	r30, r16
    2478:	80 85       	ldd	r24, Z+8	; 0x08
    247a:	81 11       	cpse	r24, r1
    247c:	05 c0       	rjmp	.+10     	; 0x2488 <__stack+0x289>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    247e:	0f c0       	rjmp	.+30     	; 0x249e <__stack+0x29f>
    2480:	78 01       	movw	r14, r16
    2482:	f8 e0       	ldi	r31, 0x08	; 8
    2484:	ef 0e       	add	r14, r31
    2486:	f1 1c       	adc	r15, r1
    2488:	c7 01       	movw	r24, r14
    248a:	bb d6       	rcall	.+3446   	; 0x3202 <xTaskRemoveFromEventList>
				{
					vTaskMissedYield();
    248c:	81 11       	cpse	r24, r1
    248e:	47 d7       	rcall	.+3726   	; 0x331e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2490:	f8 01       	movw	r30, r16
    2492:	85 8d       	ldd	r24, Z+29	; 0x1d
    2494:	81 50       	subi	r24, 0x01	; 1
    2496:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2498:	85 8d       	ldd	r24, Z+29	; 0x1d
    249a:	18 16       	cp	r1, r24
    249c:	64 f3       	brlt	.-40     	; 0x2476 <__stack+0x277>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    249e:	8f ef       	ldi	r24, 0xFF	; 255
    24a0:	f8 01       	movw	r30, r16
    24a2:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    24a4:	0f 90       	pop	r0
    24a6:	0f be       	out	0x3f, r0	; 63
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    24a8:	b7 d3       	rcall	.+1902   	; 0x2c18 <xTaskResumeAll>
    24aa:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    24ac:	0f 90       	pop	r0
		}
	}
}
    24ae:	0f 90       	pop	r0
    24b0:	0f 90       	pop	r0
    24b2:	0f 90       	pop	r0
    24b4:	0f 90       	pop	r0
    24b6:	df 91       	pop	r29
    24b8:	cf 91       	pop	r28
    24ba:	1f 91       	pop	r17
    24bc:	0f 91       	pop	r16
    24be:	ff 90       	pop	r15
    24c0:	ef 90       	pop	r14
    24c2:	df 90       	pop	r13
    24c4:	cf 90       	pop	r12
    24c6:	bf 90       	pop	r11
    24c8:	af 90       	pop	r10
    24ca:	9f 90       	pop	r9
    24cc:	8f 90       	pop	r8
    24ce:	7f 90       	pop	r7
    24d0:	6f 90       	pop	r6
    24d2:	08 95       	ret

000024d4 <xTaskGenericCreate>:
    24d4:	4f 92       	push	r4
    24d6:	5f 92       	push	r5
    24d8:	6f 92       	push	r6
    24da:	7f 92       	push	r7
    24dc:	8f 92       	push	r8
    24de:	9f 92       	push	r9
    24e0:	af 92       	push	r10
    24e2:	bf 92       	push	r11
    24e4:	cf 92       	push	r12
    24e6:	df 92       	push	r13
    24e8:	ef 92       	push	r14
    24ea:	ff 92       	push	r15
    24ec:	0f 93       	push	r16
    24ee:	1f 93       	push	r17
    24f0:	cf 93       	push	r28
    24f2:	df 93       	push	r29
    24f4:	4c 01       	movw	r8, r24
    24f6:	eb 01       	movw	r28, r22
    24f8:	5a 01       	movw	r10, r20
    24fa:	29 01       	movw	r4, r18
    24fc:	c1 14       	cp	r12, r1
    24fe:	d1 04       	cpc	r13, r1
    2500:	31 f4       	brne	.+12     	; 0x250e <xTaskGenericCreate+0x3a>
    2502:	ca 01       	movw	r24, r20
    2504:	51 d8       	rcall	.-3934   	; 0x15a8 <pvPortMalloc>
    2506:	6c 01       	movw	r12, r24
    2508:	89 2b       	or	r24, r25
    250a:	09 f4       	brne	.+2      	; 0x250e <xTaskGenericCreate+0x3a>
    250c:	e1 c0       	rjmp	.+450    	; 0x26d0 <xTaskGenericCreate+0x1fc>
    250e:	88 e2       	ldi	r24, 0x28	; 40
    2510:	90 e0       	ldi	r25, 0x00	; 0
    2512:	4a d8       	rcall	.-3948   	; 0x15a8 <pvPortMalloc>
    2514:	3c 01       	movw	r6, r24
    2516:	00 97       	sbiw	r24, 0x00	; 0
    2518:	b9 f0       	breq	.+46     	; 0x2548 <xTaskGenericCreate+0x74>
    251a:	fc 01       	movw	r30, r24
    251c:	d0 8e       	std	Z+24, r13	; 0x18
    251e:	c7 8a       	std	Z+23, r12	; 0x17
    2520:	a5 01       	movw	r20, r10
    2522:	65 ea       	ldi	r22, 0xA5	; 165
    2524:	70 e0       	ldi	r23, 0x00	; 0
    2526:	c6 01       	movw	r24, r12
    2528:	0e 94 e7 21 	call	0x43ce	; 0x43ce <memset>
    252c:	f1 e0       	ldi	r31, 0x01	; 1
    252e:	af 1a       	sub	r10, r31
    2530:	b1 08       	sbc	r11, r1
    2532:	f3 01       	movw	r30, r6
    2534:	87 89       	ldd	r24, Z+23	; 0x17
    2536:	90 8d       	ldd	r25, Z+24	; 0x18
    2538:	a8 0e       	add	r10, r24
    253a:	b9 1e       	adc	r11, r25
    253c:	88 81       	ld	r24, Y
    253e:	81 8f       	std	Z+25, r24	; 0x19
    2540:	88 81       	ld	r24, Y
    2542:	81 11       	cpse	r24, r1
    2544:	04 c0       	rjmp	.+8      	; 0x254e <xTaskGenericCreate+0x7a>
    2546:	13 c0       	rjmp	.+38     	; 0x256e <xTaskGenericCreate+0x9a>
    2548:	c6 01       	movw	r24, r12
    254a:	63 d8       	rcall	.-3898   	; 0x1612 <vPortFree>
    254c:	c1 c0       	rjmp	.+386    	; 0x26d0 <xTaskGenericCreate+0x1fc>
    254e:	d3 01       	movw	r26, r6
    2550:	5a 96       	adiw	r26, 0x1a	; 26
    2552:	fe 01       	movw	r30, r28
    2554:	31 96       	adiw	r30, 0x01	; 1
    2556:	9e 01       	movw	r18, r28
    2558:	28 5f       	subi	r18, 0xF8	; 248
    255a:	3f 4f       	sbci	r19, 0xFF	; 255
    255c:	ef 01       	movw	r28, r30
    255e:	81 91       	ld	r24, Z+
    2560:	8d 93       	st	X+, r24
    2562:	88 81       	ld	r24, Y
    2564:	88 23       	and	r24, r24
    2566:	19 f0       	breq	.+6      	; 0x256e <xTaskGenericCreate+0x9a>
    2568:	2e 17       	cp	r18, r30
    256a:	3f 07       	cpc	r19, r31
    256c:	b9 f7       	brne	.-18     	; 0x255c <xTaskGenericCreate+0x88>
    256e:	f3 01       	movw	r30, r6
    2570:	10 a2       	std	Z+32, r1	; 0x20
    2572:	10 2f       	mov	r17, r16
    2574:	04 30       	cpi	r16, 0x04	; 4
    2576:	08 f0       	brcs	.+2      	; 0x257a <xTaskGenericCreate+0xa6>
    2578:	13 e0       	ldi	r17, 0x03	; 3
    257a:	f3 01       	movw	r30, r6
    257c:	16 8b       	std	Z+22, r17	; 0x16
    257e:	11 a3       	std	Z+33, r17	; 0x21
    2580:	12 a2       	std	Z+34, r1	; 0x22
    2582:	e3 01       	movw	r28, r6
    2584:	22 96       	adiw	r28, 0x02	; 2
    2586:	ce 01       	movw	r24, r28
    2588:	53 d8       	rcall	.-3930   	; 0x1630 <vListInitialiseItem>
    258a:	c3 01       	movw	r24, r6
    258c:	0c 96       	adiw	r24, 0x0c	; 12
    258e:	50 d8       	rcall	.-3936   	; 0x1630 <vListInitialiseItem>
    2590:	f3 01       	movw	r30, r6
    2592:	71 86       	std	Z+9, r7	; 0x09
    2594:	60 86       	std	Z+8, r6	; 0x08
    2596:	84 e0       	ldi	r24, 0x04	; 4
    2598:	90 e0       	ldi	r25, 0x00	; 0
    259a:	81 1b       	sub	r24, r17
    259c:	91 09       	sbc	r25, r1
    259e:	95 87       	std	Z+13, r25	; 0x0d
    25a0:	84 87       	std	Z+12, r24	; 0x0c
    25a2:	73 8a       	std	Z+19, r7	; 0x13
    25a4:	62 8a       	std	Z+18, r6	; 0x12
    25a6:	13 a2       	std	Z+35, r1	; 0x23
    25a8:	14 a2       	std	Z+36, r1	; 0x24
    25aa:	15 a2       	std	Z+37, r1	; 0x25
    25ac:	16 a2       	std	Z+38, r1	; 0x26
    25ae:	17 a2       	std	Z+39, r1	; 0x27
    25b0:	a2 01       	movw	r20, r4
    25b2:	b4 01       	movw	r22, r8
    25b4:	c5 01       	movw	r24, r10
    25b6:	b8 d8       	rcall	.-3728   	; 0x1728 <pxPortInitialiseStack>
    25b8:	f3 01       	movw	r30, r6
    25ba:	91 83       	std	Z+1, r25	; 0x01
    25bc:	80 83       	st	Z, r24
    25be:	e1 14       	cp	r14, r1
    25c0:	f1 04       	cpc	r15, r1
    25c2:	19 f0       	breq	.+6      	; 0x25ca <xTaskGenericCreate+0xf6>
    25c4:	f7 01       	movw	r30, r14
    25c6:	71 82       	std	Z+1, r7	; 0x01
    25c8:	60 82       	st	Z, r6
    25ca:	0f b6       	in	r0, 0x3f	; 63
    25cc:	f8 94       	cli
    25ce:	0f 92       	push	r0
    25d0:	80 91 74 15 	lds	r24, 0x1574	; 0x801574 <uxCurrentNumberOfTasks>
    25d4:	8f 5f       	subi	r24, 0xFF	; 255
    25d6:	80 93 74 15 	sts	0x1574, r24	; 0x801574 <uxCurrentNumberOfTasks>
    25da:	80 91 cb 15 	lds	r24, 0x15CB	; 0x8015cb <pxCurrentTCB>
    25de:	90 91 cc 15 	lds	r25, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    25e2:	89 2b       	or	r24, r25
    25e4:	b1 f5       	brne	.+108    	; 0x2652 <xTaskGenericCreate+0x17e>
    25e6:	70 92 cc 15 	sts	0x15CC, r7	; 0x8015cc <pxCurrentTCB+0x1>
    25ea:	60 92 cb 15 	sts	0x15CB, r6	; 0x8015cb <pxCurrentTCB>
    25ee:	80 91 74 15 	lds	r24, 0x1574	; 0x801574 <uxCurrentNumberOfTasks>
    25f2:	81 30       	cpi	r24, 0x01	; 1
    25f4:	09 f0       	breq	.+2      	; 0x25f8 <xTaskGenericCreate+0x124>
    25f6:	3c c0       	rjmp	.+120    	; 0x2670 <xTaskGenericCreate+0x19c>
    25f8:	87 ea       	ldi	r24, 0xA7	; 167
    25fa:	95 e1       	ldi	r25, 0x15	; 21
    25fc:	0b d8       	rcall	.-4074   	; 0x1614 <vListInitialise>
    25fe:	80 eb       	ldi	r24, 0xB0	; 176
    2600:	95 e1       	ldi	r25, 0x15	; 21
    2602:	08 d8       	rcall	.-4080   	; 0x1614 <vListInitialise>
    2604:	89 eb       	ldi	r24, 0xB9	; 185
    2606:	95 e1       	ldi	r25, 0x15	; 21
    2608:	05 d8       	rcall	.-4086   	; 0x1614 <vListInitialise>
    260a:	82 ec       	ldi	r24, 0xC2	; 194
    260c:	95 e1       	ldi	r25, 0x15	; 21
    260e:	02 d8       	rcall	.-4092   	; 0x1614 <vListInitialise>
    2610:	8e e9       	ldi	r24, 0x9E	; 158
    2612:	95 e1       	ldi	r25, 0x15	; 21
    2614:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2618:	85 e9       	ldi	r24, 0x95	; 149
    261a:	95 e1       	ldi	r25, 0x15	; 21
    261c:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2620:	88 e8       	ldi	r24, 0x88	; 136
    2622:	95 e1       	ldi	r25, 0x15	; 21
    2624:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2628:	8f e7       	ldi	r24, 0x7F	; 127
    262a:	95 e1       	ldi	r25, 0x15	; 21
    262c:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2630:	85 e7       	ldi	r24, 0x75	; 117
    2632:	95 e1       	ldi	r25, 0x15	; 21
    2634:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2638:	8e e9       	ldi	r24, 0x9E	; 158
    263a:	95 e1       	ldi	r25, 0x15	; 21
    263c:	90 93 94 15 	sts	0x1594, r25	; 0x801594 <pxDelayedTaskList+0x1>
    2640:	80 93 93 15 	sts	0x1593, r24	; 0x801593 <pxDelayedTaskList>
    2644:	85 e9       	ldi	r24, 0x95	; 149
    2646:	95 e1       	ldi	r25, 0x15	; 21
    2648:	90 93 92 15 	sts	0x1592, r25	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    264c:	80 93 91 15 	sts	0x1591, r24	; 0x801591 <pxOverflowDelayedTaskList>
    2650:	0f c0       	rjmp	.+30     	; 0x2670 <xTaskGenericCreate+0x19c>
    2652:	80 91 70 15 	lds	r24, 0x1570	; 0x801570 <xSchedulerRunning>
    2656:	81 11       	cpse	r24, r1
    2658:	0b c0       	rjmp	.+22     	; 0x2670 <xTaskGenericCreate+0x19c>
    265a:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    265e:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2662:	86 89       	ldd	r24, Z+22	; 0x16
    2664:	08 17       	cp	r16, r24
    2666:	20 f0       	brcs	.+8      	; 0x2670 <xTaskGenericCreate+0x19c>
    2668:	70 92 cc 15 	sts	0x15CC, r7	; 0x8015cc <pxCurrentTCB+0x1>
    266c:	60 92 cb 15 	sts	0x15CB, r6	; 0x8015cb <pxCurrentTCB>
    2670:	80 91 6c 15 	lds	r24, 0x156C	; 0x80156c <uxTaskNumber>
    2674:	8f 5f       	subi	r24, 0xFF	; 255
    2676:	80 93 6c 15 	sts	0x156C, r24	; 0x80156c <uxTaskNumber>
    267a:	f3 01       	movw	r30, r6
    267c:	86 89       	ldd	r24, Z+22	; 0x16
    267e:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    2682:	98 17       	cp	r25, r24
    2684:	10 f4       	brcc	.+4      	; 0x268a <xTaskGenericCreate+0x1b6>
    2686:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    268a:	90 e0       	ldi	r25, 0x00	; 0
    268c:	9c 01       	movw	r18, r24
    268e:	22 0f       	add	r18, r18
    2690:	33 1f       	adc	r19, r19
    2692:	22 0f       	add	r18, r18
    2694:	33 1f       	adc	r19, r19
    2696:	22 0f       	add	r18, r18
    2698:	33 1f       	adc	r19, r19
    269a:	82 0f       	add	r24, r18
    269c:	93 1f       	adc	r25, r19
    269e:	be 01       	movw	r22, r28
    26a0:	89 55       	subi	r24, 0x59	; 89
    26a2:	9a 4e       	sbci	r25, 0xEA	; 234
    26a4:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    26a8:	0f 90       	pop	r0
    26aa:	0f be       	out	0x3f, r0	; 63
    26ac:	80 91 70 15 	lds	r24, 0x1570	; 0x801570 <xSchedulerRunning>
    26b0:	88 23       	and	r24, r24
    26b2:	51 f0       	breq	.+20     	; 0x26c8 <xTaskGenericCreate+0x1f4>
    26b4:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    26b8:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    26bc:	86 89       	ldd	r24, Z+22	; 0x16
    26be:	80 17       	cp	r24, r16
    26c0:	28 f4       	brcc	.+10     	; 0x26cc <xTaskGenericCreate+0x1f8>
    26c2:	ed d8       	rcall	.-3622   	; 0x189e <vPortYield>
    26c4:	81 e0       	ldi	r24, 0x01	; 1
    26c6:	05 c0       	rjmp	.+10     	; 0x26d2 <xTaskGenericCreate+0x1fe>
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	03 c0       	rjmp	.+6      	; 0x26d2 <xTaskGenericCreate+0x1fe>
    26cc:	81 e0       	ldi	r24, 0x01	; 1
    26ce:	01 c0       	rjmp	.+2      	; 0x26d2 <xTaskGenericCreate+0x1fe>
    26d0:	8f ef       	ldi	r24, 0xFF	; 255
    26d2:	df 91       	pop	r29
    26d4:	cf 91       	pop	r28
    26d6:	1f 91       	pop	r17
    26d8:	0f 91       	pop	r16
    26da:	ff 90       	pop	r15
    26dc:	ef 90       	pop	r14
    26de:	df 90       	pop	r13
    26e0:	cf 90       	pop	r12
    26e2:	bf 90       	pop	r11
    26e4:	af 90       	pop	r10
    26e6:	9f 90       	pop	r9
    26e8:	8f 90       	pop	r8
    26ea:	7f 90       	pop	r7
    26ec:	6f 90       	pop	r6
    26ee:	5f 90       	pop	r5
    26f0:	4f 90       	pop	r4
    26f2:	08 95       	ret

000026f4 <vTaskDelay>:
    26f4:	9f 92       	push	r9
    26f6:	af 92       	push	r10
    26f8:	bf 92       	push	r11
    26fa:	cf 92       	push	r12
    26fc:	df 92       	push	r13
    26fe:	ef 92       	push	r14
    2700:	ff 92       	push	r15
    2702:	0f 93       	push	r16
    2704:	1f 93       	push	r17
    2706:	cf 93       	push	r28
    2708:	df 93       	push	r29
    270a:	00 97       	sbiw	r24, 0x00	; 0
    270c:	09 f4       	brne	.+2      	; 0x2710 <vTaskDelay+0x1c>
    270e:	7e c1       	rjmp	.+764    	; 0x2a0c <vTaskDelay+0x318>
    2710:	20 91 69 15 	lds	r18, 0x1569	; 0x801569 <uxSchedulerSuspended>
    2714:	2f 5f       	subi	r18, 0xFF	; 255
    2716:	20 93 69 15 	sts	0x1569, r18	; 0x801569 <uxSchedulerSuspended>
    271a:	c0 91 72 15 	lds	r28, 0x1572	; 0x801572 <xTickCount>
    271e:	d0 91 73 15 	lds	r29, 0x1573	; 0x801573 <xTickCount+0x1>
    2722:	c8 0f       	add	r28, r24
    2724:	d9 1f       	adc	r29, r25
    2726:	80 91 cb 15 	lds	r24, 0x15CB	; 0x8015cb <pxCurrentTCB>
    272a:	90 91 cc 15 	lds	r25, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    272e:	02 96       	adiw	r24, 0x02	; 2
    2730:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    2734:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2738:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    273c:	d3 83       	std	Z+3, r29	; 0x03
    273e:	c2 83       	std	Z+2, r28	; 0x02
    2740:	80 91 72 15 	lds	r24, 0x1572	; 0x801572 <xTickCount>
    2744:	90 91 73 15 	lds	r25, 0x1573	; 0x801573 <xTickCount+0x1>
    2748:	c8 17       	cp	r28, r24
    274a:	d9 07       	cpc	r29, r25
    274c:	68 f4       	brcc	.+26     	; 0x2768 <vTaskDelay+0x74>
    274e:	60 91 cb 15 	lds	r22, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2752:	70 91 cc 15 	lds	r23, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2756:	80 91 91 15 	lds	r24, 0x1591	; 0x801591 <pxOverflowDelayedTaskList>
    275a:	90 91 92 15 	lds	r25, 0x1592	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    275e:	6e 5f       	subi	r22, 0xFE	; 254
    2760:	7f 4f       	sbci	r23, 0xFF	; 255
    2762:	0e 94 3d 0b 	call	0x167a	; 0x167a <vListInsert>
    2766:	17 c0       	rjmp	.+46     	; 0x2796 <vTaskDelay+0xa2>
    2768:	60 91 cb 15 	lds	r22, 0x15CB	; 0x8015cb <pxCurrentTCB>
    276c:	70 91 cc 15 	lds	r23, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2770:	80 91 93 15 	lds	r24, 0x1593	; 0x801593 <pxDelayedTaskList>
    2774:	90 91 94 15 	lds	r25, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2778:	6e 5f       	subi	r22, 0xFE	; 254
    277a:	7f 4f       	sbci	r23, 0xFF	; 255
    277c:	0e 94 3d 0b 	call	0x167a	; 0x167a <vListInsert>
    2780:	80 91 6a 15 	lds	r24, 0x156A	; 0x80156a <xNextTaskUnblockTime>
    2784:	90 91 6b 15 	lds	r25, 0x156B	; 0x80156b <xNextTaskUnblockTime+0x1>
    2788:	c8 17       	cp	r28, r24
    278a:	d9 07       	cpc	r29, r25
    278c:	20 f4       	brcc	.+8      	; 0x2796 <vTaskDelay+0xa2>
    278e:	d0 93 6b 15 	sts	0x156B, r29	; 0x80156b <xNextTaskUnblockTime+0x1>
    2792:	c0 93 6a 15 	sts	0x156A, r28	; 0x80156a <xNextTaskUnblockTime>
    2796:	0f b6       	in	r0, 0x3f	; 63
    2798:	f8 94       	cli
    279a:	0f 92       	push	r0
    279c:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    27a0:	81 50       	subi	r24, 0x01	; 1
    27a2:	80 93 69 15 	sts	0x1569, r24	; 0x801569 <uxSchedulerSuspended>
    27a6:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    27aa:	81 11       	cpse	r24, r1
    27ac:	28 c1       	rjmp	.+592    	; 0x29fe <vTaskDelay+0x30a>
    27ae:	80 91 74 15 	lds	r24, 0x1574	; 0x801574 <uxCurrentNumberOfTasks>
    27b2:	81 11       	cpse	r24, r1
    27b4:	33 c0       	rjmp	.+102    	; 0x281c <vTaskDelay+0x128>
    27b6:	26 c1       	rjmp	.+588    	; 0x2a04 <vTaskDelay+0x310>
    27b8:	d7 01       	movw	r26, r14
    27ba:	15 96       	adiw	r26, 0x05	; 5
    27bc:	ed 91       	ld	r30, X+
    27be:	fc 91       	ld	r31, X
    27c0:	16 97       	sbiw	r26, 0x06	; 6
    27c2:	c6 81       	ldd	r28, Z+6	; 0x06
    27c4:	d7 81       	ldd	r29, Z+7	; 0x07
    27c6:	ce 01       	movw	r24, r28
    27c8:	0c 96       	adiw	r24, 0x0c	; 12
    27ca:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    27ce:	8e 01       	movw	r16, r28
    27d0:	0e 5f       	subi	r16, 0xFE	; 254
    27d2:	1f 4f       	sbci	r17, 0xFF	; 255
    27d4:	c8 01       	movw	r24, r16
    27d6:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    27da:	8e 89       	ldd	r24, Y+22	; 0x16
    27dc:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    27e0:	98 17       	cp	r25, r24
    27e2:	10 f4       	brcc	.+4      	; 0x27e8 <vTaskDelay+0xf4>
    27e4:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    27e8:	90 e0       	ldi	r25, 0x00	; 0
    27ea:	9c 01       	movw	r18, r24
    27ec:	22 0f       	add	r18, r18
    27ee:	33 1f       	adc	r19, r19
    27f0:	22 0f       	add	r18, r18
    27f2:	33 1f       	adc	r19, r19
    27f4:	22 0f       	add	r18, r18
    27f6:	33 1f       	adc	r19, r19
    27f8:	82 0f       	add	r24, r18
    27fa:	93 1f       	adc	r25, r19
    27fc:	b8 01       	movw	r22, r16
    27fe:	89 55       	subi	r24, 0x59	; 89
    2800:	9a 4e       	sbci	r25, 0xEA	; 234
    2802:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    2806:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    280a:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    280e:	9e 89       	ldd	r25, Y+22	; 0x16
    2810:	86 89       	ldd	r24, Z+22	; 0x16
    2812:	98 17       	cp	r25, r24
    2814:	58 f0       	brcs	.+22     	; 0x282c <vTaskDelay+0x138>
    2816:	d0 92 6e 15 	sts	0x156E, r13	; 0x80156e <xYieldPending>
    281a:	08 c0       	rjmp	.+16     	; 0x282c <vTaskDelay+0x138>
    281c:	0f 2e       	mov	r0, r31
    281e:	f8 e8       	ldi	r31, 0x88	; 136
    2820:	ef 2e       	mov	r14, r31
    2822:	f5 e1       	ldi	r31, 0x15	; 21
    2824:	ff 2e       	mov	r15, r31
    2826:	f0 2d       	mov	r31, r0
    2828:	dd 24       	eor	r13, r13
    282a:	d3 94       	inc	r13
    282c:	f7 01       	movw	r30, r14
    282e:	80 81       	ld	r24, Z
    2830:	81 11       	cpse	r24, r1
    2832:	c2 cf       	rjmp	.-124    	; 0x27b8 <vTaskDelay+0xc4>
    2834:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    2838:	88 23       	and	r24, r24
    283a:	09 f4       	brne	.+2      	; 0x283e <vTaskDelay+0x14a>
    283c:	d8 c0       	rjmp	.+432    	; 0x29ee <vTaskDelay+0x2fa>
    283e:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    2842:	88 23       	and	r24, r24
    2844:	09 f4       	brne	.+2      	; 0x2848 <vTaskDelay+0x154>
    2846:	d3 c0       	rjmp	.+422    	; 0x29ee <vTaskDelay+0x2fa>
    2848:	91 2c       	mov	r9, r1
    284a:	bb 24       	eor	r11, r11
    284c:	b3 94       	inc	r11
    284e:	cc 24       	eor	r12, r12
    2850:	ca 94       	dec	r12
    2852:	dc 2c       	mov	r13, r12
    2854:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    2858:	81 11       	cpse	r24, r1
    285a:	af c0       	rjmp	.+350    	; 0x29ba <vTaskDelay+0x2c6>
    285c:	80 91 72 15 	lds	r24, 0x1572	; 0x801572 <xTickCount>
    2860:	90 91 73 15 	lds	r25, 0x1573	; 0x801573 <xTickCount+0x1>
    2864:	01 96       	adiw	r24, 0x01	; 1
    2866:	90 93 73 15 	sts	0x1573, r25	; 0x801573 <xTickCount+0x1>
    286a:	80 93 72 15 	sts	0x1572, r24	; 0x801572 <xTickCount>
    286e:	e0 90 72 15 	lds	r14, 0x1572	; 0x801572 <xTickCount>
    2872:	f0 90 73 15 	lds	r15, 0x1573	; 0x801573 <xTickCount+0x1>
    2876:	e1 14       	cp	r14, r1
    2878:	f1 04       	cpc	r15, r1
    287a:	89 f5       	brne	.+98     	; 0x28de <vTaskDelay+0x1ea>
    287c:	80 91 93 15 	lds	r24, 0x1593	; 0x801593 <pxDelayedTaskList>
    2880:	90 91 94 15 	lds	r25, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2884:	20 91 91 15 	lds	r18, 0x1591	; 0x801591 <pxOverflowDelayedTaskList>
    2888:	30 91 92 15 	lds	r19, 0x1592	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    288c:	30 93 94 15 	sts	0x1594, r19	; 0x801594 <pxDelayedTaskList+0x1>
    2890:	20 93 93 15 	sts	0x1593, r18	; 0x801593 <pxDelayedTaskList>
    2894:	90 93 92 15 	sts	0x1592, r25	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    2898:	80 93 91 15 	sts	0x1591, r24	; 0x801591 <pxOverflowDelayedTaskList>
    289c:	80 91 6d 15 	lds	r24, 0x156D	; 0x80156d <xNumOfOverflows>
    28a0:	8f 5f       	subi	r24, 0xFF	; 255
    28a2:	80 93 6d 15 	sts	0x156D, r24	; 0x80156d <xNumOfOverflows>
    28a6:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    28aa:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    28ae:	80 81       	ld	r24, Z
    28b0:	81 11       	cpse	r24, r1
    28b2:	05 c0       	rjmp	.+10     	; 0x28be <vTaskDelay+0x1ca>
    28b4:	d0 92 6b 15 	sts	0x156B, r13	; 0x80156b <xNextTaskUnblockTime+0x1>
    28b8:	c0 92 6a 15 	sts	0x156A, r12	; 0x80156a <xNextTaskUnblockTime>
    28bc:	10 c0       	rjmp	.+32     	; 0x28de <vTaskDelay+0x1ea>
    28be:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    28c2:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    28c6:	05 80       	ldd	r0, Z+5	; 0x05
    28c8:	f6 81       	ldd	r31, Z+6	; 0x06
    28ca:	e0 2d       	mov	r30, r0
    28cc:	06 80       	ldd	r0, Z+6	; 0x06
    28ce:	f7 81       	ldd	r31, Z+7	; 0x07
    28d0:	e0 2d       	mov	r30, r0
    28d2:	82 81       	ldd	r24, Z+2	; 0x02
    28d4:	93 81       	ldd	r25, Z+3	; 0x03
    28d6:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    28da:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    28de:	80 91 6a 15 	lds	r24, 0x156A	; 0x80156a <xNextTaskUnblockTime>
    28e2:	90 91 6b 15 	lds	r25, 0x156B	; 0x80156b <xNextTaskUnblockTime+0x1>
    28e6:	e8 16       	cp	r14, r24
    28e8:	f9 06       	cpc	r15, r25
    28ea:	10 f4       	brcc	.+4      	; 0x28f0 <vTaskDelay+0x1fc>
    28ec:	a9 2c       	mov	r10, r9
    28ee:	4f c0       	rjmp	.+158    	; 0x298e <vTaskDelay+0x29a>
    28f0:	a9 2c       	mov	r10, r9
    28f2:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    28f6:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    28fa:	80 81       	ld	r24, Z
    28fc:	81 11       	cpse	r24, r1
    28fe:	05 c0       	rjmp	.+10     	; 0x290a <vTaskDelay+0x216>
    2900:	d0 92 6b 15 	sts	0x156B, r13	; 0x80156b <xNextTaskUnblockTime+0x1>
    2904:	c0 92 6a 15 	sts	0x156A, r12	; 0x80156a <xNextTaskUnblockTime>
    2908:	42 c0       	rjmp	.+132    	; 0x298e <vTaskDelay+0x29a>
    290a:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    290e:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2912:	05 80       	ldd	r0, Z+5	; 0x05
    2914:	f6 81       	ldd	r31, Z+6	; 0x06
    2916:	e0 2d       	mov	r30, r0
    2918:	c6 81       	ldd	r28, Z+6	; 0x06
    291a:	d7 81       	ldd	r29, Z+7	; 0x07
    291c:	8a 81       	ldd	r24, Y+2	; 0x02
    291e:	9b 81       	ldd	r25, Y+3	; 0x03
    2920:	e8 16       	cp	r14, r24
    2922:	f9 06       	cpc	r15, r25
    2924:	28 f4       	brcc	.+10     	; 0x2930 <vTaskDelay+0x23c>
    2926:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    292a:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    292e:	2f c0       	rjmp	.+94     	; 0x298e <vTaskDelay+0x29a>
    2930:	8e 01       	movw	r16, r28
    2932:	0e 5f       	subi	r16, 0xFE	; 254
    2934:	1f 4f       	sbci	r17, 0xFF	; 255
    2936:	c8 01       	movw	r24, r16
    2938:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    293c:	8c 89       	ldd	r24, Y+20	; 0x14
    293e:	9d 89       	ldd	r25, Y+21	; 0x15
    2940:	89 2b       	or	r24, r25
    2942:	21 f0       	breq	.+8      	; 0x294c <vTaskDelay+0x258>
    2944:	ce 01       	movw	r24, r28
    2946:	0c 96       	adiw	r24, 0x0c	; 12
    2948:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    294c:	8e 89       	ldd	r24, Y+22	; 0x16
    294e:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    2952:	98 17       	cp	r25, r24
    2954:	10 f4       	brcc	.+4      	; 0x295a <vTaskDelay+0x266>
    2956:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    295a:	90 e0       	ldi	r25, 0x00	; 0
    295c:	9c 01       	movw	r18, r24
    295e:	22 0f       	add	r18, r18
    2960:	33 1f       	adc	r19, r19
    2962:	22 0f       	add	r18, r18
    2964:	33 1f       	adc	r19, r19
    2966:	22 0f       	add	r18, r18
    2968:	33 1f       	adc	r19, r19
    296a:	82 0f       	add	r24, r18
    296c:	93 1f       	adc	r25, r19
    296e:	b8 01       	movw	r22, r16
    2970:	89 55       	subi	r24, 0x59	; 89
    2972:	9a 4e       	sbci	r25, 0xEA	; 234
    2974:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    2978:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    297c:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2980:	9e 89       	ldd	r25, Y+22	; 0x16
    2982:	86 89       	ldd	r24, Z+22	; 0x16
    2984:	98 17       	cp	r25, r24
    2986:	08 f4       	brcc	.+2      	; 0x298a <vTaskDelay+0x296>
    2988:	b4 cf       	rjmp	.-152    	; 0x28f2 <vTaskDelay+0x1fe>
    298a:	ab 2c       	mov	r10, r11
    298c:	b2 cf       	rjmp	.-156    	; 0x28f2 <vTaskDelay+0x1fe>
    298e:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2992:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2996:	86 89       	ldd	r24, Z+22	; 0x16
    2998:	90 e0       	ldi	r25, 0x00	; 0
    299a:	fc 01       	movw	r30, r24
    299c:	ee 0f       	add	r30, r30
    299e:	ff 1f       	adc	r31, r31
    29a0:	ee 0f       	add	r30, r30
    29a2:	ff 1f       	adc	r31, r31
    29a4:	ee 0f       	add	r30, r30
    29a6:	ff 1f       	adc	r31, r31
    29a8:	8e 0f       	add	r24, r30
    29aa:	9f 1f       	adc	r25, r31
    29ac:	fc 01       	movw	r30, r24
    29ae:	e9 55       	subi	r30, 0x59	; 89
    29b0:	fa 4e       	sbci	r31, 0xEA	; 234
    29b2:	80 81       	ld	r24, Z
    29b4:	82 30       	cpi	r24, 0x02	; 2
    29b6:	68 f5       	brcc	.+90     	; 0x2a12 <vTaskDelay+0x31e>
    29b8:	0a c0       	rjmp	.+20     	; 0x29ce <vTaskDelay+0x2da>
    29ba:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    29be:	8f 5f       	subi	r24, 0xFF	; 255
    29c0:	80 93 6f 15 	sts	0x156F, r24	; 0x80156f <uxPendedTicks>
    29c4:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    29c8:	88 23       	and	r24, r24
    29ca:	41 f0       	breq	.+16     	; 0x29dc <vTaskDelay+0x2e8>
    29cc:	05 c0       	rjmp	.+10     	; 0x29d8 <vTaskDelay+0x2e4>
    29ce:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    29d2:	81 11       	cpse	r24, r1
    29d4:	01 c0       	rjmp	.+2      	; 0x29d8 <vTaskDelay+0x2e4>
    29d6:	a1 10       	cpse	r10, r1
    29d8:	b0 92 6e 15 	sts	0x156E, r11	; 0x80156e <xYieldPending>
    29dc:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    29e0:	81 50       	subi	r24, 0x01	; 1
    29e2:	80 93 6f 15 	sts	0x156F, r24	; 0x80156f <uxPendedTicks>
    29e6:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    29ea:	81 11       	cpse	r24, r1
    29ec:	33 cf       	rjmp	.-410    	; 0x2854 <vTaskDelay+0x160>
    29ee:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    29f2:	81 30       	cpi	r24, 0x01	; 1
    29f4:	31 f4       	brne	.+12     	; 0x2a02 <vTaskDelay+0x30e>
    29f6:	0e 94 4f 0c 	call	0x189e	; 0x189e <vPortYield>
    29fa:	81 e0       	ldi	r24, 0x01	; 1
    29fc:	03 c0       	rjmp	.+6      	; 0x2a04 <vTaskDelay+0x310>
    29fe:	80 e0       	ldi	r24, 0x00	; 0
    2a00:	01 c0       	rjmp	.+2      	; 0x2a04 <vTaskDelay+0x310>
    2a02:	80 e0       	ldi	r24, 0x00	; 0
    2a04:	0f 90       	pop	r0
    2a06:	0f be       	out	0x3f, r0	; 63
    2a08:	81 11       	cpse	r24, r1
    2a0a:	06 c0       	rjmp	.+12     	; 0x2a18 <vTaskDelay+0x324>
    2a0c:	0e 94 4f 0c 	call	0x189e	; 0x189e <vPortYield>
    2a10:	03 c0       	rjmp	.+6      	; 0x2a18 <vTaskDelay+0x324>
    2a12:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    2a16:	e0 cf       	rjmp	.-64     	; 0x29d8 <vTaskDelay+0x2e4>
    2a18:	df 91       	pop	r29
    2a1a:	cf 91       	pop	r28
    2a1c:	1f 91       	pop	r17
    2a1e:	0f 91       	pop	r16
    2a20:	ff 90       	pop	r15
    2a22:	ef 90       	pop	r14
    2a24:	df 90       	pop	r13
    2a26:	cf 90       	pop	r12
    2a28:	bf 90       	pop	r11
    2a2a:	af 90       	pop	r10
    2a2c:	9f 90       	pop	r9
    2a2e:	08 95       	ret

00002a30 <vTaskStartScheduler>:
    2a30:	ef 92       	push	r14
    2a32:	ff 92       	push	r15
    2a34:	0f 93       	push	r16
    2a36:	1f 93       	push	r17
    2a38:	cf 93       	push	r28
    2a3a:	df 93       	push	r29
    2a3c:	84 e6       	ldi	r24, 0x64	; 100
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
    2a40:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <pvPortMalloc>
    2a44:	8c 01       	movw	r16, r24
    2a46:	89 2b       	or	r24, r25
    2a48:	09 f4       	brne	.+2      	; 0x2a4c <vTaskStartScheduler+0x1c>
    2a4a:	d9 c0       	rjmp	.+434    	; 0x2bfe <vTaskStartScheduler+0x1ce>
    2a4c:	88 e2       	ldi	r24, 0x28	; 40
    2a4e:	90 e0       	ldi	r25, 0x00	; 0
    2a50:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <pvPortMalloc>
    2a54:	ec 01       	movw	r28, r24
    2a56:	89 2b       	or	r24, r25
    2a58:	b1 f0       	breq	.+44     	; 0x2a86 <vTaskStartScheduler+0x56>
    2a5a:	18 8f       	std	Y+24, r17	; 0x18
    2a5c:	0f 8b       	std	Y+23, r16	; 0x17
    2a5e:	44 e6       	ldi	r20, 0x64	; 100
    2a60:	50 e0       	ldi	r21, 0x00	; 0
    2a62:	65 ea       	ldi	r22, 0xA5	; 165
    2a64:	70 e0       	ldi	r23, 0x00	; 0
    2a66:	c8 01       	movw	r24, r16
    2a68:	0e 94 e7 21 	call	0x43ce	; 0x43ce <memset>
    2a6c:	0f 89       	ldd	r16, Y+23	; 0x17
    2a6e:	18 8d       	ldd	r17, Y+24	; 0x18
    2a70:	0d 59       	subi	r16, 0x9D	; 157
    2a72:	1f 4f       	sbci	r17, 0xFF	; 255
    2a74:	89 e4       	ldi	r24, 0x49	; 73
    2a76:	89 8f       	std	Y+25, r24	; 0x19
    2a78:	ee e2       	ldi	r30, 0x2E	; 46
    2a7a:	f3 e0       	ldi	r31, 0x03	; 3
    2a7c:	de 01       	movw	r26, r28
    2a7e:	5a 96       	adiw	r26, 0x1a	; 26
    2a80:	25 e3       	ldi	r18, 0x35	; 53
    2a82:	33 e0       	ldi	r19, 0x03	; 3
    2a84:	04 c0       	rjmp	.+8      	; 0x2a8e <vTaskStartScheduler+0x5e>
    2a86:	c8 01       	movw	r24, r16
    2a88:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortFree>
    2a8c:	b8 c0       	rjmp	.+368    	; 0x2bfe <vTaskStartScheduler+0x1ce>
    2a8e:	81 91       	ld	r24, Z+
    2a90:	8d 93       	st	X+, r24
    2a92:	88 23       	and	r24, r24
    2a94:	19 f0       	breq	.+6      	; 0x2a9c <vTaskStartScheduler+0x6c>
    2a96:	e2 17       	cp	r30, r18
    2a98:	f3 07       	cpc	r31, r19
    2a9a:	c9 f7       	brne	.-14     	; 0x2a8e <vTaskStartScheduler+0x5e>
    2a9c:	18 a2       	std	Y+32, r1	; 0x20
    2a9e:	1e 8a       	std	Y+22, r1	; 0x16
    2aa0:	19 a2       	std	Y+33, r1	; 0x21
    2aa2:	1a a2       	std	Y+34, r1	; 0x22
    2aa4:	7e 01       	movw	r14, r28
    2aa6:	82 e0       	ldi	r24, 0x02	; 2
    2aa8:	e8 0e       	add	r14, r24
    2aaa:	f1 1c       	adc	r15, r1
    2aac:	c7 01       	movw	r24, r14
    2aae:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListInitialiseItem>
    2ab2:	ce 01       	movw	r24, r28
    2ab4:	0c 96       	adiw	r24, 0x0c	; 12
    2ab6:	0e 94 18 0b 	call	0x1630	; 0x1630 <vListInitialiseItem>
    2aba:	d9 87       	std	Y+9, r29	; 0x09
    2abc:	c8 87       	std	Y+8, r28	; 0x08
    2abe:	84 e0       	ldi	r24, 0x04	; 4
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	9d 87       	std	Y+13, r25	; 0x0d
    2ac4:	8c 87       	std	Y+12, r24	; 0x0c
    2ac6:	db 8b       	std	Y+19, r29	; 0x13
    2ac8:	ca 8b       	std	Y+18, r28	; 0x12
    2aca:	1b a2       	std	Y+35, r1	; 0x23
    2acc:	1c a2       	std	Y+36, r1	; 0x24
    2ace:	1d a2       	std	Y+37, r1	; 0x25
    2ad0:	1e a2       	std	Y+38, r1	; 0x26
    2ad2:	1f a2       	std	Y+39, r1	; 0x27
    2ad4:	40 e0       	ldi	r20, 0x00	; 0
    2ad6:	50 e0       	ldi	r21, 0x00	; 0
    2ad8:	62 e8       	ldi	r22, 0x82	; 130
    2ada:	70 e0       	ldi	r23, 0x00	; 0
    2adc:	c8 01       	movw	r24, r16
    2ade:	0e 94 94 0b 	call	0x1728	; 0x1728 <pxPortInitialiseStack>
    2ae2:	99 83       	std	Y+1, r25	; 0x01
    2ae4:	88 83       	st	Y, r24
    2ae6:	0f b6       	in	r0, 0x3f	; 63
    2ae8:	f8 94       	cli
    2aea:	0f 92       	push	r0
    2aec:	80 91 74 15 	lds	r24, 0x1574	; 0x801574 <uxCurrentNumberOfTasks>
    2af0:	8f 5f       	subi	r24, 0xFF	; 255
    2af2:	80 93 74 15 	sts	0x1574, r24	; 0x801574 <uxCurrentNumberOfTasks>
    2af6:	80 91 cb 15 	lds	r24, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2afa:	90 91 cc 15 	lds	r25, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2afe:	89 2b       	or	r24, r25
    2b00:	d1 f5       	brne	.+116    	; 0x2b76 <vTaskStartScheduler+0x146>
    2b02:	d0 93 cc 15 	sts	0x15CC, r29	; 0x8015cc <pxCurrentTCB+0x1>
    2b06:	c0 93 cb 15 	sts	0x15CB, r28	; 0x8015cb <pxCurrentTCB>
    2b0a:	80 91 74 15 	lds	r24, 0x1574	; 0x801574 <uxCurrentNumberOfTasks>
    2b0e:	81 30       	cpi	r24, 0x01	; 1
    2b10:	09 f0       	breq	.+2      	; 0x2b14 <vTaskStartScheduler+0xe4>
    2b12:	40 c0       	rjmp	.+128    	; 0x2b94 <vTaskStartScheduler+0x164>
    2b14:	87 ea       	ldi	r24, 0xA7	; 167
    2b16:	95 e1       	ldi	r25, 0x15	; 21
    2b18:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b1c:	80 eb       	ldi	r24, 0xB0	; 176
    2b1e:	95 e1       	ldi	r25, 0x15	; 21
    2b20:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b24:	89 eb       	ldi	r24, 0xB9	; 185
    2b26:	95 e1       	ldi	r25, 0x15	; 21
    2b28:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b2c:	82 ec       	ldi	r24, 0xC2	; 194
    2b2e:	95 e1       	ldi	r25, 0x15	; 21
    2b30:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b34:	8e e9       	ldi	r24, 0x9E	; 158
    2b36:	95 e1       	ldi	r25, 0x15	; 21
    2b38:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b3c:	85 e9       	ldi	r24, 0x95	; 149
    2b3e:	95 e1       	ldi	r25, 0x15	; 21
    2b40:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b44:	88 e8       	ldi	r24, 0x88	; 136
    2b46:	95 e1       	ldi	r25, 0x15	; 21
    2b48:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b4c:	8f e7       	ldi	r24, 0x7F	; 127
    2b4e:	95 e1       	ldi	r25, 0x15	; 21
    2b50:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b54:	85 e7       	ldi	r24, 0x75	; 117
    2b56:	95 e1       	ldi	r25, 0x15	; 21
    2b58:	0e 94 0a 0b 	call	0x1614	; 0x1614 <vListInitialise>
    2b5c:	8e e9       	ldi	r24, 0x9E	; 158
    2b5e:	95 e1       	ldi	r25, 0x15	; 21
    2b60:	90 93 94 15 	sts	0x1594, r25	; 0x801594 <pxDelayedTaskList+0x1>
    2b64:	80 93 93 15 	sts	0x1593, r24	; 0x801593 <pxDelayedTaskList>
    2b68:	85 e9       	ldi	r24, 0x95	; 149
    2b6a:	95 e1       	ldi	r25, 0x15	; 21
    2b6c:	90 93 92 15 	sts	0x1592, r25	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    2b70:	80 93 91 15 	sts	0x1591, r24	; 0x801591 <pxOverflowDelayedTaskList>
    2b74:	0f c0       	rjmp	.+30     	; 0x2b94 <vTaskStartScheduler+0x164>
    2b76:	80 91 70 15 	lds	r24, 0x1570	; 0x801570 <xSchedulerRunning>
    2b7a:	81 11       	cpse	r24, r1
    2b7c:	0b c0       	rjmp	.+22     	; 0x2b94 <vTaskStartScheduler+0x164>
    2b7e:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2b82:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2b86:	86 89       	ldd	r24, Z+22	; 0x16
    2b88:	81 11       	cpse	r24, r1
    2b8a:	04 c0       	rjmp	.+8      	; 0x2b94 <vTaskStartScheduler+0x164>
    2b8c:	d0 93 cc 15 	sts	0x15CC, r29	; 0x8015cc <pxCurrentTCB+0x1>
    2b90:	c0 93 cb 15 	sts	0x15CB, r28	; 0x8015cb <pxCurrentTCB>
    2b94:	80 91 6c 15 	lds	r24, 0x156C	; 0x80156c <uxTaskNumber>
    2b98:	8f 5f       	subi	r24, 0xFF	; 255
    2b9a:	80 93 6c 15 	sts	0x156C, r24	; 0x80156c <uxTaskNumber>
    2b9e:	8e 89       	ldd	r24, Y+22	; 0x16
    2ba0:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    2ba4:	98 17       	cp	r25, r24
    2ba6:	10 f4       	brcc	.+4      	; 0x2bac <vTaskStartScheduler+0x17c>
    2ba8:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    2bac:	90 e0       	ldi	r25, 0x00	; 0
    2bae:	9c 01       	movw	r18, r24
    2bb0:	22 0f       	add	r18, r18
    2bb2:	33 1f       	adc	r19, r19
    2bb4:	22 0f       	add	r18, r18
    2bb6:	33 1f       	adc	r19, r19
    2bb8:	22 0f       	add	r18, r18
    2bba:	33 1f       	adc	r19, r19
    2bbc:	82 0f       	add	r24, r18
    2bbe:	93 1f       	adc	r25, r19
    2bc0:	b7 01       	movw	r22, r14
    2bc2:	89 55       	subi	r24, 0x59	; 89
    2bc4:	9a 4e       	sbci	r25, 0xEA	; 234
    2bc6:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    2bca:	0f 90       	pop	r0
    2bcc:	0f be       	out	0x3f, r0	; 63
    2bce:	80 91 70 15 	lds	r24, 0x1570	; 0x801570 <xSchedulerRunning>
    2bd2:	88 23       	and	r24, r24
    2bd4:	21 f0       	breq	.+8      	; 0x2bde <vTaskStartScheduler+0x1ae>
    2bd6:	80 91 cb 15 	lds	r24, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2bda:	90 91 cc 15 	lds	r25, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2bde:	f8 94       	cli
    2be0:	8f ef       	ldi	r24, 0xFF	; 255
    2be2:	9f ef       	ldi	r25, 0xFF	; 255
    2be4:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    2be8:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    2bec:	81 e0       	ldi	r24, 0x01	; 1
    2bee:	80 93 70 15 	sts	0x1570, r24	; 0x801570 <xSchedulerRunning>
    2bf2:	10 92 73 15 	sts	0x1573, r1	; 0x801573 <xTickCount+0x1>
    2bf6:	10 92 72 15 	sts	0x1572, r1	; 0x801572 <xTickCount>
    2bfa:	0e 94 06 0c 	call	0x180c	; 0x180c <xPortStartScheduler>
    2bfe:	df 91       	pop	r29
    2c00:	cf 91       	pop	r28
    2c02:	1f 91       	pop	r17
    2c04:	0f 91       	pop	r16
    2c06:	ff 90       	pop	r15
    2c08:	ef 90       	pop	r14
    2c0a:	08 95       	ret

00002c0c <vTaskSuspendAll>:
    2c0c:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    2c10:	8f 5f       	subi	r24, 0xFF	; 255
    2c12:	80 93 69 15 	sts	0x1569, r24	; 0x801569 <uxSchedulerSuspended>
    2c16:	08 95       	ret

00002c18 <xTaskResumeAll>:
    2c18:	9f 92       	push	r9
    2c1a:	af 92       	push	r10
    2c1c:	bf 92       	push	r11
    2c1e:	cf 92       	push	r12
    2c20:	df 92       	push	r13
    2c22:	ef 92       	push	r14
    2c24:	ff 92       	push	r15
    2c26:	0f 93       	push	r16
    2c28:	1f 93       	push	r17
    2c2a:	cf 93       	push	r28
    2c2c:	df 93       	push	r29
    2c2e:	0f b6       	in	r0, 0x3f	; 63
    2c30:	f8 94       	cli
    2c32:	0f 92       	push	r0
    2c34:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    2c38:	81 50       	subi	r24, 0x01	; 1
    2c3a:	80 93 69 15 	sts	0x1569, r24	; 0x801569 <uxSchedulerSuspended>
    2c3e:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    2c42:	81 11       	cpse	r24, r1
    2c44:	28 c1       	rjmp	.+592    	; 0x2e96 <xTaskResumeAll+0x27e>
    2c46:	80 91 74 15 	lds	r24, 0x1574	; 0x801574 <uxCurrentNumberOfTasks>
    2c4a:	81 11       	cpse	r24, r1
    2c4c:	33 c0       	rjmp	.+102    	; 0x2cb4 <xTaskResumeAll+0x9c>
    2c4e:	26 c1       	rjmp	.+588    	; 0x2e9c <xTaskResumeAll+0x284>
    2c50:	d7 01       	movw	r26, r14
    2c52:	15 96       	adiw	r26, 0x05	; 5
    2c54:	ed 91       	ld	r30, X+
    2c56:	fc 91       	ld	r31, X
    2c58:	16 97       	sbiw	r26, 0x06	; 6
    2c5a:	c6 81       	ldd	r28, Z+6	; 0x06
    2c5c:	d7 81       	ldd	r29, Z+7	; 0x07
    2c5e:	ce 01       	movw	r24, r28
    2c60:	0c 96       	adiw	r24, 0x0c	; 12
    2c62:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    2c66:	8e 01       	movw	r16, r28
    2c68:	0e 5f       	subi	r16, 0xFE	; 254
    2c6a:	1f 4f       	sbci	r17, 0xFF	; 255
    2c6c:	c8 01       	movw	r24, r16
    2c6e:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    2c72:	8e 89       	ldd	r24, Y+22	; 0x16
    2c74:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    2c78:	98 17       	cp	r25, r24
    2c7a:	10 f4       	brcc	.+4      	; 0x2c80 <xTaskResumeAll+0x68>
    2c7c:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    2c80:	90 e0       	ldi	r25, 0x00	; 0
    2c82:	9c 01       	movw	r18, r24
    2c84:	22 0f       	add	r18, r18
    2c86:	33 1f       	adc	r19, r19
    2c88:	22 0f       	add	r18, r18
    2c8a:	33 1f       	adc	r19, r19
    2c8c:	22 0f       	add	r18, r18
    2c8e:	33 1f       	adc	r19, r19
    2c90:	82 0f       	add	r24, r18
    2c92:	93 1f       	adc	r25, r19
    2c94:	b8 01       	movw	r22, r16
    2c96:	89 55       	subi	r24, 0x59	; 89
    2c98:	9a 4e       	sbci	r25, 0xEA	; 234
    2c9a:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    2c9e:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2ca2:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2ca6:	9e 89       	ldd	r25, Y+22	; 0x16
    2ca8:	86 89       	ldd	r24, Z+22	; 0x16
    2caa:	98 17       	cp	r25, r24
    2cac:	58 f0       	brcs	.+22     	; 0x2cc4 <xTaskResumeAll+0xac>
    2cae:	d0 92 6e 15 	sts	0x156E, r13	; 0x80156e <xYieldPending>
    2cb2:	08 c0       	rjmp	.+16     	; 0x2cc4 <xTaskResumeAll+0xac>
    2cb4:	0f 2e       	mov	r0, r31
    2cb6:	f8 e8       	ldi	r31, 0x88	; 136
    2cb8:	ef 2e       	mov	r14, r31
    2cba:	f5 e1       	ldi	r31, 0x15	; 21
    2cbc:	ff 2e       	mov	r15, r31
    2cbe:	f0 2d       	mov	r31, r0
    2cc0:	dd 24       	eor	r13, r13
    2cc2:	d3 94       	inc	r13
    2cc4:	f7 01       	movw	r30, r14
    2cc6:	80 81       	ld	r24, Z
    2cc8:	81 11       	cpse	r24, r1
    2cca:	c2 cf       	rjmp	.-124    	; 0x2c50 <xTaskResumeAll+0x38>
    2ccc:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    2cd0:	88 23       	and	r24, r24
    2cd2:	09 f4       	brne	.+2      	; 0x2cd6 <xTaskResumeAll+0xbe>
    2cd4:	d8 c0       	rjmp	.+432    	; 0x2e86 <xTaskResumeAll+0x26e>
    2cd6:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    2cda:	88 23       	and	r24, r24
    2cdc:	09 f4       	brne	.+2      	; 0x2ce0 <xTaskResumeAll+0xc8>
    2cde:	d3 c0       	rjmp	.+422    	; 0x2e86 <xTaskResumeAll+0x26e>
    2ce0:	91 2c       	mov	r9, r1
    2ce2:	bb 24       	eor	r11, r11
    2ce4:	b3 94       	inc	r11
    2ce6:	cc 24       	eor	r12, r12
    2ce8:	ca 94       	dec	r12
    2cea:	dc 2c       	mov	r13, r12
    2cec:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    2cf0:	81 11       	cpse	r24, r1
    2cf2:	af c0       	rjmp	.+350    	; 0x2e52 <xTaskResumeAll+0x23a>
    2cf4:	80 91 72 15 	lds	r24, 0x1572	; 0x801572 <xTickCount>
    2cf8:	90 91 73 15 	lds	r25, 0x1573	; 0x801573 <xTickCount+0x1>
    2cfc:	01 96       	adiw	r24, 0x01	; 1
    2cfe:	90 93 73 15 	sts	0x1573, r25	; 0x801573 <xTickCount+0x1>
    2d02:	80 93 72 15 	sts	0x1572, r24	; 0x801572 <xTickCount>
    2d06:	e0 90 72 15 	lds	r14, 0x1572	; 0x801572 <xTickCount>
    2d0a:	f0 90 73 15 	lds	r15, 0x1573	; 0x801573 <xTickCount+0x1>
    2d0e:	e1 14       	cp	r14, r1
    2d10:	f1 04       	cpc	r15, r1
    2d12:	89 f5       	brne	.+98     	; 0x2d76 <xTaskResumeAll+0x15e>
    2d14:	80 91 93 15 	lds	r24, 0x1593	; 0x801593 <pxDelayedTaskList>
    2d18:	90 91 94 15 	lds	r25, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2d1c:	20 91 91 15 	lds	r18, 0x1591	; 0x801591 <pxOverflowDelayedTaskList>
    2d20:	30 91 92 15 	lds	r19, 0x1592	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    2d24:	30 93 94 15 	sts	0x1594, r19	; 0x801594 <pxDelayedTaskList+0x1>
    2d28:	20 93 93 15 	sts	0x1593, r18	; 0x801593 <pxDelayedTaskList>
    2d2c:	90 93 92 15 	sts	0x1592, r25	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    2d30:	80 93 91 15 	sts	0x1591, r24	; 0x801591 <pxOverflowDelayedTaskList>
    2d34:	80 91 6d 15 	lds	r24, 0x156D	; 0x80156d <xNumOfOverflows>
    2d38:	8f 5f       	subi	r24, 0xFF	; 255
    2d3a:	80 93 6d 15 	sts	0x156D, r24	; 0x80156d <xNumOfOverflows>
    2d3e:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    2d42:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2d46:	80 81       	ld	r24, Z
    2d48:	81 11       	cpse	r24, r1
    2d4a:	05 c0       	rjmp	.+10     	; 0x2d56 <xTaskResumeAll+0x13e>
    2d4c:	d0 92 6b 15 	sts	0x156B, r13	; 0x80156b <xNextTaskUnblockTime+0x1>
    2d50:	c0 92 6a 15 	sts	0x156A, r12	; 0x80156a <xNextTaskUnblockTime>
    2d54:	10 c0       	rjmp	.+32     	; 0x2d76 <xTaskResumeAll+0x15e>
    2d56:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    2d5a:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2d5e:	05 80       	ldd	r0, Z+5	; 0x05
    2d60:	f6 81       	ldd	r31, Z+6	; 0x06
    2d62:	e0 2d       	mov	r30, r0
    2d64:	06 80       	ldd	r0, Z+6	; 0x06
    2d66:	f7 81       	ldd	r31, Z+7	; 0x07
    2d68:	e0 2d       	mov	r30, r0
    2d6a:	82 81       	ldd	r24, Z+2	; 0x02
    2d6c:	93 81       	ldd	r25, Z+3	; 0x03
    2d6e:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    2d72:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    2d76:	80 91 6a 15 	lds	r24, 0x156A	; 0x80156a <xNextTaskUnblockTime>
    2d7a:	90 91 6b 15 	lds	r25, 0x156B	; 0x80156b <xNextTaskUnblockTime+0x1>
    2d7e:	e8 16       	cp	r14, r24
    2d80:	f9 06       	cpc	r15, r25
    2d82:	10 f4       	brcc	.+4      	; 0x2d88 <xTaskResumeAll+0x170>
    2d84:	a9 2c       	mov	r10, r9
    2d86:	4f c0       	rjmp	.+158    	; 0x2e26 <xTaskResumeAll+0x20e>
    2d88:	a9 2c       	mov	r10, r9
    2d8a:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    2d8e:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2d92:	80 81       	ld	r24, Z
    2d94:	81 11       	cpse	r24, r1
    2d96:	05 c0       	rjmp	.+10     	; 0x2da2 <xTaskResumeAll+0x18a>
    2d98:	d0 92 6b 15 	sts	0x156B, r13	; 0x80156b <xNextTaskUnblockTime+0x1>
    2d9c:	c0 92 6a 15 	sts	0x156A, r12	; 0x80156a <xNextTaskUnblockTime>
    2da0:	42 c0       	rjmp	.+132    	; 0x2e26 <xTaskResumeAll+0x20e>
    2da2:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    2da6:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2daa:	05 80       	ldd	r0, Z+5	; 0x05
    2dac:	f6 81       	ldd	r31, Z+6	; 0x06
    2dae:	e0 2d       	mov	r30, r0
    2db0:	c6 81       	ldd	r28, Z+6	; 0x06
    2db2:	d7 81       	ldd	r29, Z+7	; 0x07
    2db4:	8a 81       	ldd	r24, Y+2	; 0x02
    2db6:	9b 81       	ldd	r25, Y+3	; 0x03
    2db8:	e8 16       	cp	r14, r24
    2dba:	f9 06       	cpc	r15, r25
    2dbc:	28 f4       	brcc	.+10     	; 0x2dc8 <xTaskResumeAll+0x1b0>
    2dbe:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    2dc2:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    2dc6:	2f c0       	rjmp	.+94     	; 0x2e26 <xTaskResumeAll+0x20e>
    2dc8:	8e 01       	movw	r16, r28
    2dca:	0e 5f       	subi	r16, 0xFE	; 254
    2dcc:	1f 4f       	sbci	r17, 0xFF	; 255
    2dce:	c8 01       	movw	r24, r16
    2dd0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    2dd4:	8c 89       	ldd	r24, Y+20	; 0x14
    2dd6:	9d 89       	ldd	r25, Y+21	; 0x15
    2dd8:	89 2b       	or	r24, r25
    2dda:	21 f0       	breq	.+8      	; 0x2de4 <xTaskResumeAll+0x1cc>
    2ddc:	ce 01       	movw	r24, r28
    2dde:	0c 96       	adiw	r24, 0x0c	; 12
    2de0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    2de4:	8e 89       	ldd	r24, Y+22	; 0x16
    2de6:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    2dea:	98 17       	cp	r25, r24
    2dec:	10 f4       	brcc	.+4      	; 0x2df2 <xTaskResumeAll+0x1da>
    2dee:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    2df2:	90 e0       	ldi	r25, 0x00	; 0
    2df4:	9c 01       	movw	r18, r24
    2df6:	22 0f       	add	r18, r18
    2df8:	33 1f       	adc	r19, r19
    2dfa:	22 0f       	add	r18, r18
    2dfc:	33 1f       	adc	r19, r19
    2dfe:	22 0f       	add	r18, r18
    2e00:	33 1f       	adc	r19, r19
    2e02:	82 0f       	add	r24, r18
    2e04:	93 1f       	adc	r25, r19
    2e06:	b8 01       	movw	r22, r16
    2e08:	89 55       	subi	r24, 0x59	; 89
    2e0a:	9a 4e       	sbci	r25, 0xEA	; 234
    2e0c:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    2e10:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2e14:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2e18:	9e 89       	ldd	r25, Y+22	; 0x16
    2e1a:	86 89       	ldd	r24, Z+22	; 0x16
    2e1c:	98 17       	cp	r25, r24
    2e1e:	08 f4       	brcc	.+2      	; 0x2e22 <xTaskResumeAll+0x20a>
    2e20:	b4 cf       	rjmp	.-152    	; 0x2d8a <xTaskResumeAll+0x172>
    2e22:	ab 2c       	mov	r10, r11
    2e24:	b2 cf       	rjmp	.-156    	; 0x2d8a <xTaskResumeAll+0x172>
    2e26:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    2e2a:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    2e2e:	86 89       	ldd	r24, Z+22	; 0x16
    2e30:	90 e0       	ldi	r25, 0x00	; 0
    2e32:	fc 01       	movw	r30, r24
    2e34:	ee 0f       	add	r30, r30
    2e36:	ff 1f       	adc	r31, r31
    2e38:	ee 0f       	add	r30, r30
    2e3a:	ff 1f       	adc	r31, r31
    2e3c:	ee 0f       	add	r30, r30
    2e3e:	ff 1f       	adc	r31, r31
    2e40:	8e 0f       	add	r24, r30
    2e42:	9f 1f       	adc	r25, r31
    2e44:	fc 01       	movw	r30, r24
    2e46:	e9 55       	subi	r30, 0x59	; 89
    2e48:	fa 4e       	sbci	r31, 0xEA	; 234
    2e4a:	80 81       	ld	r24, Z
    2e4c:	82 30       	cpi	r24, 0x02	; 2
    2e4e:	48 f5       	brcc	.+82     	; 0x2ea2 <xTaskResumeAll+0x28a>
    2e50:	0a c0       	rjmp	.+20     	; 0x2e66 <xTaskResumeAll+0x24e>
    2e52:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    2e56:	8f 5f       	subi	r24, 0xFF	; 255
    2e58:	80 93 6f 15 	sts	0x156F, r24	; 0x80156f <uxPendedTicks>
    2e5c:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    2e60:	81 11       	cpse	r24, r1
    2e62:	06 c0       	rjmp	.+12     	; 0x2e70 <xTaskResumeAll+0x258>
    2e64:	07 c0       	rjmp	.+14     	; 0x2e74 <xTaskResumeAll+0x25c>
    2e66:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    2e6a:	81 11       	cpse	r24, r1
    2e6c:	01 c0       	rjmp	.+2      	; 0x2e70 <xTaskResumeAll+0x258>
    2e6e:	a1 10       	cpse	r10, r1
    2e70:	b0 92 6e 15 	sts	0x156E, r11	; 0x80156e <xYieldPending>
    2e74:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    2e78:	81 50       	subi	r24, 0x01	; 1
    2e7a:	80 93 6f 15 	sts	0x156F, r24	; 0x80156f <uxPendedTicks>
    2e7e:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    2e82:	81 11       	cpse	r24, r1
    2e84:	33 cf       	rjmp	.-410    	; 0x2cec <xTaskResumeAll+0xd4>
    2e86:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    2e8a:	81 30       	cpi	r24, 0x01	; 1
    2e8c:	31 f4       	brne	.+12     	; 0x2e9a <xTaskResumeAll+0x282>
    2e8e:	0e 94 4f 0c 	call	0x189e	; 0x189e <vPortYield>
    2e92:	81 e0       	ldi	r24, 0x01	; 1
    2e94:	03 c0       	rjmp	.+6      	; 0x2e9c <xTaskResumeAll+0x284>
    2e96:	80 e0       	ldi	r24, 0x00	; 0
    2e98:	01 c0       	rjmp	.+2      	; 0x2e9c <xTaskResumeAll+0x284>
    2e9a:	80 e0       	ldi	r24, 0x00	; 0
    2e9c:	0f 90       	pop	r0
    2e9e:	0f be       	out	0x3f, r0	; 63
    2ea0:	03 c0       	rjmp	.+6      	; 0x2ea8 <xTaskResumeAll+0x290>
    2ea2:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    2ea6:	e4 cf       	rjmp	.-56     	; 0x2e70 <xTaskResumeAll+0x258>
    2ea8:	df 91       	pop	r29
    2eaa:	cf 91       	pop	r28
    2eac:	1f 91       	pop	r17
    2eae:	0f 91       	pop	r16
    2eb0:	ff 90       	pop	r15
    2eb2:	ef 90       	pop	r14
    2eb4:	df 90       	pop	r13
    2eb6:	cf 90       	pop	r12
    2eb8:	bf 90       	pop	r11
    2eba:	af 90       	pop	r10
    2ebc:	9f 90       	pop	r9
    2ebe:	08 95       	ret

00002ec0 <xTaskIncrementTick>:
    2ec0:	cf 92       	push	r12
    2ec2:	df 92       	push	r13
    2ec4:	ef 92       	push	r14
    2ec6:	ff 92       	push	r15
    2ec8:	0f 93       	push	r16
    2eca:	1f 93       	push	r17
    2ecc:	cf 93       	push	r28
    2ece:	df 93       	push	r29
    2ed0:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    2ed4:	81 11       	cpse	r24, r1
    2ed6:	b7 c0       	rjmp	.+366    	; 0x3046 <xTaskIncrementTick+0x186>
    2ed8:	80 91 72 15 	lds	r24, 0x1572	; 0x801572 <xTickCount>
    2edc:	90 91 73 15 	lds	r25, 0x1573	; 0x801573 <xTickCount+0x1>
    2ee0:	01 96       	adiw	r24, 0x01	; 1
    2ee2:	90 93 73 15 	sts	0x1573, r25	; 0x801573 <xTickCount+0x1>
    2ee6:	80 93 72 15 	sts	0x1572, r24	; 0x801572 <xTickCount>
    2eea:	e0 90 72 15 	lds	r14, 0x1572	; 0x801572 <xTickCount>
    2eee:	f0 90 73 15 	lds	r15, 0x1573	; 0x801573 <xTickCount+0x1>
    2ef2:	e1 14       	cp	r14, r1
    2ef4:	f1 04       	cpc	r15, r1
    2ef6:	99 f5       	brne	.+102    	; 0x2f5e <xTaskIncrementTick+0x9e>
    2ef8:	80 91 93 15 	lds	r24, 0x1593	; 0x801593 <pxDelayedTaskList>
    2efc:	90 91 94 15 	lds	r25, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2f00:	20 91 91 15 	lds	r18, 0x1591	; 0x801591 <pxOverflowDelayedTaskList>
    2f04:	30 91 92 15 	lds	r19, 0x1592	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    2f08:	30 93 94 15 	sts	0x1594, r19	; 0x801594 <pxDelayedTaskList+0x1>
    2f0c:	20 93 93 15 	sts	0x1593, r18	; 0x801593 <pxDelayedTaskList>
    2f10:	90 93 92 15 	sts	0x1592, r25	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    2f14:	80 93 91 15 	sts	0x1591, r24	; 0x801591 <pxOverflowDelayedTaskList>
    2f18:	80 91 6d 15 	lds	r24, 0x156D	; 0x80156d <xNumOfOverflows>
    2f1c:	8f 5f       	subi	r24, 0xFF	; 255
    2f1e:	80 93 6d 15 	sts	0x156D, r24	; 0x80156d <xNumOfOverflows>
    2f22:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    2f26:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2f2a:	80 81       	ld	r24, Z
    2f2c:	81 11       	cpse	r24, r1
    2f2e:	07 c0       	rjmp	.+14     	; 0x2f3e <xTaskIncrementTick+0x7e>
    2f30:	8f ef       	ldi	r24, 0xFF	; 255
    2f32:	9f ef       	ldi	r25, 0xFF	; 255
    2f34:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    2f38:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    2f3c:	10 c0       	rjmp	.+32     	; 0x2f5e <xTaskIncrementTick+0x9e>
    2f3e:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    2f42:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2f46:	05 80       	ldd	r0, Z+5	; 0x05
    2f48:	f6 81       	ldd	r31, Z+6	; 0x06
    2f4a:	e0 2d       	mov	r30, r0
    2f4c:	06 80       	ldd	r0, Z+6	; 0x06
    2f4e:	f7 81       	ldd	r31, Z+7	; 0x07
    2f50:	e0 2d       	mov	r30, r0
    2f52:	82 81       	ldd	r24, Z+2	; 0x02
    2f54:	93 81       	ldd	r25, Z+3	; 0x03
    2f56:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    2f5a:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    2f5e:	80 91 6a 15 	lds	r24, 0x156A	; 0x80156a <xNextTaskUnblockTime>
    2f62:	90 91 6b 15 	lds	r25, 0x156B	; 0x80156b <xNextTaskUnblockTime+0x1>
    2f66:	e8 16       	cp	r14, r24
    2f68:	f9 06       	cpc	r15, r25
    2f6a:	10 f4       	brcc	.+4      	; 0x2f70 <xTaskIncrementTick+0xb0>
    2f6c:	d1 2c       	mov	r13, r1
    2f6e:	53 c0       	rjmp	.+166    	; 0x3016 <xTaskIncrementTick+0x156>
    2f70:	d1 2c       	mov	r13, r1
    2f72:	cc 24       	eor	r12, r12
    2f74:	c3 94       	inc	r12
    2f76:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    2f7a:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2f7e:	80 81       	ld	r24, Z
    2f80:	81 11       	cpse	r24, r1
    2f82:	07 c0       	rjmp	.+14     	; 0x2f92 <xTaskIncrementTick+0xd2>
    2f84:	8f ef       	ldi	r24, 0xFF	; 255
    2f86:	9f ef       	ldi	r25, 0xFF	; 255
    2f88:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    2f8c:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    2f90:	42 c0       	rjmp	.+132    	; 0x3016 <xTaskIncrementTick+0x156>
    2f92:	e0 91 93 15 	lds	r30, 0x1593	; 0x801593 <pxDelayedTaskList>
    2f96:	f0 91 94 15 	lds	r31, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    2f9a:	05 80       	ldd	r0, Z+5	; 0x05
    2f9c:	f6 81       	ldd	r31, Z+6	; 0x06
    2f9e:	e0 2d       	mov	r30, r0
    2fa0:	c6 81       	ldd	r28, Z+6	; 0x06
    2fa2:	d7 81       	ldd	r29, Z+7	; 0x07
    2fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fa6:	9b 81       	ldd	r25, Y+3	; 0x03
    2fa8:	e8 16       	cp	r14, r24
    2faa:	f9 06       	cpc	r15, r25
    2fac:	28 f4       	brcc	.+10     	; 0x2fb8 <xTaskIncrementTick+0xf8>
    2fae:	90 93 6b 15 	sts	0x156B, r25	; 0x80156b <xNextTaskUnblockTime+0x1>
    2fb2:	80 93 6a 15 	sts	0x156A, r24	; 0x80156a <xNextTaskUnblockTime>
    2fb6:	2f c0       	rjmp	.+94     	; 0x3016 <xTaskIncrementTick+0x156>
    2fb8:	8e 01       	movw	r16, r28
    2fba:	0e 5f       	subi	r16, 0xFE	; 254
    2fbc:	1f 4f       	sbci	r17, 0xFF	; 255
    2fbe:	c8 01       	movw	r24, r16
    2fc0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    2fc4:	8c 89       	ldd	r24, Y+20	; 0x14
    2fc6:	9d 89       	ldd	r25, Y+21	; 0x15
    2fc8:	89 2b       	or	r24, r25
    2fca:	21 f0       	breq	.+8      	; 0x2fd4 <xTaskIncrementTick+0x114>
    2fcc:	ce 01       	movw	r24, r28
    2fce:	0c 96       	adiw	r24, 0x0c	; 12
    2fd0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    2fd4:	8e 89       	ldd	r24, Y+22	; 0x16
    2fd6:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    2fda:	98 17       	cp	r25, r24
    2fdc:	10 f4       	brcc	.+4      	; 0x2fe2 <xTaskIncrementTick+0x122>
    2fde:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    2fe2:	90 e0       	ldi	r25, 0x00	; 0
    2fe4:	9c 01       	movw	r18, r24
    2fe6:	22 0f       	add	r18, r18
    2fe8:	33 1f       	adc	r19, r19
    2fea:	22 0f       	add	r18, r18
    2fec:	33 1f       	adc	r19, r19
    2fee:	22 0f       	add	r18, r18
    2ff0:	33 1f       	adc	r19, r19
    2ff2:	82 0f       	add	r24, r18
    2ff4:	93 1f       	adc	r25, r19
    2ff6:	b8 01       	movw	r22, r16
    2ff8:	89 55       	subi	r24, 0x59	; 89
    2ffa:	9a 4e       	sbci	r25, 0xEA	; 234
    2ffc:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    3000:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    3004:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    3008:	9e 89       	ldd	r25, Y+22	; 0x16
    300a:	86 89       	ldd	r24, Z+22	; 0x16
    300c:	98 17       	cp	r25, r24
    300e:	08 f4       	brcc	.+2      	; 0x3012 <xTaskIncrementTick+0x152>
    3010:	b2 cf       	rjmp	.-156    	; 0x2f76 <xTaskIncrementTick+0xb6>
    3012:	dc 2c       	mov	r13, r12
    3014:	b0 cf       	rjmp	.-160    	; 0x2f76 <xTaskIncrementTick+0xb6>
    3016:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    301a:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    301e:	86 89       	ldd	r24, Z+22	; 0x16
    3020:	90 e0       	ldi	r25, 0x00	; 0
    3022:	fc 01       	movw	r30, r24
    3024:	ee 0f       	add	r30, r30
    3026:	ff 1f       	adc	r31, r31
    3028:	ee 0f       	add	r30, r30
    302a:	ff 1f       	adc	r31, r31
    302c:	ee 0f       	add	r30, r30
    302e:	ff 1f       	adc	r31, r31
    3030:	8e 0f       	add	r24, r30
    3032:	9f 1f       	adc	r25, r31
    3034:	fc 01       	movw	r30, r24
    3036:	e9 55       	subi	r30, 0x59	; 89
    3038:	fa 4e       	sbci	r31, 0xEA	; 234
    303a:	80 81       	ld	r24, Z
    303c:	82 30       	cpi	r24, 0x02	; 2
    303e:	48 f0       	brcs	.+18     	; 0x3052 <xTaskIncrementTick+0x192>
    3040:	dd 24       	eor	r13, r13
    3042:	d3 94       	inc	r13
    3044:	06 c0       	rjmp	.+12     	; 0x3052 <xTaskIncrementTick+0x192>
    3046:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <uxPendedTicks>
    304a:	8f 5f       	subi	r24, 0xFF	; 255
    304c:	80 93 6f 15 	sts	0x156F, r24	; 0x80156f <uxPendedTicks>
    3050:	d1 2c       	mov	r13, r1
    3052:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <xYieldPending>
    3056:	88 23       	and	r24, r24
    3058:	11 f0       	breq	.+4      	; 0x305e <xTaskIncrementTick+0x19e>
    305a:	dd 24       	eor	r13, r13
    305c:	d3 94       	inc	r13
    305e:	8d 2d       	mov	r24, r13
    3060:	df 91       	pop	r29
    3062:	cf 91       	pop	r28
    3064:	1f 91       	pop	r17
    3066:	0f 91       	pop	r16
    3068:	ff 90       	pop	r15
    306a:	ef 90       	pop	r14
    306c:	df 90       	pop	r13
    306e:	cf 90       	pop	r12
    3070:	08 95       	ret

00003072 <vTaskSwitchContext>:
    3072:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    3076:	88 23       	and	r24, r24
    3078:	21 f0       	breq	.+8      	; 0x3082 <vTaskSwitchContext+0x10>
    307a:	81 e0       	ldi	r24, 0x01	; 1
    307c:	80 93 6e 15 	sts	0x156E, r24	; 0x80156e <xYieldPending>
    3080:	08 95       	ret
    3082:	10 92 6e 15 	sts	0x156E, r1	; 0x80156e <xYieldPending>
    3086:	80 91 71 15 	lds	r24, 0x1571	; 0x801571 <uxTopReadyPriority>
    308a:	90 e0       	ldi	r25, 0x00	; 0
    308c:	fc 01       	movw	r30, r24
    308e:	ee 0f       	add	r30, r30
    3090:	ff 1f       	adc	r31, r31
    3092:	ee 0f       	add	r30, r30
    3094:	ff 1f       	adc	r31, r31
    3096:	ee 0f       	add	r30, r30
    3098:	ff 1f       	adc	r31, r31
    309a:	8e 0f       	add	r24, r30
    309c:	9f 1f       	adc	r25, r31
    309e:	fc 01       	movw	r30, r24
    30a0:	e9 55       	subi	r30, 0x59	; 89
    30a2:	fa 4e       	sbci	r31, 0xEA	; 234
    30a4:	80 81       	ld	r24, Z
    30a6:	81 11       	cpse	r24, r1
    30a8:	17 c0       	rjmp	.+46     	; 0x30d8 <vTaskSwitchContext+0x66>
    30aa:	80 91 71 15 	lds	r24, 0x1571	; 0x801571 <uxTopReadyPriority>
    30ae:	81 50       	subi	r24, 0x01	; 1
    30b0:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    30b4:	80 91 71 15 	lds	r24, 0x1571	; 0x801571 <uxTopReadyPriority>
    30b8:	90 e0       	ldi	r25, 0x00	; 0
    30ba:	fc 01       	movw	r30, r24
    30bc:	ee 0f       	add	r30, r30
    30be:	ff 1f       	adc	r31, r31
    30c0:	ee 0f       	add	r30, r30
    30c2:	ff 1f       	adc	r31, r31
    30c4:	ee 0f       	add	r30, r30
    30c6:	ff 1f       	adc	r31, r31
    30c8:	8e 0f       	add	r24, r30
    30ca:	9f 1f       	adc	r25, r31
    30cc:	fc 01       	movw	r30, r24
    30ce:	e9 55       	subi	r30, 0x59	; 89
    30d0:	fa 4e       	sbci	r31, 0xEA	; 234
    30d2:	80 81       	ld	r24, Z
    30d4:	88 23       	and	r24, r24
    30d6:	49 f3       	breq	.-46     	; 0x30aa <vTaskSwitchContext+0x38>
    30d8:	80 91 71 15 	lds	r24, 0x1571	; 0x801571 <uxTopReadyPriority>
    30dc:	90 e0       	ldi	r25, 0x00	; 0
    30de:	9c 01       	movw	r18, r24
    30e0:	22 0f       	add	r18, r18
    30e2:	33 1f       	adc	r19, r19
    30e4:	22 0f       	add	r18, r18
    30e6:	33 1f       	adc	r19, r19
    30e8:	22 0f       	add	r18, r18
    30ea:	33 1f       	adc	r19, r19
    30ec:	28 0f       	add	r18, r24
    30ee:	39 1f       	adc	r19, r25
    30f0:	d9 01       	movw	r26, r18
    30f2:	a9 55       	subi	r26, 0x59	; 89
    30f4:	ba 4e       	sbci	r27, 0xEA	; 234
    30f6:	11 96       	adiw	r26, 0x01	; 1
    30f8:	ed 91       	ld	r30, X+
    30fa:	fc 91       	ld	r31, X
    30fc:	12 97       	sbiw	r26, 0x02	; 2
    30fe:	02 80       	ldd	r0, Z+2	; 0x02
    3100:	f3 81       	ldd	r31, Z+3	; 0x03
    3102:	e0 2d       	mov	r30, r0
    3104:	12 96       	adiw	r26, 0x02	; 2
    3106:	fc 93       	st	X, r31
    3108:	ee 93       	st	-X, r30
    310a:	11 97       	sbiw	r26, 0x01	; 1
    310c:	26 55       	subi	r18, 0x56	; 86
    310e:	3a 4e       	sbci	r19, 0xEA	; 234
    3110:	e2 17       	cp	r30, r18
    3112:	f3 07       	cpc	r31, r19
    3114:	29 f4       	brne	.+10     	; 0x3120 <vTaskSwitchContext+0xae>
    3116:	22 81       	ldd	r18, Z+2	; 0x02
    3118:	33 81       	ldd	r19, Z+3	; 0x03
    311a:	fd 01       	movw	r30, r26
    311c:	32 83       	std	Z+2, r19	; 0x02
    311e:	21 83       	std	Z+1, r18	; 0x01
    3120:	fc 01       	movw	r30, r24
    3122:	ee 0f       	add	r30, r30
    3124:	ff 1f       	adc	r31, r31
    3126:	ee 0f       	add	r30, r30
    3128:	ff 1f       	adc	r31, r31
    312a:	ee 0f       	add	r30, r30
    312c:	ff 1f       	adc	r31, r31
    312e:	8e 0f       	add	r24, r30
    3130:	9f 1f       	adc	r25, r31
    3132:	fc 01       	movw	r30, r24
    3134:	e9 55       	subi	r30, 0x59	; 89
    3136:	fa 4e       	sbci	r31, 0xEA	; 234
    3138:	01 80       	ldd	r0, Z+1	; 0x01
    313a:	f2 81       	ldd	r31, Z+2	; 0x02
    313c:	e0 2d       	mov	r30, r0
    313e:	86 81       	ldd	r24, Z+6	; 0x06
    3140:	97 81       	ldd	r25, Z+7	; 0x07
    3142:	90 93 cc 15 	sts	0x15CC, r25	; 0x8015cc <pxCurrentTCB+0x1>
    3146:	80 93 cb 15 	sts	0x15CB, r24	; 0x8015cb <pxCurrentTCB>
    314a:	08 95       	ret

0000314c <vTaskPlaceOnEventList>:
    314c:	cf 93       	push	r28
    314e:	df 93       	push	r29
    3150:	eb 01       	movw	r28, r22
    3152:	60 91 cb 15 	lds	r22, 0x15CB	; 0x8015cb <pxCurrentTCB>
    3156:	70 91 cc 15 	lds	r23, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    315a:	64 5f       	subi	r22, 0xF4	; 244
    315c:	7f 4f       	sbci	r23, 0xFF	; 255
    315e:	0e 94 3d 0b 	call	0x167a	; 0x167a <vListInsert>
    3162:	80 91 cb 15 	lds	r24, 0x15CB	; 0x8015cb <pxCurrentTCB>
    3166:	90 91 cc 15 	lds	r25, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    316a:	02 96       	adiw	r24, 0x02	; 2
    316c:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    3170:	cf 3f       	cpi	r28, 0xFF	; 255
    3172:	8f ef       	ldi	r24, 0xFF	; 255
    3174:	d8 07       	cpc	r29, r24
    3176:	59 f4       	brne	.+22     	; 0x318e <vTaskPlaceOnEventList+0x42>
    3178:	60 91 cb 15 	lds	r22, 0x15CB	; 0x8015cb <pxCurrentTCB>
    317c:	70 91 cc 15 	lds	r23, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    3180:	6e 5f       	subi	r22, 0xFE	; 254
    3182:	7f 4f       	sbci	r23, 0xFF	; 255
    3184:	85 e7       	ldi	r24, 0x75	; 117
    3186:	95 e1       	ldi	r25, 0x15	; 21
    3188:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    318c:	37 c0       	rjmp	.+110    	; 0x31fc <vTaskPlaceOnEventList+0xb0>
    318e:	80 91 72 15 	lds	r24, 0x1572	; 0x801572 <xTickCount>
    3192:	90 91 73 15 	lds	r25, 0x1573	; 0x801573 <xTickCount+0x1>
    3196:	c8 0f       	add	r28, r24
    3198:	d9 1f       	adc	r29, r25
    319a:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    319e:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    31a2:	d3 83       	std	Z+3, r29	; 0x03
    31a4:	c2 83       	std	Z+2, r28	; 0x02
    31a6:	80 91 72 15 	lds	r24, 0x1572	; 0x801572 <xTickCount>
    31aa:	90 91 73 15 	lds	r25, 0x1573	; 0x801573 <xTickCount+0x1>
    31ae:	c8 17       	cp	r28, r24
    31b0:	d9 07       	cpc	r29, r25
    31b2:	68 f4       	brcc	.+26     	; 0x31ce <vTaskPlaceOnEventList+0x82>
    31b4:	60 91 cb 15 	lds	r22, 0x15CB	; 0x8015cb <pxCurrentTCB>
    31b8:	70 91 cc 15 	lds	r23, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    31bc:	80 91 91 15 	lds	r24, 0x1591	; 0x801591 <pxOverflowDelayedTaskList>
    31c0:	90 91 92 15 	lds	r25, 0x1592	; 0x801592 <pxOverflowDelayedTaskList+0x1>
    31c4:	6e 5f       	subi	r22, 0xFE	; 254
    31c6:	7f 4f       	sbci	r23, 0xFF	; 255
    31c8:	0e 94 3d 0b 	call	0x167a	; 0x167a <vListInsert>
    31cc:	17 c0       	rjmp	.+46     	; 0x31fc <vTaskPlaceOnEventList+0xb0>
    31ce:	60 91 cb 15 	lds	r22, 0x15CB	; 0x8015cb <pxCurrentTCB>
    31d2:	70 91 cc 15 	lds	r23, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    31d6:	80 91 93 15 	lds	r24, 0x1593	; 0x801593 <pxDelayedTaskList>
    31da:	90 91 94 15 	lds	r25, 0x1594	; 0x801594 <pxDelayedTaskList+0x1>
    31de:	6e 5f       	subi	r22, 0xFE	; 254
    31e0:	7f 4f       	sbci	r23, 0xFF	; 255
    31e2:	0e 94 3d 0b 	call	0x167a	; 0x167a <vListInsert>
    31e6:	80 91 6a 15 	lds	r24, 0x156A	; 0x80156a <xNextTaskUnblockTime>
    31ea:	90 91 6b 15 	lds	r25, 0x156B	; 0x80156b <xNextTaskUnblockTime+0x1>
    31ee:	c8 17       	cp	r28, r24
    31f0:	d9 07       	cpc	r29, r25
    31f2:	20 f4       	brcc	.+8      	; 0x31fc <vTaskPlaceOnEventList+0xb0>
    31f4:	d0 93 6b 15 	sts	0x156B, r29	; 0x80156b <xNextTaskUnblockTime+0x1>
    31f8:	c0 93 6a 15 	sts	0x156A, r28	; 0x80156a <xNextTaskUnblockTime>
    31fc:	df 91       	pop	r29
    31fe:	cf 91       	pop	r28
    3200:	08 95       	ret

00003202 <xTaskRemoveFromEventList>:
    3202:	0f 93       	push	r16
    3204:	1f 93       	push	r17
    3206:	cf 93       	push	r28
    3208:	df 93       	push	r29
    320a:	dc 01       	movw	r26, r24
    320c:	15 96       	adiw	r26, 0x05	; 5
    320e:	ed 91       	ld	r30, X+
    3210:	fc 91       	ld	r31, X
    3212:	16 97       	sbiw	r26, 0x06	; 6
    3214:	c6 81       	ldd	r28, Z+6	; 0x06
    3216:	d7 81       	ldd	r29, Z+7	; 0x07
    3218:	8e 01       	movw	r16, r28
    321a:	04 5f       	subi	r16, 0xF4	; 244
    321c:	1f 4f       	sbci	r17, 0xFF	; 255
    321e:	c8 01       	movw	r24, r16
    3220:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    3224:	80 91 69 15 	lds	r24, 0x1569	; 0x801569 <uxSchedulerSuspended>
    3228:	81 11       	cpse	r24, r1
    322a:	1c c0       	rjmp	.+56     	; 0x3264 <xTaskRemoveFromEventList+0x62>
    322c:	0a 50       	subi	r16, 0x0A	; 10
    322e:	11 09       	sbc	r17, r1
    3230:	c8 01       	movw	r24, r16
    3232:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    3236:	8e 89       	ldd	r24, Y+22	; 0x16
    3238:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    323c:	98 17       	cp	r25, r24
    323e:	10 f4       	brcc	.+4      	; 0x3244 <xTaskRemoveFromEventList+0x42>
    3240:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    3244:	90 e0       	ldi	r25, 0x00	; 0
    3246:	9c 01       	movw	r18, r24
    3248:	22 0f       	add	r18, r18
    324a:	33 1f       	adc	r19, r19
    324c:	22 0f       	add	r18, r18
    324e:	33 1f       	adc	r19, r19
    3250:	22 0f       	add	r18, r18
    3252:	33 1f       	adc	r19, r19
    3254:	82 0f       	add	r24, r18
    3256:	93 1f       	adc	r25, r19
    3258:	b8 01       	movw	r22, r16
    325a:	89 55       	subi	r24, 0x59	; 89
    325c:	9a 4e       	sbci	r25, 0xEA	; 234
    325e:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    3262:	05 c0       	rjmp	.+10     	; 0x326e <xTaskRemoveFromEventList+0x6c>
    3264:	b8 01       	movw	r22, r16
    3266:	88 e8       	ldi	r24, 0x88	; 136
    3268:	95 e1       	ldi	r25, 0x15	; 21
    326a:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    326e:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    3272:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    3276:	9e 89       	ldd	r25, Y+22	; 0x16
    3278:	86 89       	ldd	r24, Z+22	; 0x16
    327a:	89 17       	cp	r24, r25
    327c:	20 f4       	brcc	.+8      	; 0x3286 <xTaskRemoveFromEventList+0x84>
    327e:	81 e0       	ldi	r24, 0x01	; 1
    3280:	80 93 6e 15 	sts	0x156E, r24	; 0x80156e <xYieldPending>
    3284:	01 c0       	rjmp	.+2      	; 0x3288 <xTaskRemoveFromEventList+0x86>
    3286:	80 e0       	ldi	r24, 0x00	; 0
    3288:	df 91       	pop	r29
    328a:	cf 91       	pop	r28
    328c:	1f 91       	pop	r17
    328e:	0f 91       	pop	r16
    3290:	08 95       	ret

00003292 <vTaskSetTimeOutState>:
    3292:	20 91 6d 15 	lds	r18, 0x156D	; 0x80156d <xNumOfOverflows>
    3296:	fc 01       	movw	r30, r24
    3298:	20 83       	st	Z, r18
    329a:	20 91 72 15 	lds	r18, 0x1572	; 0x801572 <xTickCount>
    329e:	30 91 73 15 	lds	r19, 0x1573	; 0x801573 <xTickCount+0x1>
    32a2:	32 83       	std	Z+2, r19	; 0x02
    32a4:	21 83       	std	Z+1, r18	; 0x01
    32a6:	08 95       	ret

000032a8 <xTaskCheckForTimeOut>:
    32a8:	fc 01       	movw	r30, r24
    32aa:	0f b6       	in	r0, 0x3f	; 63
    32ac:	f8 94       	cli
    32ae:	0f 92       	push	r0
    32b0:	20 91 72 15 	lds	r18, 0x1572	; 0x801572 <xTickCount>
    32b4:	30 91 73 15 	lds	r19, 0x1573	; 0x801573 <xTickCount+0x1>
    32b8:	db 01       	movw	r26, r22
    32ba:	8d 91       	ld	r24, X+
    32bc:	9c 91       	ld	r25, X
    32be:	8f 3f       	cpi	r24, 0xFF	; 255
    32c0:	bf ef       	ldi	r27, 0xFF	; 255
    32c2:	9b 07       	cpc	r25, r27
    32c4:	21 f1       	breq	.+72     	; 0x330e <xTaskCheckForTimeOut+0x66>
    32c6:	40 91 6d 15 	lds	r20, 0x156D	; 0x80156d <xNumOfOverflows>
    32ca:	50 81       	ld	r21, Z
    32cc:	54 17       	cp	r21, r20
    32ce:	29 f0       	breq	.+10     	; 0x32da <xTaskCheckForTimeOut+0x32>
    32d0:	41 81       	ldd	r20, Z+1	; 0x01
    32d2:	52 81       	ldd	r21, Z+2	; 0x02
    32d4:	24 17       	cp	r18, r20
    32d6:	35 07       	cpc	r19, r21
    32d8:	e0 f4       	brcc	.+56     	; 0x3312 <xTaskCheckForTimeOut+0x6a>
    32da:	41 81       	ldd	r20, Z+1	; 0x01
    32dc:	52 81       	ldd	r21, Z+2	; 0x02
    32de:	d9 01       	movw	r26, r18
    32e0:	a4 1b       	sub	r26, r20
    32e2:	b5 0b       	sbc	r27, r21
    32e4:	a8 17       	cp	r26, r24
    32e6:	b9 07       	cpc	r27, r25
    32e8:	b0 f4       	brcc	.+44     	; 0x3316 <xTaskCheckForTimeOut+0x6e>
    32ea:	42 1b       	sub	r20, r18
    32ec:	53 0b       	sbc	r21, r19
    32ee:	84 0f       	add	r24, r20
    32f0:	95 1f       	adc	r25, r21
    32f2:	db 01       	movw	r26, r22
    32f4:	8d 93       	st	X+, r24
    32f6:	9c 93       	st	X, r25
    32f8:	80 91 6d 15 	lds	r24, 0x156D	; 0x80156d <xNumOfOverflows>
    32fc:	80 83       	st	Z, r24
    32fe:	80 91 72 15 	lds	r24, 0x1572	; 0x801572 <xTickCount>
    3302:	90 91 73 15 	lds	r25, 0x1573	; 0x801573 <xTickCount+0x1>
    3306:	92 83       	std	Z+2, r25	; 0x02
    3308:	81 83       	std	Z+1, r24	; 0x01
    330a:	80 e0       	ldi	r24, 0x00	; 0
    330c:	05 c0       	rjmp	.+10     	; 0x3318 <xTaskCheckForTimeOut+0x70>
    330e:	80 e0       	ldi	r24, 0x00	; 0
    3310:	03 c0       	rjmp	.+6      	; 0x3318 <xTaskCheckForTimeOut+0x70>
    3312:	81 e0       	ldi	r24, 0x01	; 1
    3314:	01 c0       	rjmp	.+2      	; 0x3318 <xTaskCheckForTimeOut+0x70>
    3316:	81 e0       	ldi	r24, 0x01	; 1
    3318:	0f 90       	pop	r0
    331a:	0f be       	out	0x3f, r0	; 63
    331c:	08 95       	ret

0000331e <vTaskMissedYield>:
    331e:	81 e0       	ldi	r24, 0x01	; 1
    3320:	80 93 6e 15 	sts	0x156E, r24	; 0x80156e <xYieldPending>
    3324:	08 95       	ret

00003326 <vTaskPriorityInherit>:
    3326:	0f 93       	push	r16
    3328:	1f 93       	push	r17
    332a:	cf 93       	push	r28
    332c:	df 93       	push	r29
    332e:	fc 01       	movw	r30, r24
    3330:	89 2b       	or	r24, r25
    3332:	09 f4       	brne	.+2      	; 0x3336 <vTaskPriorityInherit+0x10>
    3334:	55 c0       	rjmp	.+170    	; 0x33e0 <vTaskPriorityInherit+0xba>
    3336:	26 89       	ldd	r18, Z+22	; 0x16
    3338:	a0 91 cb 15 	lds	r26, 0x15CB	; 0x8015cb <pxCurrentTCB>
    333c:	b0 91 cc 15 	lds	r27, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    3340:	56 96       	adiw	r26, 0x16	; 22
    3342:	8c 91       	ld	r24, X
    3344:	28 17       	cp	r18, r24
    3346:	08 f0       	brcs	.+2      	; 0x334a <vTaskPriorityInherit+0x24>
    3348:	4b c0       	rjmp	.+150    	; 0x33e0 <vTaskPriorityInherit+0xba>
    334a:	84 85       	ldd	r24, Z+12	; 0x0c
    334c:	95 85       	ldd	r25, Z+13	; 0x0d
    334e:	99 23       	and	r25, r25
    3350:	64 f0       	brlt	.+24     	; 0x336a <vTaskPriorityInherit+0x44>
    3352:	a0 91 cb 15 	lds	r26, 0x15CB	; 0x8015cb <pxCurrentTCB>
    3356:	b0 91 cc 15 	lds	r27, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    335a:	56 96       	adiw	r26, 0x16	; 22
    335c:	3c 91       	ld	r19, X
    335e:	84 e0       	ldi	r24, 0x04	; 4
    3360:	90 e0       	ldi	r25, 0x00	; 0
    3362:	83 1b       	sub	r24, r19
    3364:	91 09       	sbc	r25, r1
    3366:	95 87       	std	Z+13, r25	; 0x0d
    3368:	84 87       	std	Z+12, r24	; 0x0c
    336a:	30 e0       	ldi	r19, 0x00	; 0
    336c:	c9 01       	movw	r24, r18
    336e:	88 0f       	add	r24, r24
    3370:	99 1f       	adc	r25, r25
    3372:	88 0f       	add	r24, r24
    3374:	99 1f       	adc	r25, r25
    3376:	88 0f       	add	r24, r24
    3378:	99 1f       	adc	r25, r25
    337a:	28 0f       	add	r18, r24
    337c:	39 1f       	adc	r19, r25
    337e:	29 55       	subi	r18, 0x59	; 89
    3380:	3a 4e       	sbci	r19, 0xEA	; 234
    3382:	82 85       	ldd	r24, Z+10	; 0x0a
    3384:	93 85       	ldd	r25, Z+11	; 0x0b
    3386:	82 17       	cp	r24, r18
    3388:	93 07       	cpc	r25, r19
    338a:	19 f5       	brne	.+70     	; 0x33d2 <vTaskPriorityInherit+0xac>
    338c:	8f 01       	movw	r16, r30
    338e:	ef 01       	movw	r28, r30
    3390:	22 96       	adiw	r28, 0x02	; 2
    3392:	ce 01       	movw	r24, r28
    3394:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    3398:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    339c:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    33a0:	86 89       	ldd	r24, Z+22	; 0x16
    33a2:	f8 01       	movw	r30, r16
    33a4:	86 8b       	std	Z+22, r24	; 0x16
    33a6:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    33aa:	98 17       	cp	r25, r24
    33ac:	10 f4       	brcc	.+4      	; 0x33b2 <vTaskPriorityInherit+0x8c>
    33ae:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	9c 01       	movw	r18, r24
    33b6:	22 0f       	add	r18, r18
    33b8:	33 1f       	adc	r19, r19
    33ba:	22 0f       	add	r18, r18
    33bc:	33 1f       	adc	r19, r19
    33be:	22 0f       	add	r18, r18
    33c0:	33 1f       	adc	r19, r19
    33c2:	82 0f       	add	r24, r18
    33c4:	93 1f       	adc	r25, r19
    33c6:	be 01       	movw	r22, r28
    33c8:	89 55       	subi	r24, 0x59	; 89
    33ca:	9a 4e       	sbci	r25, 0xEA	; 234
    33cc:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    33d0:	07 c0       	rjmp	.+14     	; 0x33e0 <vTaskPriorityInherit+0xba>
    33d2:	a0 91 cb 15 	lds	r26, 0x15CB	; 0x8015cb <pxCurrentTCB>
    33d6:	b0 91 cc 15 	lds	r27, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    33da:	56 96       	adiw	r26, 0x16	; 22
    33dc:	8c 91       	ld	r24, X
    33de:	86 8b       	std	Z+22, r24	; 0x16
    33e0:	df 91       	pop	r29
    33e2:	cf 91       	pop	r28
    33e4:	1f 91       	pop	r17
    33e6:	0f 91       	pop	r16
    33e8:	08 95       	ret

000033ea <xTaskPriorityDisinherit>:
    33ea:	0f 93       	push	r16
    33ec:	1f 93       	push	r17
    33ee:	cf 93       	push	r28
    33f0:	df 93       	push	r29
    33f2:	fc 01       	movw	r30, r24
    33f4:	89 2b       	or	r24, r25
    33f6:	79 f1       	breq	.+94     	; 0x3456 <xTaskPriorityDisinherit+0x6c>
    33f8:	82 a1       	ldd	r24, Z+34	; 0x22
    33fa:	81 50       	subi	r24, 0x01	; 1
    33fc:	82 a3       	std	Z+34, r24	; 0x22
    33fe:	26 89       	ldd	r18, Z+22	; 0x16
    3400:	91 a1       	ldd	r25, Z+33	; 0x21
    3402:	29 17       	cp	r18, r25
    3404:	51 f1       	breq	.+84     	; 0x345a <xTaskPriorityDisinherit+0x70>
    3406:	81 11       	cpse	r24, r1
    3408:	2a c0       	rjmp	.+84     	; 0x345e <xTaskPriorityDisinherit+0x74>
    340a:	ef 01       	movw	r28, r30
    340c:	8f 01       	movw	r16, r30
    340e:	0e 5f       	subi	r16, 0xFE	; 254
    3410:	1f 4f       	sbci	r17, 0xFF	; 255
    3412:	c8 01       	movw	r24, r16
    3414:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <uxListRemove>
    3418:	89 a1       	ldd	r24, Y+33	; 0x21
    341a:	8e 8b       	std	Y+22, r24	; 0x16
    341c:	24 e0       	ldi	r18, 0x04	; 4
    341e:	30 e0       	ldi	r19, 0x00	; 0
    3420:	28 1b       	sub	r18, r24
    3422:	31 09       	sbc	r19, r1
    3424:	3d 87       	std	Y+13, r19	; 0x0d
    3426:	2c 87       	std	Y+12, r18	; 0x0c
    3428:	90 91 71 15 	lds	r25, 0x1571	; 0x801571 <uxTopReadyPriority>
    342c:	98 17       	cp	r25, r24
    342e:	10 f4       	brcc	.+4      	; 0x3434 <xTaskPriorityDisinherit+0x4a>
    3430:	80 93 71 15 	sts	0x1571, r24	; 0x801571 <uxTopReadyPriority>
    3434:	90 e0       	ldi	r25, 0x00	; 0
    3436:	9c 01       	movw	r18, r24
    3438:	22 0f       	add	r18, r18
    343a:	33 1f       	adc	r19, r19
    343c:	22 0f       	add	r18, r18
    343e:	33 1f       	adc	r19, r19
    3440:	22 0f       	add	r18, r18
    3442:	33 1f       	adc	r19, r19
    3444:	82 0f       	add	r24, r18
    3446:	93 1f       	adc	r25, r19
    3448:	b8 01       	movw	r22, r16
    344a:	89 55       	subi	r24, 0x59	; 89
    344c:	9a 4e       	sbci	r25, 0xEA	; 234
    344e:	0e 94 1c 0b 	call	0x1638	; 0x1638 <vListInsertEnd>
    3452:	81 e0       	ldi	r24, 0x01	; 1
    3454:	05 c0       	rjmp	.+10     	; 0x3460 <xTaskPriorityDisinherit+0x76>
    3456:	80 e0       	ldi	r24, 0x00	; 0
    3458:	03 c0       	rjmp	.+6      	; 0x3460 <xTaskPriorityDisinherit+0x76>
    345a:	80 e0       	ldi	r24, 0x00	; 0
    345c:	01 c0       	rjmp	.+2      	; 0x3460 <xTaskPriorityDisinherit+0x76>
    345e:	80 e0       	ldi	r24, 0x00	; 0
    3460:	df 91       	pop	r29
    3462:	cf 91       	pop	r28
    3464:	1f 91       	pop	r17
    3466:	0f 91       	pop	r16
    3468:	08 95       	ret

0000346a <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    346a:	80 91 cb 15 	lds	r24, 0x15CB	; 0x8015cb <pxCurrentTCB>
    346e:	90 91 cc 15 	lds	r25, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    3472:	89 2b       	or	r24, r25
    3474:	39 f0       	breq	.+14     	; 0x3484 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    3476:	e0 91 cb 15 	lds	r30, 0x15CB	; 0x8015cb <pxCurrentTCB>
    347a:	f0 91 cc 15 	lds	r31, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
    347e:	82 a1       	ldd	r24, Z+34	; 0x22
    3480:	8f 5f       	subi	r24, 0xFF	; 255
    3482:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    3484:	80 91 cb 15 	lds	r24, 0x15CB	; 0x8015cb <pxCurrentTCB>
    3488:	90 91 cc 15 	lds	r25, 0x15CC	; 0x8015cc <pxCurrentTCB+0x1>
	}
    348c:	08 95       	ret

0000348e <xSerialPutChar>:

		default:
			break;
	}
	return 0;
}
    348e:	cf 93       	push	r28
    3490:	df 93       	push	r29
    3492:	dc 01       	movw	r26, r24
    3494:	0f b6       	in	r0, 0x3f	; 63
    3496:	f8 94       	cli
    3498:	0f 92       	push	r0
    349a:	1d 96       	adiw	r26, 0x0d	; 13
    349c:	2d 91       	ld	r18, X+
    349e:	3c 91       	ld	r19, X
    34a0:	1e 97       	sbiw	r26, 0x0e	; 14
    34a2:	0f 90       	pop	r0
    34a4:	0f be       	out	0x3f, r0	; 63
    34a6:	57 96       	adiw	r26, 0x17	; 23
    34a8:	8d 91       	ld	r24, X+
    34aa:	9c 91       	ld	r25, X
    34ac:	58 97       	sbiw	r26, 0x18	; 24
    34ae:	28 17       	cp	r18, r24
    34b0:	39 07       	cpc	r19, r25
    34b2:	f1 f0       	breq	.+60     	; 0x34f0 <xSerialPutChar+0x62>
    34b4:	fd 01       	movw	r30, r26
    34b6:	3d 96       	adiw	r30, 0x0d	; 13
    34b8:	c2 81       	ldd	r28, Z+2	; 0x02
    34ba:	d3 81       	ldd	r29, Z+3	; 0x03
    34bc:	68 83       	st	Y, r22
    34be:	82 81       	ldd	r24, Z+2	; 0x02
    34c0:	93 81       	ldd	r25, Z+3	; 0x03
    34c2:	01 96       	adiw	r24, 0x01	; 1
    34c4:	93 83       	std	Z+3, r25	; 0x03
    34c6:	82 83       	std	Z+2, r24	; 0x02
    34c8:	20 85       	ldd	r18, Z+8	; 0x08
    34ca:	31 85       	ldd	r19, Z+9	; 0x09
    34cc:	82 17       	cp	r24, r18
    34ce:	93 07       	cpc	r25, r19
    34d0:	21 f4       	brne	.+8      	; 0x34da <xSerialPutChar+0x4c>
    34d2:	86 81       	ldd	r24, Z+6	; 0x06
    34d4:	97 81       	ldd	r25, Z+7	; 0x07
    34d6:	93 83       	std	Z+3, r25	; 0x03
    34d8:	82 83       	std	Z+2, r24	; 0x02
    34da:	0f b6       	in	r0, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	0f 92       	push	r0
    34e0:	80 81       	ld	r24, Z
    34e2:	91 81       	ldd	r25, Z+1	; 0x01
    34e4:	01 96       	adiw	r24, 0x01	; 1
    34e6:	91 83       	std	Z+1, r25	; 0x01
    34e8:	80 83       	st	Z, r24
    34ea:	0f 90       	pop	r0
    34ec:	0f be       	out	0x3f, r0	; 63
    34ee:	37 c0       	rjmp	.+110    	; 0x355e <xSerialPutChar+0xd0>
    34f0:	2f ef       	ldi	r18, 0xFF	; 255
    34f2:	8f e8       	ldi	r24, 0x8F	; 143
    34f4:	91 e0       	ldi	r25, 0x01	; 1
    34f6:	21 50       	subi	r18, 0x01	; 1
    34f8:	80 40       	sbci	r24, 0x00	; 0
    34fa:	90 40       	sbci	r25, 0x00	; 0
    34fc:	e1 f7       	brne	.-8      	; 0x34f6 <xSerialPutChar+0x68>
    34fe:	00 c0       	rjmp	.+0      	; 0x3500 <xSerialPutChar+0x72>
    3500:	00 00       	nop
    3502:	0f b6       	in	r0, 0x3f	; 63
    3504:	f8 94       	cli
    3506:	0f 92       	push	r0
    3508:	1d 96       	adiw	r26, 0x0d	; 13
    350a:	2d 91       	ld	r18, X+
    350c:	3c 91       	ld	r19, X
    350e:	1e 97       	sbiw	r26, 0x0e	; 14
    3510:	0f 90       	pop	r0
    3512:	0f be       	out	0x3f, r0	; 63
    3514:	57 96       	adiw	r26, 0x17	; 23
    3516:	8d 91       	ld	r24, X+
    3518:	9c 91       	ld	r25, X
    351a:	58 97       	sbiw	r26, 0x18	; 24
    351c:	28 17       	cp	r18, r24
    351e:	39 07       	cpc	r19, r25
    3520:	09 f4       	brne	.+2      	; 0x3524 <xSerialPutChar+0x96>
    3522:	44 c0       	rjmp	.+136    	; 0x35ac <xSerialPutChar+0x11e>
    3524:	fd 01       	movw	r30, r26
    3526:	3d 96       	adiw	r30, 0x0d	; 13
    3528:	c2 81       	ldd	r28, Z+2	; 0x02
    352a:	d3 81       	ldd	r29, Z+3	; 0x03
    352c:	68 83       	st	Y, r22
    352e:	82 81       	ldd	r24, Z+2	; 0x02
    3530:	93 81       	ldd	r25, Z+3	; 0x03
    3532:	01 96       	adiw	r24, 0x01	; 1
    3534:	93 83       	std	Z+3, r25	; 0x03
    3536:	82 83       	std	Z+2, r24	; 0x02
    3538:	20 85       	ldd	r18, Z+8	; 0x08
    353a:	31 85       	ldd	r19, Z+9	; 0x09
    353c:	82 17       	cp	r24, r18
    353e:	93 07       	cpc	r25, r19
    3540:	21 f4       	brne	.+8      	; 0x354a <xSerialPutChar+0xbc>
    3542:	86 81       	ldd	r24, Z+6	; 0x06
    3544:	97 81       	ldd	r25, Z+7	; 0x07
    3546:	93 83       	std	Z+3, r25	; 0x03
    3548:	82 83       	std	Z+2, r24	; 0x02
    354a:	0f b6       	in	r0, 0x3f	; 63
    354c:	f8 94       	cli
    354e:	0f 92       	push	r0
    3550:	80 81       	ld	r24, Z
    3552:	91 81       	ldd	r25, Z+1	; 0x01
    3554:	01 96       	adiw	r24, 0x01	; 1
    3556:	91 83       	std	Z+1, r25	; 0x01
    3558:	80 83       	st	Z, r24
    355a:	0f 90       	pop	r0
    355c:	0f be       	out	0x3f, r0	; 63
    355e:	8c 91       	ld	r24, X
    3560:	90 e0       	ldi	r25, 0x00	; 0
    3562:	88 30       	cpi	r24, 0x08	; 8
    3564:	91 05       	cpc	r25, r1
    3566:	20 f5       	brcc	.+72     	; 0x35b0 <xSerialPutChar+0x122>
    3568:	fc 01       	movw	r30, r24
    356a:	88 27       	eor	r24, r24
    356c:	ee 58       	subi	r30, 0x8E	; 142
    356e:	ff 4f       	sbci	r31, 0xFF	; 255
    3570:	8f 4f       	sbci	r24, 0xFF	; 255
    3572:	0d c7       	rjmp	.+3610   	; 0x438e <__tablejump2__>
    3574:	e1 ec       	ldi	r30, 0xC1	; 193
    3576:	f0 e0       	ldi	r31, 0x00	; 0
    3578:	80 81       	ld	r24, Z
    357a:	80 62       	ori	r24, 0x20	; 32
    357c:	80 83       	st	Z, r24
    357e:	81 e0       	ldi	r24, 0x01	; 1
    3580:	18 c0       	rjmp	.+48     	; 0x35b2 <xSerialPutChar+0x124>
    3582:	e9 ec       	ldi	r30, 0xC9	; 201
    3584:	f0 e0       	ldi	r31, 0x00	; 0
    3586:	80 81       	ld	r24, Z
    3588:	80 62       	ori	r24, 0x20	; 32
    358a:	80 83       	st	Z, r24
    358c:	81 e0       	ldi	r24, 0x01	; 1
    358e:	11 c0       	rjmp	.+34     	; 0x35b2 <xSerialPutChar+0x124>
    3590:	e1 ed       	ldi	r30, 0xD1	; 209
    3592:	f0 e0       	ldi	r31, 0x00	; 0
    3594:	80 81       	ld	r24, Z
    3596:	80 62       	ori	r24, 0x20	; 32
    3598:	80 83       	st	Z, r24
    359a:	81 e0       	ldi	r24, 0x01	; 1
    359c:	0a c0       	rjmp	.+20     	; 0x35b2 <xSerialPutChar+0x124>
    359e:	e1 e3       	ldi	r30, 0x31	; 49
    35a0:	f1 e0       	ldi	r31, 0x01	; 1
    35a2:	80 81       	ld	r24, Z
    35a4:	80 62       	ori	r24, 0x20	; 32
    35a6:	80 83       	st	Z, r24
    35a8:	81 e0       	ldi	r24, 0x01	; 1
    35aa:	03 c0       	rjmp	.+6      	; 0x35b2 <xSerialPutChar+0x124>
    35ac:	80 e0       	ldi	r24, 0x00	; 0
    35ae:	01 c0       	rjmp	.+2      	; 0x35b2 <xSerialPutChar+0x124>
    35b0:	81 e0       	ldi	r24, 0x01	; 1
    35b2:	df 91       	pop	r29
    35b4:	cf 91       	pop	r28
    35b6:	08 95       	ret

000035b8 <xSerialPortInitMinimal>:
    35b8:	7f 92       	push	r7
    35ba:	8f 92       	push	r8
    35bc:	9f 92       	push	r9
    35be:	af 92       	push	r10
    35c0:	bf 92       	push	r11
    35c2:	cf 92       	push	r12
    35c4:	df 92       	push	r13
    35c6:	ef 92       	push	r14
    35c8:	ff 92       	push	r15
    35ca:	0f 93       	push	r16
    35cc:	1f 93       	push	r17
    35ce:	cf 93       	push	r28
    35d0:	df 93       	push	r29
    35d2:	cd b7       	in	r28, 0x3d	; 61
    35d4:	de b7       	in	r29, 0x3e	; 62
    35d6:	a2 97       	sbiw	r28, 0x22	; 34
    35d8:	0f b6       	in	r0, 0x3f	; 63
    35da:	f8 94       	cli
    35dc:	de bf       	out	0x3e, r29	; 62
    35de:	0f be       	out	0x3f, r0	; 63
    35e0:	cd bf       	out	0x3d, r28	; 61
    35e2:	6c 01       	movw	r12, r24
    35e4:	76 2e       	mov	r7, r22
    35e6:	49 01       	movw	r8, r18
    35e8:	5a 01       	movw	r10, r20
    35ea:	c7 01       	movw	r24, r14
    35ec:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <pvPortMalloc>
    35f0:	00 97       	sbiw	r24, 0x00	; 0
    35f2:	a9 f0       	breq	.+42     	; 0x361e <xSerialPortInitMinimal+0x66>
    35f4:	fe 01       	movw	r30, r28
    35f6:	32 96       	adiw	r30, 0x02	; 2
    35f8:	0f b6       	in	r0, 0x3f	; 63
    35fa:	f8 94       	cli
    35fc:	0f 92       	push	r0
    35fe:	11 82       	std	Z+1, r1	; 0x01
    3600:	10 82       	st	Z, r1
    3602:	93 83       	std	Z+3, r25	; 0x03
    3604:	82 83       	std	Z+2, r24	; 0x02
    3606:	95 83       	std	Z+5, r25	; 0x05
    3608:	84 83       	std	Z+4, r24	; 0x04
    360a:	97 83       	std	Z+7, r25	; 0x07
    360c:	86 83       	std	Z+6, r24	; 0x06
    360e:	8e 0d       	add	r24, r14
    3610:	9f 1d       	adc	r25, r15
    3612:	91 87       	std	Z+9, r25	; 0x09
    3614:	80 87       	std	Z+8, r24	; 0x08
    3616:	f3 86       	std	Z+11, r15	; 0x0b
    3618:	e2 86       	std	Z+10, r14	; 0x0a
    361a:	0f 90       	pop	r0
    361c:	0f be       	out	0x3f, r0	; 63
    361e:	c8 01       	movw	r24, r16
    3620:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <pvPortMalloc>
    3624:	00 97       	sbiw	r24, 0x00	; 0
    3626:	a9 f0       	breq	.+42     	; 0x3652 <xSerialPortInitMinimal+0x9a>
    3628:	fe 01       	movw	r30, r28
    362a:	3e 96       	adiw	r30, 0x0e	; 14
    362c:	0f b6       	in	r0, 0x3f	; 63
    362e:	f8 94       	cli
    3630:	0f 92       	push	r0
    3632:	11 82       	std	Z+1, r1	; 0x01
    3634:	10 82       	st	Z, r1
    3636:	93 83       	std	Z+3, r25	; 0x03
    3638:	82 83       	std	Z+2, r24	; 0x02
    363a:	95 83       	std	Z+5, r25	; 0x05
    363c:	84 83       	std	Z+4, r24	; 0x04
    363e:	97 83       	std	Z+7, r25	; 0x07
    3640:	86 83       	std	Z+6, r24	; 0x06
    3642:	80 0f       	add	r24, r16
    3644:	91 1f       	adc	r25, r17
    3646:	91 87       	std	Z+9, r25	; 0x09
    3648:	80 87       	std	Z+8, r24	; 0x08
    364a:	13 87       	std	Z+11, r17	; 0x0b
    364c:	02 87       	std	Z+10, r16	; 0x0a
    364e:	0f 90       	pop	r0
    3650:	0f be       	out	0x3f, r0	; 63
    3652:	c8 01       	movw	r24, r16
    3654:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <pvPortMalloc>
    3658:	9b 8f       	std	Y+27, r25	; 0x1b
    365a:	8a 8f       	std	Y+26, r24	; 0x1a
    365c:	79 82       	std	Y+1, r7	; 0x01
    365e:	1d 8f       	std	Y+29, r17	; 0x1d
    3660:	0c 8f       	std	Y+28, r16	; 0x1c
    3662:	1e 8e       	std	Y+30, r1	; 0x1e
    3664:	8f 8e       	std	Y+31, r8	; 0x1f
    3666:	98 a2       	std	Y+32, r9	; 0x20
    3668:	a9 a2       	std	Y+33, r10	; 0x21
    366a:	ba a2       	std	Y+34, r11	; 0x22
    366c:	0f b6       	in	r0, 0x3f	; 63
    366e:	f8 94       	cli
    3670:	0f 92       	push	r0
    3672:	89 81       	ldd	r24, Y+1	; 0x01
    3674:	90 e0       	ldi	r25, 0x00	; 0
    3676:	88 30       	cpi	r24, 0x08	; 8
    3678:	91 05       	cpc	r25, r1
    367a:	08 f0       	brcs	.+2      	; 0x367e <xSerialPortInitMinimal+0xc6>
    367c:	b1 c1       	rjmp	.+866    	; 0x39e0 <xSerialPortInitMinimal+0x428>
    367e:	fc 01       	movw	r30, r24
    3680:	88 27       	eor	r24, r24
    3682:	e6 58       	subi	r30, 0x86	; 134
    3684:	ff 4f       	sbci	r31, 0xFF	; 255
    3686:	8f 4f       	sbci	r24, 0xFF	; 255
    3688:	82 c6       	rjmp	.+3332   	; 0x438e <__tablejump2__>
    368a:	d5 01       	movw	r26, r10
    368c:	c4 01       	movw	r24, r8
    368e:	97 5f       	subi	r25, 0xF7	; 247
    3690:	a2 4c       	sbci	r26, 0xC2	; 194
    3692:	bf 4f       	sbci	r27, 0xFF	; 255
    3694:	bc 01       	movw	r22, r24
    3696:	cd 01       	movw	r24, r26
    3698:	66 0f       	add	r22, r22
    369a:	77 1f       	adc	r23, r23
    369c:	88 1f       	adc	r24, r24
    369e:	99 1f       	adc	r25, r25
    36a0:	66 0f       	add	r22, r22
    36a2:	77 1f       	adc	r23, r23
    36a4:	88 1f       	adc	r24, r24
    36a6:	99 1f       	adc	r25, r25
    36a8:	95 01       	movw	r18, r10
    36aa:	84 01       	movw	r16, r8
    36ac:	00 0f       	add	r16, r16
    36ae:	11 1f       	adc	r17, r17
    36b0:	22 1f       	adc	r18, r18
    36b2:	33 1f       	adc	r19, r19
    36b4:	00 0f       	add	r16, r16
    36b6:	11 1f       	adc	r17, r17
    36b8:	22 1f       	adc	r18, r18
    36ba:	33 1f       	adc	r19, r19
    36bc:	a9 01       	movw	r20, r18
    36be:	98 01       	movw	r18, r16
    36c0:	22 0f       	add	r18, r18
    36c2:	33 1f       	adc	r19, r19
    36c4:	44 1f       	adc	r20, r20
    36c6:	55 1f       	adc	r21, r21
    36c8:	24 d6       	rcall	.+3144   	; 0x4312 <__udivmodsi4>
    36ca:	21 50       	subi	r18, 0x01	; 1
    36cc:	31 09       	sbc	r19, r1
    36ce:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    36d2:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    36d6:	82 e0       	ldi	r24, 0x02	; 2
    36d8:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    36dc:	88 e9       	ldi	r24, 0x98	; 152
    36de:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    36e2:	8e e0       	ldi	r24, 0x0E	; 14
    36e4:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    36e8:	7b c1       	rjmp	.+758    	; 0x39e0 <xSerialPortInitMinimal+0x428>
    36ea:	04 ec       	ldi	r16, 0xC4	; 196
    36ec:	10 e0       	ldi	r17, 0x00	; 0
    36ee:	f8 01       	movw	r30, r16
    36f0:	11 82       	std	Z+1, r1	; 0x01
    36f2:	10 82       	st	Z, r1
    36f4:	6a 9a       	sbi	0x0d, 2	; 13
    36f6:	80 ec       	ldi	r24, 0xC0	; 192
    36f8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    36fc:	88 e9       	ldi	r24, 0x98	; 152
    36fe:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    3702:	d5 01       	movw	r26, r10
    3704:	c4 01       	movw	r24, r8
    3706:	80 58       	subi	r24, 0x80	; 128
    3708:	9b 47       	sbci	r25, 0x7B	; 123
    370a:	a1 4e       	sbci	r26, 0xE1	; 225
    370c:	bf 4f       	sbci	r27, 0xFF	; 255
    370e:	88 0f       	add	r24, r24
    3710:	99 1f       	adc	r25, r25
    3712:	aa 1f       	adc	r26, r26
    3714:	bb 1f       	adc	r27, r27
    3716:	88 0f       	add	r24, r24
    3718:	99 1f       	adc	r25, r25
    371a:	aa 1f       	adc	r26, r26
    371c:	bb 1f       	adc	r27, r27
    371e:	bc 01       	movw	r22, r24
    3720:	cd 01       	movw	r24, r26
    3722:	66 0f       	add	r22, r22
    3724:	77 1f       	adc	r23, r23
    3726:	88 1f       	adc	r24, r24
    3728:	99 1f       	adc	r25, r25
    372a:	88 0c       	add	r8, r8
    372c:	99 1c       	adc	r9, r9
    372e:	aa 1c       	adc	r10, r10
    3730:	bb 1c       	adc	r11, r11
    3732:	88 0c       	add	r8, r8
    3734:	99 1c       	adc	r9, r9
    3736:	aa 1c       	adc	r10, r10
    3738:	bb 1c       	adc	r11, r11
    373a:	a5 01       	movw	r20, r10
    373c:	94 01       	movw	r18, r8
    373e:	22 0f       	add	r18, r18
    3740:	33 1f       	adc	r19, r19
    3742:	44 1f       	adc	r20, r20
    3744:	55 1f       	adc	r21, r21
    3746:	22 0f       	add	r18, r18
    3748:	33 1f       	adc	r19, r19
    374a:	44 1f       	adc	r20, r20
    374c:	55 1f       	adc	r21, r21
    374e:	e1 d5       	rcall	.+3010   	; 0x4312 <__udivmodsi4>
    3750:	21 50       	subi	r18, 0x01	; 1
    3752:	31 09       	sbc	r19, r1
    3754:	f8 01       	movw	r30, r16
    3756:	31 83       	std	Z+1, r19	; 0x01
    3758:	20 83       	st	Z, r18
    375a:	42 c1       	rjmp	.+644    	; 0x39e0 <xSerialPortInitMinimal+0x428>
    375c:	d5 01       	movw	r26, r10
    375e:	c4 01       	movw	r24, r8
    3760:	97 5f       	subi	r25, 0xF7	; 247
    3762:	a2 4c       	sbci	r26, 0xC2	; 194
    3764:	bf 4f       	sbci	r27, 0xFF	; 255
    3766:	bc 01       	movw	r22, r24
    3768:	cd 01       	movw	r24, r26
    376a:	66 0f       	add	r22, r22
    376c:	77 1f       	adc	r23, r23
    376e:	88 1f       	adc	r24, r24
    3770:	99 1f       	adc	r25, r25
    3772:	66 0f       	add	r22, r22
    3774:	77 1f       	adc	r23, r23
    3776:	88 1f       	adc	r24, r24
    3778:	99 1f       	adc	r25, r25
    377a:	95 01       	movw	r18, r10
    377c:	84 01       	movw	r16, r8
    377e:	00 0f       	add	r16, r16
    3780:	11 1f       	adc	r17, r17
    3782:	22 1f       	adc	r18, r18
    3784:	33 1f       	adc	r19, r19
    3786:	00 0f       	add	r16, r16
    3788:	11 1f       	adc	r17, r17
    378a:	22 1f       	adc	r18, r18
    378c:	33 1f       	adc	r19, r19
    378e:	a9 01       	movw	r20, r18
    3790:	98 01       	movw	r18, r16
    3792:	22 0f       	add	r18, r18
    3794:	33 1f       	adc	r19, r19
    3796:	44 1f       	adc	r20, r20
    3798:	55 1f       	adc	r21, r21
    379a:	bb d5       	rcall	.+2934   	; 0x4312 <__udivmodsi4>
    379c:	21 50       	subi	r18, 0x01	; 1
    379e:	31 09       	sbc	r19, r1
    37a0:	30 93 cd 00 	sts	0x00CD, r19	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7000cd>
    37a4:	20 93 cc 00 	sts	0x00CC, r18	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7000cc>
    37a8:	82 e0       	ldi	r24, 0x02	; 2
    37aa:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    37ae:	88 e9       	ldi	r24, 0x98	; 152
    37b0:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    37b4:	8e e0       	ldi	r24, 0x0E	; 14
    37b6:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    37ba:	12 c1       	rjmp	.+548    	; 0x39e0 <xSerialPortInitMinimal+0x428>
    37bc:	0c ec       	ldi	r16, 0xCC	; 204
    37be:	10 e0       	ldi	r17, 0x00	; 0
    37c0:	f8 01       	movw	r30, r16
    37c2:	11 82       	std	Z+1, r1	; 0x01
    37c4:	10 82       	st	Z, r1
    37c6:	55 9a       	sbi	0x0a, 5	; 10
    37c8:	80 ec       	ldi	r24, 0xC0	; 192
    37ca:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7000ca>
    37ce:	88 e9       	ldi	r24, 0x98	; 152
    37d0:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7000c9>
    37d4:	d5 01       	movw	r26, r10
    37d6:	c4 01       	movw	r24, r8
    37d8:	80 58       	subi	r24, 0x80	; 128
    37da:	9b 47       	sbci	r25, 0x7B	; 123
    37dc:	a1 4e       	sbci	r26, 0xE1	; 225
    37de:	bf 4f       	sbci	r27, 0xFF	; 255
    37e0:	88 0f       	add	r24, r24
    37e2:	99 1f       	adc	r25, r25
    37e4:	aa 1f       	adc	r26, r26
    37e6:	bb 1f       	adc	r27, r27
    37e8:	88 0f       	add	r24, r24
    37ea:	99 1f       	adc	r25, r25
    37ec:	aa 1f       	adc	r26, r26
    37ee:	bb 1f       	adc	r27, r27
    37f0:	bc 01       	movw	r22, r24
    37f2:	cd 01       	movw	r24, r26
    37f4:	66 0f       	add	r22, r22
    37f6:	77 1f       	adc	r23, r23
    37f8:	88 1f       	adc	r24, r24
    37fa:	99 1f       	adc	r25, r25
    37fc:	88 0c       	add	r8, r8
    37fe:	99 1c       	adc	r9, r9
    3800:	aa 1c       	adc	r10, r10
    3802:	bb 1c       	adc	r11, r11
    3804:	88 0c       	add	r8, r8
    3806:	99 1c       	adc	r9, r9
    3808:	aa 1c       	adc	r10, r10
    380a:	bb 1c       	adc	r11, r11
    380c:	a5 01       	movw	r20, r10
    380e:	94 01       	movw	r18, r8
    3810:	22 0f       	add	r18, r18
    3812:	33 1f       	adc	r19, r19
    3814:	44 1f       	adc	r20, r20
    3816:	55 1f       	adc	r21, r21
    3818:	22 0f       	add	r18, r18
    381a:	33 1f       	adc	r19, r19
    381c:	44 1f       	adc	r20, r20
    381e:	55 1f       	adc	r21, r21
    3820:	78 d5       	rcall	.+2800   	; 0x4312 <__udivmodsi4>
    3822:	21 50       	subi	r18, 0x01	; 1
    3824:	31 09       	sbc	r19, r1
    3826:	f8 01       	movw	r30, r16
    3828:	31 83       	std	Z+1, r19	; 0x01
    382a:	20 83       	st	Z, r18
    382c:	d9 c0       	rjmp	.+434    	; 0x39e0 <xSerialPortInitMinimal+0x428>
    382e:	d5 01       	movw	r26, r10
    3830:	c4 01       	movw	r24, r8
    3832:	97 5f       	subi	r25, 0xF7	; 247
    3834:	a2 4c       	sbci	r26, 0xC2	; 194
    3836:	bf 4f       	sbci	r27, 0xFF	; 255
    3838:	bc 01       	movw	r22, r24
    383a:	cd 01       	movw	r24, r26
    383c:	66 0f       	add	r22, r22
    383e:	77 1f       	adc	r23, r23
    3840:	88 1f       	adc	r24, r24
    3842:	99 1f       	adc	r25, r25
    3844:	66 0f       	add	r22, r22
    3846:	77 1f       	adc	r23, r23
    3848:	88 1f       	adc	r24, r24
    384a:	99 1f       	adc	r25, r25
    384c:	95 01       	movw	r18, r10
    384e:	84 01       	movw	r16, r8
    3850:	00 0f       	add	r16, r16
    3852:	11 1f       	adc	r17, r17
    3854:	22 1f       	adc	r18, r18
    3856:	33 1f       	adc	r19, r19
    3858:	00 0f       	add	r16, r16
    385a:	11 1f       	adc	r17, r17
    385c:	22 1f       	adc	r18, r18
    385e:	33 1f       	adc	r19, r19
    3860:	a9 01       	movw	r20, r18
    3862:	98 01       	movw	r18, r16
    3864:	22 0f       	add	r18, r18
    3866:	33 1f       	adc	r19, r19
    3868:	44 1f       	adc	r20, r20
    386a:	55 1f       	adc	r21, r21
    386c:	52 d5       	rcall	.+2724   	; 0x4312 <__udivmodsi4>
    386e:	21 50       	subi	r18, 0x01	; 1
    3870:	31 09       	sbc	r19, r1
    3872:	30 93 d5 00 	sts	0x00D5, r19	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    3876:	20 93 d4 00 	sts	0x00D4, r18	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    387a:	82 e0       	ldi	r24, 0x02	; 2
    387c:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3880:	88 e9       	ldi	r24, 0x98	; 152
    3882:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    3886:	8e e0       	ldi	r24, 0x0E	; 14
    3888:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    388c:	a9 c0       	rjmp	.+338    	; 0x39e0 <xSerialPortInitMinimal+0x428>
    388e:	04 ed       	ldi	r16, 0xD4	; 212
    3890:	10 e0       	ldi	r17, 0x00	; 0
    3892:	f8 01       	movw	r30, r16
    3894:	11 82       	std	Z+1, r1	; 0x01
    3896:	10 82       	st	Z, r1
    3898:	e1 e0       	ldi	r30, 0x01	; 1
    389a:	f1 e0       	ldi	r31, 0x01	; 1
    389c:	80 81       	ld	r24, Z
    389e:	84 60       	ori	r24, 0x04	; 4
    38a0:	80 83       	st	Z, r24
    38a2:	80 ec       	ldi	r24, 0xC0	; 192
    38a4:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7000d2>
    38a8:	88 e9       	ldi	r24, 0x98	; 152
    38aa:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>
    38ae:	d5 01       	movw	r26, r10
    38b0:	c4 01       	movw	r24, r8
    38b2:	80 58       	subi	r24, 0x80	; 128
    38b4:	9b 47       	sbci	r25, 0x7B	; 123
    38b6:	a1 4e       	sbci	r26, 0xE1	; 225
    38b8:	bf 4f       	sbci	r27, 0xFF	; 255
    38ba:	88 0f       	add	r24, r24
    38bc:	99 1f       	adc	r25, r25
    38be:	aa 1f       	adc	r26, r26
    38c0:	bb 1f       	adc	r27, r27
    38c2:	88 0f       	add	r24, r24
    38c4:	99 1f       	adc	r25, r25
    38c6:	aa 1f       	adc	r26, r26
    38c8:	bb 1f       	adc	r27, r27
    38ca:	bc 01       	movw	r22, r24
    38cc:	cd 01       	movw	r24, r26
    38ce:	66 0f       	add	r22, r22
    38d0:	77 1f       	adc	r23, r23
    38d2:	88 1f       	adc	r24, r24
    38d4:	99 1f       	adc	r25, r25
    38d6:	88 0c       	add	r8, r8
    38d8:	99 1c       	adc	r9, r9
    38da:	aa 1c       	adc	r10, r10
    38dc:	bb 1c       	adc	r11, r11
    38de:	88 0c       	add	r8, r8
    38e0:	99 1c       	adc	r9, r9
    38e2:	aa 1c       	adc	r10, r10
    38e4:	bb 1c       	adc	r11, r11
    38e6:	a5 01       	movw	r20, r10
    38e8:	94 01       	movw	r18, r8
    38ea:	22 0f       	add	r18, r18
    38ec:	33 1f       	adc	r19, r19
    38ee:	44 1f       	adc	r20, r20
    38f0:	55 1f       	adc	r21, r21
    38f2:	22 0f       	add	r18, r18
    38f4:	33 1f       	adc	r19, r19
    38f6:	44 1f       	adc	r20, r20
    38f8:	55 1f       	adc	r21, r21
    38fa:	0b d5       	rcall	.+2582   	; 0x4312 <__udivmodsi4>
    38fc:	21 50       	subi	r18, 0x01	; 1
    38fe:	31 09       	sbc	r19, r1
    3900:	f8 01       	movw	r30, r16
    3902:	31 83       	std	Z+1, r19	; 0x01
    3904:	20 83       	st	Z, r18
    3906:	6c c0       	rjmp	.+216    	; 0x39e0 <xSerialPortInitMinimal+0x428>
    3908:	d5 01       	movw	r26, r10
    390a:	c4 01       	movw	r24, r8
    390c:	97 5f       	subi	r25, 0xF7	; 247
    390e:	a2 4c       	sbci	r26, 0xC2	; 194
    3910:	bf 4f       	sbci	r27, 0xFF	; 255
    3912:	bc 01       	movw	r22, r24
    3914:	cd 01       	movw	r24, r26
    3916:	66 0f       	add	r22, r22
    3918:	77 1f       	adc	r23, r23
    391a:	88 1f       	adc	r24, r24
    391c:	99 1f       	adc	r25, r25
    391e:	66 0f       	add	r22, r22
    3920:	77 1f       	adc	r23, r23
    3922:	88 1f       	adc	r24, r24
    3924:	99 1f       	adc	r25, r25
    3926:	95 01       	movw	r18, r10
    3928:	84 01       	movw	r16, r8
    392a:	00 0f       	add	r16, r16
    392c:	11 1f       	adc	r17, r17
    392e:	22 1f       	adc	r18, r18
    3930:	33 1f       	adc	r19, r19
    3932:	00 0f       	add	r16, r16
    3934:	11 1f       	adc	r17, r17
    3936:	22 1f       	adc	r18, r18
    3938:	33 1f       	adc	r19, r19
    393a:	a9 01       	movw	r20, r18
    393c:	98 01       	movw	r18, r16
    393e:	22 0f       	add	r18, r18
    3940:	33 1f       	adc	r19, r19
    3942:	44 1f       	adc	r20, r20
    3944:	55 1f       	adc	r21, r21
    3946:	e5 d4       	rcall	.+2506   	; 0x4312 <__udivmodsi4>
    3948:	21 50       	subi	r18, 0x01	; 1
    394a:	31 09       	sbc	r19, r1
    394c:	30 93 35 01 	sts	0x0135, r19	; 0x800135 <__TEXT_REGION_LENGTH__+0x700135>
    3950:	20 93 34 01 	sts	0x0134, r18	; 0x800134 <__TEXT_REGION_LENGTH__+0x700134>
    3954:	82 e0       	ldi	r24, 0x02	; 2
    3956:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    395a:	88 e9       	ldi	r24, 0x98	; 152
    395c:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    3960:	8e e0       	ldi	r24, 0x0E	; 14
    3962:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    3966:	3c c0       	rjmp	.+120    	; 0x39e0 <xSerialPortInitMinimal+0x428>
    3968:	04 e3       	ldi	r16, 0x34	; 52
    396a:	11 e0       	ldi	r17, 0x01	; 1
    396c:	f8 01       	movw	r30, r16
    396e:	11 82       	std	Z+1, r1	; 0x01
    3970:	10 82       	st	Z, r1
    3972:	e4 e0       	ldi	r30, 0x04	; 4
    3974:	f1 e0       	ldi	r31, 0x01	; 1
    3976:	80 81       	ld	r24, Z
    3978:	84 60       	ori	r24, 0x04	; 4
    397a:	80 83       	st	Z, r24
    397c:	80 ec       	ldi	r24, 0xC0	; 192
    397e:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x700132>
    3982:	88 e9       	ldi	r24, 0x98	; 152
    3984:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x700131>
    3988:	d5 01       	movw	r26, r10
    398a:	c4 01       	movw	r24, r8
    398c:	80 58       	subi	r24, 0x80	; 128
    398e:	9b 47       	sbci	r25, 0x7B	; 123
    3990:	a1 4e       	sbci	r26, 0xE1	; 225
    3992:	bf 4f       	sbci	r27, 0xFF	; 255
    3994:	88 0f       	add	r24, r24
    3996:	99 1f       	adc	r25, r25
    3998:	aa 1f       	adc	r26, r26
    399a:	bb 1f       	adc	r27, r27
    399c:	88 0f       	add	r24, r24
    399e:	99 1f       	adc	r25, r25
    39a0:	aa 1f       	adc	r26, r26
    39a2:	bb 1f       	adc	r27, r27
    39a4:	bc 01       	movw	r22, r24
    39a6:	cd 01       	movw	r24, r26
    39a8:	66 0f       	add	r22, r22
    39aa:	77 1f       	adc	r23, r23
    39ac:	88 1f       	adc	r24, r24
    39ae:	99 1f       	adc	r25, r25
    39b0:	88 0c       	add	r8, r8
    39b2:	99 1c       	adc	r9, r9
    39b4:	aa 1c       	adc	r10, r10
    39b6:	bb 1c       	adc	r11, r11
    39b8:	88 0c       	add	r8, r8
    39ba:	99 1c       	adc	r9, r9
    39bc:	aa 1c       	adc	r10, r10
    39be:	bb 1c       	adc	r11, r11
    39c0:	a5 01       	movw	r20, r10
    39c2:	94 01       	movw	r18, r8
    39c4:	22 0f       	add	r18, r18
    39c6:	33 1f       	adc	r19, r19
    39c8:	44 1f       	adc	r20, r20
    39ca:	55 1f       	adc	r21, r21
    39cc:	22 0f       	add	r18, r18
    39ce:	33 1f       	adc	r19, r19
    39d0:	44 1f       	adc	r20, r20
    39d2:	55 1f       	adc	r21, r21
    39d4:	9e d4       	rcall	.+2364   	; 0x4312 <__udivmodsi4>
    39d6:	21 50       	subi	r18, 0x01	; 1
    39d8:	31 09       	sbc	r19, r1
    39da:	f8 01       	movw	r30, r16
    39dc:	31 83       	std	Z+1, r19	; 0x01
    39de:	20 83       	st	Z, r18
    39e0:	0f 90       	pop	r0
    39e2:	0f be       	out	0x3f, r0	; 63
    39e4:	82 e2       	ldi	r24, 0x22	; 34
    39e6:	fe 01       	movw	r30, r28
    39e8:	31 96       	adiw	r30, 0x01	; 1
    39ea:	d6 01       	movw	r26, r12
    39ec:	01 90       	ld	r0, Z+
    39ee:	0d 92       	st	X+, r0
    39f0:	8a 95       	dec	r24
    39f2:	e1 f7       	brne	.-8      	; 0x39ec <xSerialPortInitMinimal+0x434>
    39f4:	c6 01       	movw	r24, r12
    39f6:	a2 96       	adiw	r28, 0x22	; 34
    39f8:	0f b6       	in	r0, 0x3f	; 63
    39fa:	f8 94       	cli
    39fc:	de bf       	out	0x3e, r29	; 62
    39fe:	0f be       	out	0x3f, r0	; 63
    3a00:	cd bf       	out	0x3d, r28	; 61
    3a02:	df 91       	pop	r29
    3a04:	cf 91       	pop	r28
    3a06:	1f 91       	pop	r17
    3a08:	0f 91       	pop	r16
    3a0a:	ff 90       	pop	r15
    3a0c:	ef 90       	pop	r14
    3a0e:	df 90       	pop	r13
    3a10:	cf 90       	pop	r12
    3a12:	bf 90       	pop	r11
    3a14:	af 90       	pop	r10
    3a16:	9f 90       	pop	r9
    3a18:	8f 90       	pop	r8
    3a1a:	7f 90       	pop	r7
    3a1c:	08 95       	ret

00003a1e <__vector_25>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART0_RX_vect )

#endif
{
    3a1e:	1f 92       	push	r1
    3a20:	0f 92       	push	r0
    3a22:	0f b6       	in	r0, 0x3f	; 63
    3a24:	0f 92       	push	r0
    3a26:	11 24       	eor	r1, r1
    3a28:	0b b6       	in	r0, 0x3b	; 59
    3a2a:	0f 92       	push	r0
    3a2c:	2f 93       	push	r18
    3a2e:	3f 93       	push	r19
    3a30:	4f 93       	push	r20
    3a32:	8f 93       	push	r24
    3a34:	9f 93       	push	r25
    3a36:	af 93       	push	r26
    3a38:	bf 93       	push	r27
    3a3a:	ef 93       	push	r30
    3a3c:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR0A & (_BV(FE0)|_BV(DOR0)|_BV(UPE0)) ) )
    3a3e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    3a42:	8c 71       	andi	r24, 0x1C	; 28
    3a44:	71 f0       	breq	.+28     	; 0x3a62 <__vector_25+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR0A & (1<<RXC0) ) erroredByte = UDR0;
    3a46:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    3a4a:	88 23       	and	r24, r24
    3a4c:	0c f0       	brlt	.+2      	; 0x3a50 <__vector_25+0x32>
    3a4e:	36 c0       	rjmp	.+108    	; 0x3abc <__vector_25+0x9e>
    3a50:	a6 ec       	ldi	r26, 0xC6	; 198
    3a52:	b0 e0       	ldi	r27, 0x00	; 0
    3a54:	e0 ec       	ldi	r30, 0xC0	; 192
    3a56:	f0 e0       	ldi	r31, 0x00	; 0
    3a58:	8c 91       	ld	r24, X
    3a5a:	80 81       	ld	r24, Z
    3a5c:	88 23       	and	r24, r24
    3a5e:	e4 f3       	brlt	.-8      	; 0x3a58 <__vector_25+0x3a>
    3a60:	2d c0       	rjmp	.+90     	; 0x3abc <__vector_25+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR0;
    3a62:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3a66:	0f b6       	in	r0, 0x3f	; 63
    3a68:	f8 94       	cli
    3a6a:	0f 92       	push	r0
	{
	    count = buffer->count;
    3a6c:	ed ec       	ldi	r30, 0xCD	; 205
    3a6e:	f5 e1       	ldi	r31, 0x15	; 21
    3a70:	21 81       	ldd	r18, Z+1	; 0x01
    3a72:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3a74:	0f 90       	pop	r0
    3a76:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerialPort.xRxedChars) ) )
    3a78:	83 85       	ldd	r24, Z+11	; 0x0b
    3a7a:	94 85       	ldd	r25, Z+12	; 0x0c
    3a7c:	28 17       	cp	r18, r24
    3a7e:	39 07       	cpc	r19, r25
    3a80:	e9 f0       	breq	.+58     	; 0x3abc <__vector_25+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3a82:	ee ec       	ldi	r30, 0xCE	; 206
    3a84:	f5 e1       	ldi	r31, 0x15	; 21

	*buffer->in = data;
    3a86:	a2 81       	ldd	r26, Z+2	; 0x02
    3a88:	b3 81       	ldd	r27, Z+3	; 0x03
    3a8a:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3a8c:	82 81       	ldd	r24, Z+2	; 0x02
    3a8e:	93 81       	ldd	r25, Z+3	; 0x03
    3a90:	01 96       	adiw	r24, 0x01	; 1
    3a92:	93 83       	std	Z+3, r25	; 0x03
    3a94:	82 83       	std	Z+2, r24	; 0x02
    3a96:	20 85       	ldd	r18, Z+8	; 0x08
    3a98:	31 85       	ldd	r19, Z+9	; 0x09
    3a9a:	82 17       	cp	r24, r18
    3a9c:	93 07       	cpc	r25, r19
    3a9e:	21 f4       	brne	.+8      	; 0x3aa8 <__vector_25+0x8a>
	  buffer->in = buffer->start;
    3aa0:	86 81       	ldd	r24, Z+6	; 0x06
    3aa2:	97 81       	ldd	r25, Z+7	; 0x07
    3aa4:	93 83       	std	Z+3, r25	; 0x03
    3aa6:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3aa8:	0f b6       	in	r0, 0x3f	; 63
    3aaa:	f8 94       	cli
    3aac:	0f 92       	push	r0
	{
	    buffer->count++;
    3aae:	80 81       	ld	r24, Z
    3ab0:	91 81       	ldd	r25, Z+1	; 0x01
    3ab2:	01 96       	adiw	r24, 0x01	; 1
    3ab4:	91 83       	std	Z+1, r25	; 0x01
    3ab6:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3ab8:	0f 90       	pop	r0
    3aba:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerialPort.xRxedChars), cChar);
	}
}
    3abc:	ff 91       	pop	r31
    3abe:	ef 91       	pop	r30
    3ac0:	bf 91       	pop	r27
    3ac2:	af 91       	pop	r26
    3ac4:	9f 91       	pop	r25
    3ac6:	8f 91       	pop	r24
    3ac8:	4f 91       	pop	r20
    3aca:	3f 91       	pop	r19
    3acc:	2f 91       	pop	r18
    3ace:	0f 90       	pop	r0
    3ad0:	0b be       	out	0x3b, r0	; 59
    3ad2:	0f 90       	pop	r0
    3ad4:	0f be       	out	0x3f, r0	; 63
    3ad6:	0f 90       	pop	r0
    3ad8:	1f 90       	pop	r1
    3ada:	18 95       	reti

00003adc <__vector_26>:
#elif defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
ISR( USART0_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART0_UDRE_vect )

#endif
{
    3adc:	1f 92       	push	r1
    3ade:	0f 92       	push	r0
    3ae0:	0f b6       	in	r0, 0x3f	; 63
    3ae2:	0f 92       	push	r0
    3ae4:	11 24       	eor	r1, r1
    3ae6:	0b b6       	in	r0, 0x3b	; 59
    3ae8:	0f 92       	push	r0
    3aea:	2f 93       	push	r18
    3aec:	8f 93       	push	r24
    3aee:	9f 93       	push	r25
    3af0:	af 93       	push	r26
    3af2:	bf 93       	push	r27
    3af4:	ef 93       	push	r30
    3af6:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3af8:	0f b6       	in	r0, 0x3f	; 63
    3afa:	f8 94       	cli
    3afc:	0f 92       	push	r0
	{
	    count = buffer->count;
    3afe:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <xSerialPort+0xd>
    3b02:	90 91 db 15 	lds	r25, 0x15DB	; 0x8015db <xSerialPort+0xe>
	}
	portEXIT_CRITICAL();
    3b06:	0f 90       	pop	r0
    3b08:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerialPort.xCharsForTx) ) )
    3b0a:	89 2b       	or	r24, r25
    3b0c:	31 f4       	brne	.+12     	; 0x3b1a <__vector_26+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt0_Off();
    3b0e:	e1 ec       	ldi	r30, 0xC1	; 193
    3b10:	f0 e0       	ldi	r31, 0x00	; 0
    3b12:	80 81       	ld	r24, Z
    3b14:	8f 7d       	andi	r24, 0xDF	; 223
    3b16:	80 83       	st	Z, r24
    3b18:	1c c0       	rjmp	.+56     	; 0x3b52 <__vector_26+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3b1a:	ea ed       	ldi	r30, 0xDA	; 218
    3b1c:	f5 e1       	ldi	r31, 0x15	; 21

	uint8_t data = *buffer->out;
    3b1e:	a4 81       	ldd	r26, Z+4	; 0x04
    3b20:	b5 81       	ldd	r27, Z+5	; 0x05
    3b22:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3b24:	b5 83       	std	Z+5, r27	; 0x05
    3b26:	a4 83       	std	Z+4, r26	; 0x04
    3b28:	80 85       	ldd	r24, Z+8	; 0x08
    3b2a:	91 85       	ldd	r25, Z+9	; 0x09
    3b2c:	a8 17       	cp	r26, r24
    3b2e:	b9 07       	cpc	r27, r25
    3b30:	21 f4       	brne	.+8      	; 0x3b3a <__vector_26+0x5e>
	  buffer->out = buffer->start;
    3b32:	86 81       	ldd	r24, Z+6	; 0x06
    3b34:	97 81       	ldd	r25, Z+7	; 0x07
    3b36:	95 83       	std	Z+5, r25	; 0x05
    3b38:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3b3a:	0f b6       	in	r0, 0x3f	; 63
    3b3c:	f8 94       	cli
    3b3e:	0f 92       	push	r0
	{
	    buffer->count--;
    3b40:	80 81       	ld	r24, Z
    3b42:	91 81       	ldd	r25, Z+1	; 0x01
    3b44:	01 97       	sbiw	r24, 0x01	; 1
    3b46:	91 83       	std	Z+1, r25	; 0x01
    3b48:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3b4a:	0f 90       	pop	r0
    3b4c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR0 = ringBuffer_Pop( (ringBuffer_t*) &(xSerialPort.xCharsForTx) );
    3b4e:	20 93 c6 00 	sts	0x00C6, r18	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
	}
}
    3b52:	ff 91       	pop	r31
    3b54:	ef 91       	pop	r30
    3b56:	bf 91       	pop	r27
    3b58:	af 91       	pop	r26
    3b5a:	9f 91       	pop	r25
    3b5c:	8f 91       	pop	r24
    3b5e:	2f 91       	pop	r18
    3b60:	0f 90       	pop	r0
    3b62:	0b be       	out	0x3b, r0	; 59
    3b64:	0f 90       	pop	r0
    3b66:	0f be       	out	0x3f, r0	; 63
    3b68:	0f 90       	pop	r0
    3b6a:	1f 90       	pop	r1
    3b6c:	18 95       	reti

00003b6e <__vector_36>:

#if defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART1_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART1_RX_vect )
{
    3b6e:	1f 92       	push	r1
    3b70:	0f 92       	push	r0
    3b72:	0f b6       	in	r0, 0x3f	; 63
    3b74:	0f 92       	push	r0
    3b76:	11 24       	eor	r1, r1
    3b78:	0b b6       	in	r0, 0x3b	; 59
    3b7a:	0f 92       	push	r0
    3b7c:	2f 93       	push	r18
    3b7e:	3f 93       	push	r19
    3b80:	4f 93       	push	r20
    3b82:	8f 93       	push	r24
    3b84:	9f 93       	push	r25
    3b86:	af 93       	push	r26
    3b88:	bf 93       	push	r27
    3b8a:	ef 93       	push	r30
    3b8c:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR1A &  (_BV(FE1)|_BV(DOR1)|_BV(UPE1)) ) )
    3b8e:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    3b92:	8c 71       	andi	r24, 0x1C	; 28
    3b94:	71 f0       	breq	.+28     	; 0x3bb2 <__vector_36+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR1A & (1<<RXC1) ) erroredByte = UDR1;
    3b96:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7000c8>
    3b9a:	88 23       	and	r24, r24
    3b9c:	0c f0       	brlt	.+2      	; 0x3ba0 <__vector_36+0x32>
    3b9e:	36 c0       	rjmp	.+108    	; 0x3c0c <__vector_36+0x9e>
    3ba0:	ae ec       	ldi	r26, 0xCE	; 206
    3ba2:	b0 e0       	ldi	r27, 0x00	; 0
    3ba4:	e8 ec       	ldi	r30, 0xC8	; 200
    3ba6:	f0 e0       	ldi	r31, 0x00	; 0
    3ba8:	8c 91       	ld	r24, X
    3baa:	80 81       	ld	r24, Z
    3bac:	88 23       	and	r24, r24
    3bae:	e4 f3       	brlt	.-8      	; 0x3ba8 <__vector_36+0x3a>
    3bb0:	2d c0       	rjmp	.+90     	; 0x3c0c <__vector_36+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR1;
    3bb2:	40 91 ce 00 	lds	r20, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3bb6:	0f b6       	in	r0, 0x3f	; 63
    3bb8:	f8 94       	cli
    3bba:	0f 92       	push	r0
	{
	    count = buffer->count;
    3bbc:	e7 e7       	ldi	r30, 0x77	; 119
    3bbe:	f6 e1       	ldi	r31, 0x16	; 22
    3bc0:	21 81       	ldd	r18, Z+1	; 0x01
    3bc2:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3bc4:	0f 90       	pop	r0
    3bc6:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial1Port.xRxedChars) ) )
    3bc8:	83 85       	ldd	r24, Z+11	; 0x0b
    3bca:	94 85       	ldd	r25, Z+12	; 0x0c
    3bcc:	28 17       	cp	r18, r24
    3bce:	39 07       	cpc	r19, r25
    3bd0:	e9 f0       	breq	.+58     	; 0x3c0c <__vector_36+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3bd2:	e8 e7       	ldi	r30, 0x78	; 120
    3bd4:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3bd6:	a2 81       	ldd	r26, Z+2	; 0x02
    3bd8:	b3 81       	ldd	r27, Z+3	; 0x03
    3bda:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3bdc:	82 81       	ldd	r24, Z+2	; 0x02
    3bde:	93 81       	ldd	r25, Z+3	; 0x03
    3be0:	01 96       	adiw	r24, 0x01	; 1
    3be2:	93 83       	std	Z+3, r25	; 0x03
    3be4:	82 83       	std	Z+2, r24	; 0x02
    3be6:	20 85       	ldd	r18, Z+8	; 0x08
    3be8:	31 85       	ldd	r19, Z+9	; 0x09
    3bea:	82 17       	cp	r24, r18
    3bec:	93 07       	cpc	r25, r19
    3bee:	21 f4       	brne	.+8      	; 0x3bf8 <__vector_36+0x8a>
	  buffer->in = buffer->start;
    3bf0:	86 81       	ldd	r24, Z+6	; 0x06
    3bf2:	97 81       	ldd	r25, Z+7	; 0x07
    3bf4:	93 83       	std	Z+3, r25	; 0x03
    3bf6:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3bf8:	0f b6       	in	r0, 0x3f	; 63
    3bfa:	f8 94       	cli
    3bfc:	0f 92       	push	r0
	{
	    buffer->count++;
    3bfe:	80 81       	ld	r24, Z
    3c00:	91 81       	ldd	r25, Z+1	; 0x01
    3c02:	01 96       	adiw	r24, 0x01	; 1
    3c04:	91 83       	std	Z+1, r25	; 0x01
    3c06:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3c08:	0f 90       	pop	r0
    3c0a:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial1Port.xRxedChars), cChar);
	}
}
    3c0c:	ff 91       	pop	r31
    3c0e:	ef 91       	pop	r30
    3c10:	bf 91       	pop	r27
    3c12:	af 91       	pop	r26
    3c14:	9f 91       	pop	r25
    3c16:	8f 91       	pop	r24
    3c18:	4f 91       	pop	r20
    3c1a:	3f 91       	pop	r19
    3c1c:	2f 91       	pop	r18
    3c1e:	0f 90       	pop	r0
    3c20:	0b be       	out	0x3b, r0	; 59
    3c22:	0f 90       	pop	r0
    3c24:	0f be       	out	0x3f, r0	; 63
    3c26:	0f 90       	pop	r0
    3c28:	1f 90       	pop	r1
    3c2a:	18 95       	reti

00003c2c <__vector_37>:
/*-----------------------------------------------------------*/

ISR( USART1_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART1_UDRE_vect )
{
    3c2c:	1f 92       	push	r1
    3c2e:	0f 92       	push	r0
    3c30:	0f b6       	in	r0, 0x3f	; 63
    3c32:	0f 92       	push	r0
    3c34:	11 24       	eor	r1, r1
    3c36:	0b b6       	in	r0, 0x3b	; 59
    3c38:	0f 92       	push	r0
    3c3a:	2f 93       	push	r18
    3c3c:	8f 93       	push	r24
    3c3e:	9f 93       	push	r25
    3c40:	af 93       	push	r26
    3c42:	bf 93       	push	r27
    3c44:	ef 93       	push	r30
    3c46:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3c48:	0f b6       	in	r0, 0x3f	; 63
    3c4a:	f8 94       	cli
    3c4c:	0f 92       	push	r0
	{
	    count = buffer->count;
    3c4e:	80 91 84 16 	lds	r24, 0x1684	; 0x801684 <xSerial1Port+0xd>
    3c52:	90 91 85 16 	lds	r25, 0x1685	; 0x801685 <xSerial1Port+0xe>
	}
	portEXIT_CRITICAL();
    3c56:	0f 90       	pop	r0
    3c58:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) ) )
    3c5a:	89 2b       	or	r24, r25
    3c5c:	31 f4       	brne	.+12     	; 0x3c6a <__vector_37+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt1_Off();
    3c5e:	e9 ec       	ldi	r30, 0xC9	; 201
    3c60:	f0 e0       	ldi	r31, 0x00	; 0
    3c62:	80 81       	ld	r24, Z
    3c64:	8f 7d       	andi	r24, 0xDF	; 223
    3c66:	80 83       	st	Z, r24
    3c68:	1c c0       	rjmp	.+56     	; 0x3ca2 <__vector_37+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3c6a:	e4 e8       	ldi	r30, 0x84	; 132
    3c6c:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    3c6e:	a4 81       	ldd	r26, Z+4	; 0x04
    3c70:	b5 81       	ldd	r27, Z+5	; 0x05
    3c72:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3c74:	b5 83       	std	Z+5, r27	; 0x05
    3c76:	a4 83       	std	Z+4, r26	; 0x04
    3c78:	80 85       	ldd	r24, Z+8	; 0x08
    3c7a:	91 85       	ldd	r25, Z+9	; 0x09
    3c7c:	a8 17       	cp	r26, r24
    3c7e:	b9 07       	cpc	r27, r25
    3c80:	21 f4       	brne	.+8      	; 0x3c8a <__vector_37+0x5e>
	  buffer->out = buffer->start;
    3c82:	86 81       	ldd	r24, Z+6	; 0x06
    3c84:	97 81       	ldd	r25, Z+7	; 0x07
    3c86:	95 83       	std	Z+5, r25	; 0x05
    3c88:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3c8a:	0f b6       	in	r0, 0x3f	; 63
    3c8c:	f8 94       	cli
    3c8e:	0f 92       	push	r0
	{
	    buffer->count--;
    3c90:	80 81       	ld	r24, Z
    3c92:	91 81       	ldd	r25, Z+1	; 0x01
    3c94:	01 97       	sbiw	r24, 0x01	; 1
    3c96:	91 83       	std	Z+1, r25	; 0x01
    3c98:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3c9a:	0f 90       	pop	r0
    3c9c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR1 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial1Port.xCharsForTx) );
    3c9e:	20 93 ce 00 	sts	0x00CE, r18	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7000ce>
	}
}
    3ca2:	ff 91       	pop	r31
    3ca4:	ef 91       	pop	r30
    3ca6:	bf 91       	pop	r27
    3ca8:	af 91       	pop	r26
    3caa:	9f 91       	pop	r25
    3cac:	8f 91       	pop	r24
    3cae:	2f 91       	pop	r18
    3cb0:	0f 90       	pop	r0
    3cb2:	0b be       	out	0x3b, r0	; 59
    3cb4:	0f 90       	pop	r0
    3cb6:	0f be       	out	0x3f, r0	; 63
    3cb8:	0f 90       	pop	r0
    3cba:	1f 90       	pop	r1
    3cbc:	18 95       	reti

00003cbe <__vector_51>:

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

ISR( USART2_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART2_RX_vect )
{
    3cbe:	1f 92       	push	r1
    3cc0:	0f 92       	push	r0
    3cc2:	0f b6       	in	r0, 0x3f	; 63
    3cc4:	0f 92       	push	r0
    3cc6:	11 24       	eor	r1, r1
    3cc8:	0b b6       	in	r0, 0x3b	; 59
    3cca:	0f 92       	push	r0
    3ccc:	2f 93       	push	r18
    3cce:	3f 93       	push	r19
    3cd0:	4f 93       	push	r20
    3cd2:	8f 93       	push	r24
    3cd4:	9f 93       	push	r25
    3cd6:	af 93       	push	r26
    3cd8:	bf 93       	push	r27
    3cda:	ef 93       	push	r30
    3cdc:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR2A & (_BV(FE2)|_BV(DOR2)|_BV(UPE2)) ) )
    3cde:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3ce2:	8c 71       	andi	r24, 0x1C	; 28
    3ce4:	71 f0       	breq	.+28     	; 0x3d02 <__vector_51+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR2A & (1<<RXC2) ) erroredByte = UDR2;
    3ce6:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>
    3cea:	88 23       	and	r24, r24
    3cec:	0c f0       	brlt	.+2      	; 0x3cf0 <__vector_51+0x32>
    3cee:	36 c0       	rjmp	.+108    	; 0x3d5c <__vector_51+0x9e>
    3cf0:	a6 ed       	ldi	r26, 0xD6	; 214
    3cf2:	b0 e0       	ldi	r27, 0x00	; 0
    3cf4:	e0 ed       	ldi	r30, 0xD0	; 208
    3cf6:	f0 e0       	ldi	r31, 0x00	; 0
    3cf8:	8c 91       	ld	r24, X
    3cfa:	80 81       	ld	r24, Z
    3cfc:	88 23       	and	r24, r24
    3cfe:	e4 f3       	brlt	.-8      	; 0x3cf8 <__vector_51+0x3a>
    3d00:	2d c0       	rjmp	.+90     	; 0x3d5c <__vector_51+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR2;
    3d02:	40 91 d6 00 	lds	r20, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3d06:	0f b6       	in	r0, 0x3f	; 63
    3d08:	f8 94       	cli
    3d0a:	0f 92       	push	r0
	{
	    count = buffer->count;
    3d0c:	e3 e3       	ldi	r30, 0x33	; 51
    3d0e:	f6 e1       	ldi	r31, 0x16	; 22
    3d10:	21 81       	ldd	r18, Z+1	; 0x01
    3d12:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3d14:	0f 90       	pop	r0
    3d16:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial2Port.xRxedChars) ) )
    3d18:	83 85       	ldd	r24, Z+11	; 0x0b
    3d1a:	94 85       	ldd	r25, Z+12	; 0x0c
    3d1c:	28 17       	cp	r18, r24
    3d1e:	39 07       	cpc	r19, r25
    3d20:	e9 f0       	breq	.+58     	; 0x3d5c <__vector_51+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3d22:	e4 e3       	ldi	r30, 0x34	; 52
    3d24:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3d26:	a2 81       	ldd	r26, Z+2	; 0x02
    3d28:	b3 81       	ldd	r27, Z+3	; 0x03
    3d2a:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3d2c:	82 81       	ldd	r24, Z+2	; 0x02
    3d2e:	93 81       	ldd	r25, Z+3	; 0x03
    3d30:	01 96       	adiw	r24, 0x01	; 1
    3d32:	93 83       	std	Z+3, r25	; 0x03
    3d34:	82 83       	std	Z+2, r24	; 0x02
    3d36:	20 85       	ldd	r18, Z+8	; 0x08
    3d38:	31 85       	ldd	r19, Z+9	; 0x09
    3d3a:	82 17       	cp	r24, r18
    3d3c:	93 07       	cpc	r25, r19
    3d3e:	21 f4       	brne	.+8      	; 0x3d48 <__vector_51+0x8a>
	  buffer->in = buffer->start;
    3d40:	86 81       	ldd	r24, Z+6	; 0x06
    3d42:	97 81       	ldd	r25, Z+7	; 0x07
    3d44:	93 83       	std	Z+3, r25	; 0x03
    3d46:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3d48:	0f b6       	in	r0, 0x3f	; 63
    3d4a:	f8 94       	cli
    3d4c:	0f 92       	push	r0
	{
	    buffer->count++;
    3d4e:	80 81       	ld	r24, Z
    3d50:	91 81       	ldd	r25, Z+1	; 0x01
    3d52:	01 96       	adiw	r24, 0x01	; 1
    3d54:	91 83       	std	Z+1, r25	; 0x01
    3d56:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3d58:	0f 90       	pop	r0
    3d5a:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial2Port.xRxedChars), cChar);
	}
}
    3d5c:	ff 91       	pop	r31
    3d5e:	ef 91       	pop	r30
    3d60:	bf 91       	pop	r27
    3d62:	af 91       	pop	r26
    3d64:	9f 91       	pop	r25
    3d66:	8f 91       	pop	r24
    3d68:	4f 91       	pop	r20
    3d6a:	3f 91       	pop	r19
    3d6c:	2f 91       	pop	r18
    3d6e:	0f 90       	pop	r0
    3d70:	0b be       	out	0x3b, r0	; 59
    3d72:	0f 90       	pop	r0
    3d74:	0f be       	out	0x3f, r0	; 63
    3d76:	0f 90       	pop	r0
    3d78:	1f 90       	pop	r1
    3d7a:	18 95       	reti

00003d7c <__vector_52>:
/*-----------------------------------------------------------*/

ISR( USART2_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART2_UDRE_vect )
{
    3d7c:	1f 92       	push	r1
    3d7e:	0f 92       	push	r0
    3d80:	0f b6       	in	r0, 0x3f	; 63
    3d82:	0f 92       	push	r0
    3d84:	11 24       	eor	r1, r1
    3d86:	0b b6       	in	r0, 0x3b	; 59
    3d88:	0f 92       	push	r0
    3d8a:	2f 93       	push	r18
    3d8c:	8f 93       	push	r24
    3d8e:	9f 93       	push	r25
    3d90:	af 93       	push	r26
    3d92:	bf 93       	push	r27
    3d94:	ef 93       	push	r30
    3d96:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3d98:	0f b6       	in	r0, 0x3f	; 63
    3d9a:	f8 94       	cli
    3d9c:	0f 92       	push	r0
	{
	    count = buffer->count;
    3d9e:	80 91 40 16 	lds	r24, 0x1640	; 0x801640 <xSerial2Port+0xd>
    3da2:	90 91 41 16 	lds	r25, 0x1641	; 0x801641 <xSerial2Port+0xe>
	}
	portEXIT_CRITICAL();
    3da6:	0f 90       	pop	r0
    3da8:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) ) )
    3daa:	89 2b       	or	r24, r25
    3dac:	31 f4       	brne	.+12     	; 0x3dba <__vector_52+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt2_Off();
    3dae:	e1 ed       	ldi	r30, 0xD1	; 209
    3db0:	f0 e0       	ldi	r31, 0x00	; 0
    3db2:	80 81       	ld	r24, Z
    3db4:	8f 7d       	andi	r24, 0xDF	; 223
    3db6:	80 83       	st	Z, r24
    3db8:	1c c0       	rjmp	.+56     	; 0x3df2 <__vector_52+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3dba:	e0 e4       	ldi	r30, 0x40	; 64
    3dbc:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    3dbe:	a4 81       	ldd	r26, Z+4	; 0x04
    3dc0:	b5 81       	ldd	r27, Z+5	; 0x05
    3dc2:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3dc4:	b5 83       	std	Z+5, r27	; 0x05
    3dc6:	a4 83       	std	Z+4, r26	; 0x04
    3dc8:	80 85       	ldd	r24, Z+8	; 0x08
    3dca:	91 85       	ldd	r25, Z+9	; 0x09
    3dcc:	a8 17       	cp	r26, r24
    3dce:	b9 07       	cpc	r27, r25
    3dd0:	21 f4       	brne	.+8      	; 0x3dda <__vector_52+0x5e>
	  buffer->out = buffer->start;
    3dd2:	86 81       	ldd	r24, Z+6	; 0x06
    3dd4:	97 81       	ldd	r25, Z+7	; 0x07
    3dd6:	95 83       	std	Z+5, r25	; 0x05
    3dd8:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3dda:	0f b6       	in	r0, 0x3f	; 63
    3ddc:	f8 94       	cli
    3dde:	0f 92       	push	r0
	{
	    buffer->count--;
    3de0:	80 81       	ld	r24, Z
    3de2:	91 81       	ldd	r25, Z+1	; 0x01
    3de4:	01 97       	sbiw	r24, 0x01	; 1
    3de6:	91 83       	std	Z+1, r25	; 0x01
    3de8:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3dea:	0f 90       	pop	r0
    3dec:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR2 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial2Port.xCharsForTx) );
    3dee:	20 93 d6 00 	sts	0x00D6, r18	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
	}
}
    3df2:	ff 91       	pop	r31
    3df4:	ef 91       	pop	r30
    3df6:	bf 91       	pop	r27
    3df8:	af 91       	pop	r26
    3dfa:	9f 91       	pop	r25
    3dfc:	8f 91       	pop	r24
    3dfe:	2f 91       	pop	r18
    3e00:	0f 90       	pop	r0
    3e02:	0b be       	out	0x3b, r0	; 59
    3e04:	0f 90       	pop	r0
    3e06:	0f be       	out	0x3f, r0	; 63
    3e08:	0f 90       	pop	r0
    3e0a:	1f 90       	pop	r1
    3e0c:	18 95       	reti

00003e0e <__vector_54>:
/*-----------------------------------------------------------*/

ISR( USART3_RX_vect ) __attribute__ ((hot, flatten));
ISR( USART3_RX_vect )
{
    3e0e:	1f 92       	push	r1
    3e10:	0f 92       	push	r0
    3e12:	0f b6       	in	r0, 0x3f	; 63
    3e14:	0f 92       	push	r0
    3e16:	11 24       	eor	r1, r1
    3e18:	0b b6       	in	r0, 0x3b	; 59
    3e1a:	0f 92       	push	r0
    3e1c:	2f 93       	push	r18
    3e1e:	3f 93       	push	r19
    3e20:	4f 93       	push	r20
    3e22:	8f 93       	push	r24
    3e24:	9f 93       	push	r25
    3e26:	af 93       	push	r26
    3e28:	bf 93       	push	r27
    3e2a:	ef 93       	push	r30
    3e2c:	ff 93       	push	r31
	/* Get status and data from buffer */

	/* If error bit set (Frame Error, Data Over Run, Parity), flush and return nothing */
	if ( (UCSR3A & (_BV(FE3)|_BV(DOR3)|_BV(UPE3)) ) )
    3e2e:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    3e32:	8c 71       	andi	r24, 0x1C	; 28
    3e34:	71 f0       	breq	.+28     	; 0x3e52 <__vector_54+0x44>
	{
		register uint8_t erroredByte __attribute__ ((unused));
		while ( UCSR3A & (1<<RXC3) ) erroredByte = UDR3;
    3e36:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x700130>
    3e3a:	88 23       	and	r24, r24
    3e3c:	0c f0       	brlt	.+2      	; 0x3e40 <__vector_54+0x32>
    3e3e:	36 c0       	rjmp	.+108    	; 0x3eac <__vector_54+0x9e>
    3e40:	a6 e3       	ldi	r26, 0x36	; 54
    3e42:	b1 e0       	ldi	r27, 0x01	; 1
    3e44:	e0 e3       	ldi	r30, 0x30	; 48
    3e46:	f1 e0       	ldi	r31, 0x01	; 1
    3e48:	8c 91       	ld	r24, X
    3e4a:	80 81       	ld	r24, Z
    3e4c:	88 23       	and	r24, r24
    3e4e:	e4 f3       	brlt	.-8      	; 0x3e48 <__vector_54+0x3a>
    3e50:	2d c0       	rjmp	.+90     	; 0x3eac <__vector_54+0x9e>
	}
	else
	{
		/* If no error, get the character and post it on the buffer of Rxed characters.*/
		register uint8_t cChar = UDR3;
    3e52:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3e56:	0f b6       	in	r0, 0x3f	; 63
    3e58:	f8 94       	cli
    3e5a:	0f 92       	push	r0
	{
	    count = buffer->count;
    3e5c:	e5 e5       	ldi	r30, 0x55	; 85
    3e5e:	f6 e1       	ldi	r31, 0x16	; 22
    3e60:	21 81       	ldd	r18, Z+1	; 0x01
    3e62:	32 81       	ldd	r19, Z+2	; 0x02
	}
	portEXIT_CRITICAL();
    3e64:	0f 90       	pop	r0
    3e66:	0f be       	out	0x3f, r0	; 63

		if( ! ringBuffer_IsFull( (ringBuffer_t*) &(xSerial3Port.xRxedChars) ) )
    3e68:	83 85       	ldd	r24, Z+11	; 0x0b
    3e6a:	94 85       	ldd	r25, Z+12	; 0x0c
    3e6c:	28 17       	cp	r18, r24
    3e6e:	39 07       	cpc	r19, r25
    3e70:	e9 f0       	breq	.+58     	; 0x3eac <__vector_54+0x9e>
}

inline void
ringBuffer_Poke(ringBuffer_t* buffer, uint8_t const data)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3e72:	e6 e5       	ldi	r30, 0x56	; 86
    3e74:	f6 e1       	ldi	r31, 0x16	; 22

	*buffer->in = data;
    3e76:	a2 81       	ldd	r26, Z+2	; 0x02
    3e78:	b3 81       	ldd	r27, Z+3	; 0x03
    3e7a:	4c 93       	st	X, r20

	if (++buffer->in == buffer->end)
    3e7c:	82 81       	ldd	r24, Z+2	; 0x02
    3e7e:	93 81       	ldd	r25, Z+3	; 0x03
    3e80:	01 96       	adiw	r24, 0x01	; 1
    3e82:	93 83       	std	Z+3, r25	; 0x03
    3e84:	82 83       	std	Z+2, r24	; 0x02
    3e86:	20 85       	ldd	r18, Z+8	; 0x08
    3e88:	31 85       	ldd	r19, Z+9	; 0x09
    3e8a:	82 17       	cp	r24, r18
    3e8c:	93 07       	cpc	r25, r19
    3e8e:	21 f4       	brne	.+8      	; 0x3e98 <__vector_54+0x8a>
	  buffer->in = buffer->start;
    3e90:	86 81       	ldd	r24, Z+6	; 0x06
    3e92:	97 81       	ldd	r25, Z+7	; 0x07
    3e94:	93 83       	std	Z+3, r25	; 0x03
    3e96:	82 83       	std	Z+2, r24	; 0x02

	portENTER_CRITICAL();
    3e98:	0f b6       	in	r0, 0x3f	; 63
    3e9a:	f8 94       	cli
    3e9c:	0f 92       	push	r0
	{
	    buffer->count++;
    3e9e:	80 81       	ld	r24, Z
    3ea0:	91 81       	ldd	r25, Z+1	; 0x01
    3ea2:	01 96       	adiw	r24, 0x01	; 1
    3ea4:	91 83       	std	Z+1, r25	; 0x01
    3ea6:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3ea8:	0f 90       	pop	r0
    3eaa:	0f be       	out	0x3f, r0	; 63
			ringBuffer_Poke( (ringBuffer_t*) &(xSerial3Port.xRxedChars), cChar);
	}
}
    3eac:	ff 91       	pop	r31
    3eae:	ef 91       	pop	r30
    3eb0:	bf 91       	pop	r27
    3eb2:	af 91       	pop	r26
    3eb4:	9f 91       	pop	r25
    3eb6:	8f 91       	pop	r24
    3eb8:	4f 91       	pop	r20
    3eba:	3f 91       	pop	r19
    3ebc:	2f 91       	pop	r18
    3ebe:	0f 90       	pop	r0
    3ec0:	0b be       	out	0x3b, r0	; 59
    3ec2:	0f 90       	pop	r0
    3ec4:	0f be       	out	0x3f, r0	; 63
    3ec6:	0f 90       	pop	r0
    3ec8:	1f 90       	pop	r1
    3eca:	18 95       	reti

00003ecc <__vector_55>:
/*-----------------------------------------------------------*/

ISR( USART3_UDRE_vect ) __attribute__ ((hot, flatten));
ISR( USART3_UDRE_vect )
{
    3ecc:	1f 92       	push	r1
    3ece:	0f 92       	push	r0
    3ed0:	0f b6       	in	r0, 0x3f	; 63
    3ed2:	0f 92       	push	r0
    3ed4:	11 24       	eor	r1, r1
    3ed6:	0b b6       	in	r0, 0x3b	; 59
    3ed8:	0f 92       	push	r0
    3eda:	2f 93       	push	r18
    3edc:	8f 93       	push	r24
    3ede:	9f 93       	push	r25
    3ee0:	af 93       	push	r26
    3ee2:	bf 93       	push	r27
    3ee4:	ef 93       	push	r30
    3ee6:	ff 93       	push	r31
inline uint16_t
ringBuffer_GetCount(ringBuffer_t* const buffer)
{
	uint16_t count;

	portENTER_CRITICAL();
    3ee8:	0f b6       	in	r0, 0x3f	; 63
    3eea:	f8 94       	cli
    3eec:	0f 92       	push	r0
	{
	    count = buffer->count;
    3eee:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <xSerial3Port+0xd>
    3ef2:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <xSerial3Port+0xe>
	}
	portEXIT_CRITICAL();
    3ef6:	0f 90       	pop	r0
    3ef8:	0f be       	out	0x3f, r0	; 63
	if( ringBuffer_IsEmpty( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) ) )
    3efa:	89 2b       	or	r24, r25
    3efc:	31 f4       	brne	.+12     	; 0x3f0a <__vector_55+0x3e>
	{
		// Queue empty, nothing to send.
		vInterrupt3_Off();
    3efe:	e1 e3       	ldi	r30, 0x31	; 49
    3f00:	f1 e0       	ldi	r31, 0x01	; 1
    3f02:	80 81       	ld	r24, Z
    3f04:	8f 7d       	andi	r24, 0xDF	; 223
    3f06:	80 83       	st	Z, r24
    3f08:	1c c0       	rjmp	.+56     	; 0x3f42 <__vector_55+0x76>
}

inline uint8_t
ringBuffer_Pop(ringBuffer_t* buffer)
{
	GCC_FORCE_POINTER_ACCESS(buffer);
    3f0a:	e2 e6       	ldi	r30, 0x62	; 98
    3f0c:	f6 e1       	ldi	r31, 0x16	; 22

	uint8_t data = *buffer->out;
    3f0e:	a4 81       	ldd	r26, Z+4	; 0x04
    3f10:	b5 81       	ldd	r27, Z+5	; 0x05
    3f12:	2d 91       	ld	r18, X+

	if (++buffer->out == buffer->end)
    3f14:	b5 83       	std	Z+5, r27	; 0x05
    3f16:	a4 83       	std	Z+4, r26	; 0x04
    3f18:	80 85       	ldd	r24, Z+8	; 0x08
    3f1a:	91 85       	ldd	r25, Z+9	; 0x09
    3f1c:	a8 17       	cp	r26, r24
    3f1e:	b9 07       	cpc	r27, r25
    3f20:	21 f4       	brne	.+8      	; 0x3f2a <__vector_55+0x5e>
	  buffer->out = buffer->start;
    3f22:	86 81       	ldd	r24, Z+6	; 0x06
    3f24:	97 81       	ldd	r25, Z+7	; 0x07
    3f26:	95 83       	std	Z+5, r25	; 0x05
    3f28:	84 83       	std	Z+4, r24	; 0x04

	portENTER_CRITICAL();
    3f2a:	0f b6       	in	r0, 0x3f	; 63
    3f2c:	f8 94       	cli
    3f2e:	0f 92       	push	r0
	{
	    buffer->count--;
    3f30:	80 81       	ld	r24, Z
    3f32:	91 81       	ldd	r25, Z+1	; 0x01
    3f34:	01 97       	sbiw	r24, 0x01	; 1
    3f36:	91 83       	std	Z+1, r25	; 0x01
    3f38:	80 83       	st	Z, r24
	}
	portEXIT_CRITICAL();
    3f3a:	0f 90       	pop	r0
    3f3c:	0f be       	out	0x3f, r0	; 63
	}
	else
	{
		UDR3 = ringBuffer_Pop( (ringBuffer_t*) &(xSerial3Port.xCharsForTx) );
    3f3e:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <__TEXT_REGION_LENGTH__+0x700136>
	}
}
    3f42:	ff 91       	pop	r31
    3f44:	ef 91       	pop	r30
    3f46:	bf 91       	pop	r27
    3f48:	af 91       	pop	r26
    3f4a:	9f 91       	pop	r25
    3f4c:	8f 91       	pop	r24
    3f4e:	2f 91       	pop	r18
    3f50:	0f 90       	pop	r0
    3f52:	0b be       	out	0x3b, r0	; 59
    3f54:	0f 90       	pop	r0
    3f56:	0f be       	out	0x3f, r0	; 63
    3f58:	0f 90       	pop	r0
    3f5a:	1f 90       	pop	r1
    3f5c:	18 95       	reti

00003f5e <__subsf3>:
    3f5e:	50 58       	subi	r21, 0x80	; 128

00003f60 <__addsf3>:
    3f60:	bb 27       	eor	r27, r27
    3f62:	aa 27       	eor	r26, r26
    3f64:	0e d0       	rcall	.+28     	; 0x3f82 <__addsf3x>
    3f66:	0d c1       	rjmp	.+538    	; 0x4182 <__fp_round>
    3f68:	fe d0       	rcall	.+508    	; 0x4166 <__fp_pscA>
    3f6a:	30 f0       	brcs	.+12     	; 0x3f78 <__addsf3+0x18>
    3f6c:	03 d1       	rcall	.+518    	; 0x4174 <__fp_pscB>
    3f6e:	20 f0       	brcs	.+8      	; 0x3f78 <__addsf3+0x18>
    3f70:	31 f4       	brne	.+12     	; 0x3f7e <__addsf3+0x1e>
    3f72:	9f 3f       	cpi	r25, 0xFF	; 255
    3f74:	11 f4       	brne	.+4      	; 0x3f7a <__addsf3+0x1a>
    3f76:	1e f4       	brtc	.+6      	; 0x3f7e <__addsf3+0x1e>
    3f78:	f3 c0       	rjmp	.+486    	; 0x4160 <__fp_nan>
    3f7a:	0e f4       	brtc	.+2      	; 0x3f7e <__addsf3+0x1e>
    3f7c:	e0 95       	com	r30
    3f7e:	e7 fb       	bst	r30, 7
    3f80:	e9 c0       	rjmp	.+466    	; 0x4154 <__fp_inf>

00003f82 <__addsf3x>:
    3f82:	e9 2f       	mov	r30, r25
    3f84:	0f d1       	rcall	.+542    	; 0x41a4 <__fp_split3>
    3f86:	80 f3       	brcs	.-32     	; 0x3f68 <__addsf3+0x8>
    3f88:	ba 17       	cp	r27, r26
    3f8a:	62 07       	cpc	r22, r18
    3f8c:	73 07       	cpc	r23, r19
    3f8e:	84 07       	cpc	r24, r20
    3f90:	95 07       	cpc	r25, r21
    3f92:	18 f0       	brcs	.+6      	; 0x3f9a <__addsf3x+0x18>
    3f94:	71 f4       	brne	.+28     	; 0x3fb2 <__addsf3x+0x30>
    3f96:	9e f5       	brtc	.+102    	; 0x3ffe <__addsf3x+0x7c>
    3f98:	27 c1       	rjmp	.+590    	; 0x41e8 <__fp_zero>
    3f9a:	0e f4       	brtc	.+2      	; 0x3f9e <__addsf3x+0x1c>
    3f9c:	e0 95       	com	r30
    3f9e:	0b 2e       	mov	r0, r27
    3fa0:	ba 2f       	mov	r27, r26
    3fa2:	a0 2d       	mov	r26, r0
    3fa4:	0b 01       	movw	r0, r22
    3fa6:	b9 01       	movw	r22, r18
    3fa8:	90 01       	movw	r18, r0
    3faa:	0c 01       	movw	r0, r24
    3fac:	ca 01       	movw	r24, r20
    3fae:	a0 01       	movw	r20, r0
    3fb0:	11 24       	eor	r1, r1
    3fb2:	ff 27       	eor	r31, r31
    3fb4:	59 1b       	sub	r21, r25
    3fb6:	99 f0       	breq	.+38     	; 0x3fde <__addsf3x+0x5c>
    3fb8:	59 3f       	cpi	r21, 0xF9	; 249
    3fba:	50 f4       	brcc	.+20     	; 0x3fd0 <__addsf3x+0x4e>
    3fbc:	50 3e       	cpi	r21, 0xE0	; 224
    3fbe:	68 f1       	brcs	.+90     	; 0x401a <__addsf3x+0x98>
    3fc0:	1a 16       	cp	r1, r26
    3fc2:	f0 40       	sbci	r31, 0x00	; 0
    3fc4:	a2 2f       	mov	r26, r18
    3fc6:	23 2f       	mov	r18, r19
    3fc8:	34 2f       	mov	r19, r20
    3fca:	44 27       	eor	r20, r20
    3fcc:	58 5f       	subi	r21, 0xF8	; 248
    3fce:	f3 cf       	rjmp	.-26     	; 0x3fb6 <__addsf3x+0x34>
    3fd0:	46 95       	lsr	r20
    3fd2:	37 95       	ror	r19
    3fd4:	27 95       	ror	r18
    3fd6:	a7 95       	ror	r26
    3fd8:	f0 40       	sbci	r31, 0x00	; 0
    3fda:	53 95       	inc	r21
    3fdc:	c9 f7       	brne	.-14     	; 0x3fd0 <__addsf3x+0x4e>
    3fde:	7e f4       	brtc	.+30     	; 0x3ffe <__addsf3x+0x7c>
    3fe0:	1f 16       	cp	r1, r31
    3fe2:	ba 0b       	sbc	r27, r26
    3fe4:	62 0b       	sbc	r22, r18
    3fe6:	73 0b       	sbc	r23, r19
    3fe8:	84 0b       	sbc	r24, r20
    3fea:	ba f0       	brmi	.+46     	; 0x401a <__addsf3x+0x98>
    3fec:	91 50       	subi	r25, 0x01	; 1
    3fee:	a1 f0       	breq	.+40     	; 0x4018 <__addsf3x+0x96>
    3ff0:	ff 0f       	add	r31, r31
    3ff2:	bb 1f       	adc	r27, r27
    3ff4:	66 1f       	adc	r22, r22
    3ff6:	77 1f       	adc	r23, r23
    3ff8:	88 1f       	adc	r24, r24
    3ffa:	c2 f7       	brpl	.-16     	; 0x3fec <__addsf3x+0x6a>
    3ffc:	0e c0       	rjmp	.+28     	; 0x401a <__addsf3x+0x98>
    3ffe:	ba 0f       	add	r27, r26
    4000:	62 1f       	adc	r22, r18
    4002:	73 1f       	adc	r23, r19
    4004:	84 1f       	adc	r24, r20
    4006:	48 f4       	brcc	.+18     	; 0x401a <__addsf3x+0x98>
    4008:	87 95       	ror	r24
    400a:	77 95       	ror	r23
    400c:	67 95       	ror	r22
    400e:	b7 95       	ror	r27
    4010:	f7 95       	ror	r31
    4012:	9e 3f       	cpi	r25, 0xFE	; 254
    4014:	08 f0       	brcs	.+2      	; 0x4018 <__addsf3x+0x96>
    4016:	b3 cf       	rjmp	.-154    	; 0x3f7e <__addsf3+0x1e>
    4018:	93 95       	inc	r25
    401a:	88 0f       	add	r24, r24
    401c:	08 f0       	brcs	.+2      	; 0x4020 <__addsf3x+0x9e>
    401e:	99 27       	eor	r25, r25
    4020:	ee 0f       	add	r30, r30
    4022:	97 95       	ror	r25
    4024:	87 95       	ror	r24
    4026:	08 95       	ret

00004028 <__cmpsf2>:
    4028:	71 d0       	rcall	.+226    	; 0x410c <__fp_cmp>
    402a:	08 f4       	brcc	.+2      	; 0x402e <__cmpsf2+0x6>
    402c:	81 e0       	ldi	r24, 0x01	; 1
    402e:	08 95       	ret

00004030 <__fixsfsi>:
    4030:	04 d0       	rcall	.+8      	; 0x403a <__fixunssfsi>
    4032:	68 94       	set
    4034:	b1 11       	cpse	r27, r1
    4036:	d9 c0       	rjmp	.+434    	; 0x41ea <__fp_szero>
    4038:	08 95       	ret

0000403a <__fixunssfsi>:
    403a:	bc d0       	rcall	.+376    	; 0x41b4 <__fp_splitA>
    403c:	88 f0       	brcs	.+34     	; 0x4060 <__fixunssfsi+0x26>
    403e:	9f 57       	subi	r25, 0x7F	; 127
    4040:	90 f0       	brcs	.+36     	; 0x4066 <__fixunssfsi+0x2c>
    4042:	b9 2f       	mov	r27, r25
    4044:	99 27       	eor	r25, r25
    4046:	b7 51       	subi	r27, 0x17	; 23
    4048:	a0 f0       	brcs	.+40     	; 0x4072 <__fixunssfsi+0x38>
    404a:	d1 f0       	breq	.+52     	; 0x4080 <__fixunssfsi+0x46>
    404c:	66 0f       	add	r22, r22
    404e:	77 1f       	adc	r23, r23
    4050:	88 1f       	adc	r24, r24
    4052:	99 1f       	adc	r25, r25
    4054:	1a f0       	brmi	.+6      	; 0x405c <__fixunssfsi+0x22>
    4056:	ba 95       	dec	r27
    4058:	c9 f7       	brne	.-14     	; 0x404c <__fixunssfsi+0x12>
    405a:	12 c0       	rjmp	.+36     	; 0x4080 <__fixunssfsi+0x46>
    405c:	b1 30       	cpi	r27, 0x01	; 1
    405e:	81 f0       	breq	.+32     	; 0x4080 <__fixunssfsi+0x46>
    4060:	c3 d0       	rcall	.+390    	; 0x41e8 <__fp_zero>
    4062:	b1 e0       	ldi	r27, 0x01	; 1
    4064:	08 95       	ret
    4066:	c0 c0       	rjmp	.+384    	; 0x41e8 <__fp_zero>
    4068:	67 2f       	mov	r22, r23
    406a:	78 2f       	mov	r23, r24
    406c:	88 27       	eor	r24, r24
    406e:	b8 5f       	subi	r27, 0xF8	; 248
    4070:	39 f0       	breq	.+14     	; 0x4080 <__fixunssfsi+0x46>
    4072:	b9 3f       	cpi	r27, 0xF9	; 249
    4074:	cc f3       	brlt	.-14     	; 0x4068 <__fixunssfsi+0x2e>
    4076:	86 95       	lsr	r24
    4078:	77 95       	ror	r23
    407a:	67 95       	ror	r22
    407c:	b3 95       	inc	r27
    407e:	d9 f7       	brne	.-10     	; 0x4076 <__fixunssfsi+0x3c>
    4080:	3e f4       	brtc	.+14     	; 0x4090 <__fixunssfsi+0x56>
    4082:	90 95       	com	r25
    4084:	80 95       	com	r24
    4086:	70 95       	com	r23
    4088:	61 95       	neg	r22
    408a:	7f 4f       	sbci	r23, 0xFF	; 255
    408c:	8f 4f       	sbci	r24, 0xFF	; 255
    408e:	9f 4f       	sbci	r25, 0xFF	; 255
    4090:	08 95       	ret

00004092 <__floatunsisf>:
    4092:	e8 94       	clt
    4094:	09 c0       	rjmp	.+18     	; 0x40a8 <__floatsisf+0x12>

00004096 <__floatsisf>:
    4096:	97 fb       	bst	r25, 7
    4098:	3e f4       	brtc	.+14     	; 0x40a8 <__floatsisf+0x12>
    409a:	90 95       	com	r25
    409c:	80 95       	com	r24
    409e:	70 95       	com	r23
    40a0:	61 95       	neg	r22
    40a2:	7f 4f       	sbci	r23, 0xFF	; 255
    40a4:	8f 4f       	sbci	r24, 0xFF	; 255
    40a6:	9f 4f       	sbci	r25, 0xFF	; 255
    40a8:	99 23       	and	r25, r25
    40aa:	a9 f0       	breq	.+42     	; 0x40d6 <__floatsisf+0x40>
    40ac:	f9 2f       	mov	r31, r25
    40ae:	96 e9       	ldi	r25, 0x96	; 150
    40b0:	bb 27       	eor	r27, r27
    40b2:	93 95       	inc	r25
    40b4:	f6 95       	lsr	r31
    40b6:	87 95       	ror	r24
    40b8:	77 95       	ror	r23
    40ba:	67 95       	ror	r22
    40bc:	b7 95       	ror	r27
    40be:	f1 11       	cpse	r31, r1
    40c0:	f8 cf       	rjmp	.-16     	; 0x40b2 <__floatsisf+0x1c>
    40c2:	fa f4       	brpl	.+62     	; 0x4102 <__floatsisf+0x6c>
    40c4:	bb 0f       	add	r27, r27
    40c6:	11 f4       	brne	.+4      	; 0x40cc <__floatsisf+0x36>
    40c8:	60 ff       	sbrs	r22, 0
    40ca:	1b c0       	rjmp	.+54     	; 0x4102 <__floatsisf+0x6c>
    40cc:	6f 5f       	subi	r22, 0xFF	; 255
    40ce:	7f 4f       	sbci	r23, 0xFF	; 255
    40d0:	8f 4f       	sbci	r24, 0xFF	; 255
    40d2:	9f 4f       	sbci	r25, 0xFF	; 255
    40d4:	16 c0       	rjmp	.+44     	; 0x4102 <__floatsisf+0x6c>
    40d6:	88 23       	and	r24, r24
    40d8:	11 f0       	breq	.+4      	; 0x40de <__floatsisf+0x48>
    40da:	96 e9       	ldi	r25, 0x96	; 150
    40dc:	11 c0       	rjmp	.+34     	; 0x4100 <__floatsisf+0x6a>
    40de:	77 23       	and	r23, r23
    40e0:	21 f0       	breq	.+8      	; 0x40ea <__floatsisf+0x54>
    40e2:	9e e8       	ldi	r25, 0x8E	; 142
    40e4:	87 2f       	mov	r24, r23
    40e6:	76 2f       	mov	r23, r22
    40e8:	05 c0       	rjmp	.+10     	; 0x40f4 <__floatsisf+0x5e>
    40ea:	66 23       	and	r22, r22
    40ec:	71 f0       	breq	.+28     	; 0x410a <__floatsisf+0x74>
    40ee:	96 e8       	ldi	r25, 0x86	; 134
    40f0:	86 2f       	mov	r24, r22
    40f2:	70 e0       	ldi	r23, 0x00	; 0
    40f4:	60 e0       	ldi	r22, 0x00	; 0
    40f6:	2a f0       	brmi	.+10     	; 0x4102 <__floatsisf+0x6c>
    40f8:	9a 95       	dec	r25
    40fa:	66 0f       	add	r22, r22
    40fc:	77 1f       	adc	r23, r23
    40fe:	88 1f       	adc	r24, r24
    4100:	da f7       	brpl	.-10     	; 0x40f8 <__floatsisf+0x62>
    4102:	88 0f       	add	r24, r24
    4104:	96 95       	lsr	r25
    4106:	87 95       	ror	r24
    4108:	97 f9       	bld	r25, 7
    410a:	08 95       	ret

0000410c <__fp_cmp>:
    410c:	99 0f       	add	r25, r25
    410e:	00 08       	sbc	r0, r0
    4110:	55 0f       	add	r21, r21
    4112:	aa 0b       	sbc	r26, r26
    4114:	e0 e8       	ldi	r30, 0x80	; 128
    4116:	fe ef       	ldi	r31, 0xFE	; 254
    4118:	16 16       	cp	r1, r22
    411a:	17 06       	cpc	r1, r23
    411c:	e8 07       	cpc	r30, r24
    411e:	f9 07       	cpc	r31, r25
    4120:	c0 f0       	brcs	.+48     	; 0x4152 <__fp_cmp+0x46>
    4122:	12 16       	cp	r1, r18
    4124:	13 06       	cpc	r1, r19
    4126:	e4 07       	cpc	r30, r20
    4128:	f5 07       	cpc	r31, r21
    412a:	98 f0       	brcs	.+38     	; 0x4152 <__fp_cmp+0x46>
    412c:	62 1b       	sub	r22, r18
    412e:	73 0b       	sbc	r23, r19
    4130:	84 0b       	sbc	r24, r20
    4132:	95 0b       	sbc	r25, r21
    4134:	39 f4       	brne	.+14     	; 0x4144 <__fp_cmp+0x38>
    4136:	0a 26       	eor	r0, r26
    4138:	61 f0       	breq	.+24     	; 0x4152 <__fp_cmp+0x46>
    413a:	23 2b       	or	r18, r19
    413c:	24 2b       	or	r18, r20
    413e:	25 2b       	or	r18, r21
    4140:	21 f4       	brne	.+8      	; 0x414a <__fp_cmp+0x3e>
    4142:	08 95       	ret
    4144:	0a 26       	eor	r0, r26
    4146:	09 f4       	brne	.+2      	; 0x414a <__fp_cmp+0x3e>
    4148:	a1 40       	sbci	r26, 0x01	; 1
    414a:	a6 95       	lsr	r26
    414c:	8f ef       	ldi	r24, 0xFF	; 255
    414e:	81 1d       	adc	r24, r1
    4150:	81 1d       	adc	r24, r1
    4152:	08 95       	ret

00004154 <__fp_inf>:
    4154:	97 f9       	bld	r25, 7
    4156:	9f 67       	ori	r25, 0x7F	; 127
    4158:	80 e8       	ldi	r24, 0x80	; 128
    415a:	70 e0       	ldi	r23, 0x00	; 0
    415c:	60 e0       	ldi	r22, 0x00	; 0
    415e:	08 95       	ret

00004160 <__fp_nan>:
    4160:	9f ef       	ldi	r25, 0xFF	; 255
    4162:	80 ec       	ldi	r24, 0xC0	; 192
    4164:	08 95       	ret

00004166 <__fp_pscA>:
    4166:	00 24       	eor	r0, r0
    4168:	0a 94       	dec	r0
    416a:	16 16       	cp	r1, r22
    416c:	17 06       	cpc	r1, r23
    416e:	18 06       	cpc	r1, r24
    4170:	09 06       	cpc	r0, r25
    4172:	08 95       	ret

00004174 <__fp_pscB>:
    4174:	00 24       	eor	r0, r0
    4176:	0a 94       	dec	r0
    4178:	12 16       	cp	r1, r18
    417a:	13 06       	cpc	r1, r19
    417c:	14 06       	cpc	r1, r20
    417e:	05 06       	cpc	r0, r21
    4180:	08 95       	ret

00004182 <__fp_round>:
    4182:	09 2e       	mov	r0, r25
    4184:	03 94       	inc	r0
    4186:	00 0c       	add	r0, r0
    4188:	11 f4       	brne	.+4      	; 0x418e <__fp_round+0xc>
    418a:	88 23       	and	r24, r24
    418c:	52 f0       	brmi	.+20     	; 0x41a2 <__fp_round+0x20>
    418e:	bb 0f       	add	r27, r27
    4190:	40 f4       	brcc	.+16     	; 0x41a2 <__fp_round+0x20>
    4192:	bf 2b       	or	r27, r31
    4194:	11 f4       	brne	.+4      	; 0x419a <__fp_round+0x18>
    4196:	60 ff       	sbrs	r22, 0
    4198:	04 c0       	rjmp	.+8      	; 0x41a2 <__fp_round+0x20>
    419a:	6f 5f       	subi	r22, 0xFF	; 255
    419c:	7f 4f       	sbci	r23, 0xFF	; 255
    419e:	8f 4f       	sbci	r24, 0xFF	; 255
    41a0:	9f 4f       	sbci	r25, 0xFF	; 255
    41a2:	08 95       	ret

000041a4 <__fp_split3>:
    41a4:	57 fd       	sbrc	r21, 7
    41a6:	90 58       	subi	r25, 0x80	; 128
    41a8:	44 0f       	add	r20, r20
    41aa:	55 1f       	adc	r21, r21
    41ac:	59 f0       	breq	.+22     	; 0x41c4 <__fp_splitA+0x10>
    41ae:	5f 3f       	cpi	r21, 0xFF	; 255
    41b0:	71 f0       	breq	.+28     	; 0x41ce <__fp_splitA+0x1a>
    41b2:	47 95       	ror	r20

000041b4 <__fp_splitA>:
    41b4:	88 0f       	add	r24, r24
    41b6:	97 fb       	bst	r25, 7
    41b8:	99 1f       	adc	r25, r25
    41ba:	61 f0       	breq	.+24     	; 0x41d4 <__fp_splitA+0x20>
    41bc:	9f 3f       	cpi	r25, 0xFF	; 255
    41be:	79 f0       	breq	.+30     	; 0x41de <__fp_splitA+0x2a>
    41c0:	87 95       	ror	r24
    41c2:	08 95       	ret
    41c4:	12 16       	cp	r1, r18
    41c6:	13 06       	cpc	r1, r19
    41c8:	14 06       	cpc	r1, r20
    41ca:	55 1f       	adc	r21, r21
    41cc:	f2 cf       	rjmp	.-28     	; 0x41b2 <__fp_split3+0xe>
    41ce:	46 95       	lsr	r20
    41d0:	f1 df       	rcall	.-30     	; 0x41b4 <__fp_splitA>
    41d2:	08 c0       	rjmp	.+16     	; 0x41e4 <__fp_splitA+0x30>
    41d4:	16 16       	cp	r1, r22
    41d6:	17 06       	cpc	r1, r23
    41d8:	18 06       	cpc	r1, r24
    41da:	99 1f       	adc	r25, r25
    41dc:	f1 cf       	rjmp	.-30     	; 0x41c0 <__fp_splitA+0xc>
    41de:	86 95       	lsr	r24
    41e0:	71 05       	cpc	r23, r1
    41e2:	61 05       	cpc	r22, r1
    41e4:	08 94       	sec
    41e6:	08 95       	ret

000041e8 <__fp_zero>:
    41e8:	e8 94       	clt

000041ea <__fp_szero>:
    41ea:	bb 27       	eor	r27, r27
    41ec:	66 27       	eor	r22, r22
    41ee:	77 27       	eor	r23, r23
    41f0:	cb 01       	movw	r24, r22
    41f2:	97 f9       	bld	r25, 7
    41f4:	08 95       	ret

000041f6 <__gesf2>:
    41f6:	8a df       	rcall	.-236    	; 0x410c <__fp_cmp>
    41f8:	08 f4       	brcc	.+2      	; 0x41fc <__gesf2+0x6>
    41fa:	8f ef       	ldi	r24, 0xFF	; 255
    41fc:	08 95       	ret

000041fe <__mulsf3>:
    41fe:	0b d0       	rcall	.+22     	; 0x4216 <__mulsf3x>
    4200:	c0 cf       	rjmp	.-128    	; 0x4182 <__fp_round>
    4202:	b1 df       	rcall	.-158    	; 0x4166 <__fp_pscA>
    4204:	28 f0       	brcs	.+10     	; 0x4210 <__mulsf3+0x12>
    4206:	b6 df       	rcall	.-148    	; 0x4174 <__fp_pscB>
    4208:	18 f0       	brcs	.+6      	; 0x4210 <__mulsf3+0x12>
    420a:	95 23       	and	r25, r21
    420c:	09 f0       	breq	.+2      	; 0x4210 <__mulsf3+0x12>
    420e:	a2 cf       	rjmp	.-188    	; 0x4154 <__fp_inf>
    4210:	a7 cf       	rjmp	.-178    	; 0x4160 <__fp_nan>
    4212:	11 24       	eor	r1, r1
    4214:	ea cf       	rjmp	.-44     	; 0x41ea <__fp_szero>

00004216 <__mulsf3x>:
    4216:	c6 df       	rcall	.-116    	; 0x41a4 <__fp_split3>
    4218:	a0 f3       	brcs	.-24     	; 0x4202 <__mulsf3+0x4>

0000421a <__mulsf3_pse>:
    421a:	95 9f       	mul	r25, r21
    421c:	d1 f3       	breq	.-12     	; 0x4212 <__mulsf3+0x14>
    421e:	95 0f       	add	r25, r21
    4220:	50 e0       	ldi	r21, 0x00	; 0
    4222:	55 1f       	adc	r21, r21
    4224:	62 9f       	mul	r22, r18
    4226:	f0 01       	movw	r30, r0
    4228:	72 9f       	mul	r23, r18
    422a:	bb 27       	eor	r27, r27
    422c:	f0 0d       	add	r31, r0
    422e:	b1 1d       	adc	r27, r1
    4230:	63 9f       	mul	r22, r19
    4232:	aa 27       	eor	r26, r26
    4234:	f0 0d       	add	r31, r0
    4236:	b1 1d       	adc	r27, r1
    4238:	aa 1f       	adc	r26, r26
    423a:	64 9f       	mul	r22, r20
    423c:	66 27       	eor	r22, r22
    423e:	b0 0d       	add	r27, r0
    4240:	a1 1d       	adc	r26, r1
    4242:	66 1f       	adc	r22, r22
    4244:	82 9f       	mul	r24, r18
    4246:	22 27       	eor	r18, r18
    4248:	b0 0d       	add	r27, r0
    424a:	a1 1d       	adc	r26, r1
    424c:	62 1f       	adc	r22, r18
    424e:	73 9f       	mul	r23, r19
    4250:	b0 0d       	add	r27, r0
    4252:	a1 1d       	adc	r26, r1
    4254:	62 1f       	adc	r22, r18
    4256:	83 9f       	mul	r24, r19
    4258:	a0 0d       	add	r26, r0
    425a:	61 1d       	adc	r22, r1
    425c:	22 1f       	adc	r18, r18
    425e:	74 9f       	mul	r23, r20
    4260:	33 27       	eor	r19, r19
    4262:	a0 0d       	add	r26, r0
    4264:	61 1d       	adc	r22, r1
    4266:	23 1f       	adc	r18, r19
    4268:	84 9f       	mul	r24, r20
    426a:	60 0d       	add	r22, r0
    426c:	21 1d       	adc	r18, r1
    426e:	82 2f       	mov	r24, r18
    4270:	76 2f       	mov	r23, r22
    4272:	6a 2f       	mov	r22, r26
    4274:	11 24       	eor	r1, r1
    4276:	9f 57       	subi	r25, 0x7F	; 127
    4278:	50 40       	sbci	r21, 0x00	; 0
    427a:	8a f0       	brmi	.+34     	; 0x429e <__mulsf3_pse+0x84>
    427c:	e1 f0       	breq	.+56     	; 0x42b6 <__mulsf3_pse+0x9c>
    427e:	88 23       	and	r24, r24
    4280:	4a f0       	brmi	.+18     	; 0x4294 <__mulsf3_pse+0x7a>
    4282:	ee 0f       	add	r30, r30
    4284:	ff 1f       	adc	r31, r31
    4286:	bb 1f       	adc	r27, r27
    4288:	66 1f       	adc	r22, r22
    428a:	77 1f       	adc	r23, r23
    428c:	88 1f       	adc	r24, r24
    428e:	91 50       	subi	r25, 0x01	; 1
    4290:	50 40       	sbci	r21, 0x00	; 0
    4292:	a9 f7       	brne	.-22     	; 0x427e <__mulsf3_pse+0x64>
    4294:	9e 3f       	cpi	r25, 0xFE	; 254
    4296:	51 05       	cpc	r21, r1
    4298:	70 f0       	brcs	.+28     	; 0x42b6 <__mulsf3_pse+0x9c>
    429a:	5c cf       	rjmp	.-328    	; 0x4154 <__fp_inf>
    429c:	a6 cf       	rjmp	.-180    	; 0x41ea <__fp_szero>
    429e:	5f 3f       	cpi	r21, 0xFF	; 255
    42a0:	ec f3       	brlt	.-6      	; 0x429c <__mulsf3_pse+0x82>
    42a2:	98 3e       	cpi	r25, 0xE8	; 232
    42a4:	dc f3       	brlt	.-10     	; 0x429c <__mulsf3_pse+0x82>
    42a6:	86 95       	lsr	r24
    42a8:	77 95       	ror	r23
    42aa:	67 95       	ror	r22
    42ac:	b7 95       	ror	r27
    42ae:	f7 95       	ror	r31
    42b0:	e7 95       	ror	r30
    42b2:	9f 5f       	subi	r25, 0xFF	; 255
    42b4:	c1 f7       	brne	.-16     	; 0x42a6 <__mulsf3_pse+0x8c>
    42b6:	fe 2b       	or	r31, r30
    42b8:	88 0f       	add	r24, r24
    42ba:	91 1d       	adc	r25, r1
    42bc:	96 95       	lsr	r25
    42be:	87 95       	ror	r24
    42c0:	97 f9       	bld	r25, 7
    42c2:	08 95       	ret

000042c4 <__udivmodhi4>:
    42c4:	aa 1b       	sub	r26, r26
    42c6:	bb 1b       	sub	r27, r27
    42c8:	51 e1       	ldi	r21, 0x11	; 17
    42ca:	07 c0       	rjmp	.+14     	; 0x42da <__udivmodhi4_ep>

000042cc <__udivmodhi4_loop>:
    42cc:	aa 1f       	adc	r26, r26
    42ce:	bb 1f       	adc	r27, r27
    42d0:	a6 17       	cp	r26, r22
    42d2:	b7 07       	cpc	r27, r23
    42d4:	10 f0       	brcs	.+4      	; 0x42da <__udivmodhi4_ep>
    42d6:	a6 1b       	sub	r26, r22
    42d8:	b7 0b       	sbc	r27, r23

000042da <__udivmodhi4_ep>:
    42da:	88 1f       	adc	r24, r24
    42dc:	99 1f       	adc	r25, r25
    42de:	5a 95       	dec	r21
    42e0:	a9 f7       	brne	.-22     	; 0x42cc <__udivmodhi4_loop>
    42e2:	80 95       	com	r24
    42e4:	90 95       	com	r25
    42e6:	bc 01       	movw	r22, r24
    42e8:	cd 01       	movw	r24, r26
    42ea:	08 95       	ret

000042ec <__divmodhi4>:
    42ec:	97 fb       	bst	r25, 7
    42ee:	07 2e       	mov	r0, r23
    42f0:	16 f4       	brtc	.+4      	; 0x42f6 <__divmodhi4+0xa>
    42f2:	00 94       	com	r0
    42f4:	06 d0       	rcall	.+12     	; 0x4302 <__divmodhi4_neg1>
    42f6:	77 fd       	sbrc	r23, 7
    42f8:	08 d0       	rcall	.+16     	; 0x430a <__divmodhi4_neg2>
    42fa:	e4 df       	rcall	.-56     	; 0x42c4 <__udivmodhi4>
    42fc:	07 fc       	sbrc	r0, 7
    42fe:	05 d0       	rcall	.+10     	; 0x430a <__divmodhi4_neg2>
    4300:	3e f4       	brtc	.+14     	; 0x4310 <__divmodhi4_exit>

00004302 <__divmodhi4_neg1>:
    4302:	90 95       	com	r25
    4304:	81 95       	neg	r24
    4306:	9f 4f       	sbci	r25, 0xFF	; 255
    4308:	08 95       	ret

0000430a <__divmodhi4_neg2>:
    430a:	70 95       	com	r23
    430c:	61 95       	neg	r22
    430e:	7f 4f       	sbci	r23, 0xFF	; 255

00004310 <__divmodhi4_exit>:
    4310:	08 95       	ret

00004312 <__udivmodsi4>:
    4312:	a1 e2       	ldi	r26, 0x21	; 33
    4314:	1a 2e       	mov	r1, r26
    4316:	aa 1b       	sub	r26, r26
    4318:	bb 1b       	sub	r27, r27
    431a:	fd 01       	movw	r30, r26
    431c:	0d c0       	rjmp	.+26     	; 0x4338 <__udivmodsi4_ep>

0000431e <__udivmodsi4_loop>:
    431e:	aa 1f       	adc	r26, r26
    4320:	bb 1f       	adc	r27, r27
    4322:	ee 1f       	adc	r30, r30
    4324:	ff 1f       	adc	r31, r31
    4326:	a2 17       	cp	r26, r18
    4328:	b3 07       	cpc	r27, r19
    432a:	e4 07       	cpc	r30, r20
    432c:	f5 07       	cpc	r31, r21
    432e:	20 f0       	brcs	.+8      	; 0x4338 <__udivmodsi4_ep>
    4330:	a2 1b       	sub	r26, r18
    4332:	b3 0b       	sbc	r27, r19
    4334:	e4 0b       	sbc	r30, r20
    4336:	f5 0b       	sbc	r31, r21

00004338 <__udivmodsi4_ep>:
    4338:	66 1f       	adc	r22, r22
    433a:	77 1f       	adc	r23, r23
    433c:	88 1f       	adc	r24, r24
    433e:	99 1f       	adc	r25, r25
    4340:	1a 94       	dec	r1
    4342:	69 f7       	brne	.-38     	; 0x431e <__udivmodsi4_loop>
    4344:	60 95       	com	r22
    4346:	70 95       	com	r23
    4348:	80 95       	com	r24
    434a:	90 95       	com	r25
    434c:	9b 01       	movw	r18, r22
    434e:	ac 01       	movw	r20, r24
    4350:	bd 01       	movw	r22, r26
    4352:	cf 01       	movw	r24, r30
    4354:	08 95       	ret

00004356 <__divmodsi4>:
    4356:	05 2e       	mov	r0, r21
    4358:	97 fb       	bst	r25, 7
    435a:	16 f4       	brtc	.+4      	; 0x4360 <__divmodsi4+0xa>
    435c:	00 94       	com	r0
    435e:	0f d0       	rcall	.+30     	; 0x437e <__negsi2>
    4360:	57 fd       	sbrc	r21, 7
    4362:	05 d0       	rcall	.+10     	; 0x436e <__divmodsi4_neg2>
    4364:	d6 df       	rcall	.-84     	; 0x4312 <__udivmodsi4>
    4366:	07 fc       	sbrc	r0, 7
    4368:	02 d0       	rcall	.+4      	; 0x436e <__divmodsi4_neg2>
    436a:	46 f4       	brtc	.+16     	; 0x437c <__divmodsi4_exit>
    436c:	08 c0       	rjmp	.+16     	; 0x437e <__negsi2>

0000436e <__divmodsi4_neg2>:
    436e:	50 95       	com	r21
    4370:	40 95       	com	r20
    4372:	30 95       	com	r19
    4374:	21 95       	neg	r18
    4376:	3f 4f       	sbci	r19, 0xFF	; 255
    4378:	4f 4f       	sbci	r20, 0xFF	; 255
    437a:	5f 4f       	sbci	r21, 0xFF	; 255

0000437c <__divmodsi4_exit>:
    437c:	08 95       	ret

0000437e <__negsi2>:
    437e:	90 95       	com	r25
    4380:	80 95       	com	r24
    4382:	70 95       	com	r23
    4384:	61 95       	neg	r22
    4386:	7f 4f       	sbci	r23, 0xFF	; 255
    4388:	8f 4f       	sbci	r24, 0xFF	; 255
    438a:	9f 4f       	sbci	r25, 0xFF	; 255
    438c:	08 95       	ret

0000438e <__tablejump2__>:
    438e:	ee 0f       	add	r30, r30
    4390:	ff 1f       	adc	r31, r31
    4392:	88 1f       	adc	r24, r24
    4394:	8b bf       	out	0x3b, r24	; 59
    4396:	07 90       	elpm	r0, Z+
    4398:	f6 91       	elpm	r31, Z
    439a:	e0 2d       	mov	r30, r0
    439c:	19 94       	eijmp

0000439e <__umulhisi3>:
    439e:	a2 9f       	mul	r26, r18
    43a0:	b0 01       	movw	r22, r0
    43a2:	b3 9f       	mul	r27, r19
    43a4:	c0 01       	movw	r24, r0
    43a6:	a3 9f       	mul	r26, r19
    43a8:	70 0d       	add	r23, r0
    43aa:	81 1d       	adc	r24, r1
    43ac:	11 24       	eor	r1, r1
    43ae:	91 1d       	adc	r25, r1
    43b0:	b2 9f       	mul	r27, r18
    43b2:	70 0d       	add	r23, r0
    43b4:	81 1d       	adc	r24, r1
    43b6:	11 24       	eor	r1, r1
    43b8:	91 1d       	adc	r25, r1
    43ba:	08 95       	ret

000043bc <memcpy>:
    43bc:	fb 01       	movw	r30, r22
    43be:	dc 01       	movw	r26, r24
    43c0:	02 c0       	rjmp	.+4      	; 0x43c6 <memcpy+0xa>
    43c2:	01 90       	ld	r0, Z+
    43c4:	0d 92       	st	X+, r0
    43c6:	41 50       	subi	r20, 0x01	; 1
    43c8:	50 40       	sbci	r21, 0x00	; 0
    43ca:	d8 f7       	brcc	.-10     	; 0x43c2 <memcpy+0x6>
    43cc:	08 95       	ret

000043ce <memset>:
    43ce:	dc 01       	movw	r26, r24
    43d0:	01 c0       	rjmp	.+2      	; 0x43d4 <memset+0x6>
    43d2:	6d 93       	st	X+, r22
    43d4:	41 50       	subi	r20, 0x01	; 1
    43d6:	50 40       	sbci	r21, 0x00	; 0
    43d8:	e0 f7       	brcc	.-8      	; 0x43d2 <memset+0x4>
    43da:	08 95       	ret

000043dc <__itoa_ncheck>:
    43dc:	bb 27       	eor	r27, r27
    43de:	4a 30       	cpi	r20, 0x0A	; 10
    43e0:	31 f4       	brne	.+12     	; 0x43ee <__itoa_ncheck+0x12>
    43e2:	99 23       	and	r25, r25
    43e4:	22 f4       	brpl	.+8      	; 0x43ee <__itoa_ncheck+0x12>
    43e6:	bd e2       	ldi	r27, 0x2D	; 45
    43e8:	90 95       	com	r25
    43ea:	81 95       	neg	r24
    43ec:	9f 4f       	sbci	r25, 0xFF	; 255
    43ee:	01 c0       	rjmp	.+2      	; 0x43f2 <__utoa_common>

000043f0 <__utoa_ncheck>:
    43f0:	bb 27       	eor	r27, r27

000043f2 <__utoa_common>:
    43f2:	fb 01       	movw	r30, r22
    43f4:	55 27       	eor	r21, r21
    43f6:	aa 27       	eor	r26, r26
    43f8:	88 0f       	add	r24, r24
    43fa:	99 1f       	adc	r25, r25
    43fc:	aa 1f       	adc	r26, r26
    43fe:	a4 17       	cp	r26, r20
    4400:	10 f0       	brcs	.+4      	; 0x4406 <__utoa_common+0x14>
    4402:	a4 1b       	sub	r26, r20
    4404:	83 95       	inc	r24
    4406:	50 51       	subi	r21, 0x10	; 16
    4408:	b9 f7       	brne	.-18     	; 0x43f8 <__utoa_common+0x6>
    440a:	a0 5d       	subi	r26, 0xD0	; 208
    440c:	aa 33       	cpi	r26, 0x3A	; 58
    440e:	08 f0       	brcs	.+2      	; 0x4412 <__utoa_common+0x20>
    4410:	a9 5d       	subi	r26, 0xD9	; 217
    4412:	a1 93       	st	Z+, r26
    4414:	00 97       	sbiw	r24, 0x00	; 0
    4416:	79 f7       	brne	.-34     	; 0x43f6 <__utoa_common+0x4>
    4418:	b1 11       	cpse	r27, r1
    441a:	b1 93       	st	Z+, r27
    441c:	11 92       	st	Z+, r1
    441e:	cb 01       	movw	r24, r22
    4420:	26 c2       	rjmp	.+1100   	; 0x486e <strrev>

00004422 <printf>:
    4422:	cf 93       	push	r28
    4424:	df 93       	push	r29
    4426:	cd b7       	in	r28, 0x3d	; 61
    4428:	de b7       	in	r29, 0x3e	; 62
    442a:	ae 01       	movw	r20, r28
    442c:	4a 5f       	subi	r20, 0xFA	; 250
    442e:	5f 4f       	sbci	r21, 0xFF	; 255
    4430:	fa 01       	movw	r30, r20
    4432:	61 91       	ld	r22, Z+
    4434:	71 91       	ld	r23, Z+
    4436:	af 01       	movw	r20, r30
    4438:	80 91 9b 16 	lds	r24, 0x169B	; 0x80169b <__iob+0x2>
    443c:	90 91 9c 16 	lds	r25, 0x169C	; 0x80169c <__iob+0x3>
    4440:	03 d0       	rcall	.+6      	; 0x4448 <vfprintf>
    4442:	df 91       	pop	r29
    4444:	cf 91       	pop	r28
    4446:	08 95       	ret

00004448 <vfprintf>:
    4448:	2f 92       	push	r2
    444a:	3f 92       	push	r3
    444c:	4f 92       	push	r4
    444e:	5f 92       	push	r5
    4450:	6f 92       	push	r6
    4452:	7f 92       	push	r7
    4454:	8f 92       	push	r8
    4456:	9f 92       	push	r9
    4458:	af 92       	push	r10
    445a:	bf 92       	push	r11
    445c:	cf 92       	push	r12
    445e:	df 92       	push	r13
    4460:	ef 92       	push	r14
    4462:	ff 92       	push	r15
    4464:	0f 93       	push	r16
    4466:	1f 93       	push	r17
    4468:	cf 93       	push	r28
    446a:	df 93       	push	r29
    446c:	cd b7       	in	r28, 0x3d	; 61
    446e:	de b7       	in	r29, 0x3e	; 62
    4470:	2b 97       	sbiw	r28, 0x0b	; 11
    4472:	0f b6       	in	r0, 0x3f	; 63
    4474:	f8 94       	cli
    4476:	de bf       	out	0x3e, r29	; 62
    4478:	0f be       	out	0x3f, r0	; 63
    447a:	cd bf       	out	0x3d, r28	; 61
    447c:	6c 01       	movw	r12, r24
    447e:	7b 01       	movw	r14, r22
    4480:	8a 01       	movw	r16, r20
    4482:	fc 01       	movw	r30, r24
    4484:	17 82       	std	Z+7, r1	; 0x07
    4486:	16 82       	std	Z+6, r1	; 0x06
    4488:	83 81       	ldd	r24, Z+3	; 0x03
    448a:	81 ff       	sbrs	r24, 1
    448c:	bf c1       	rjmp	.+894    	; 0x480c <vfprintf+0x3c4>
    448e:	ce 01       	movw	r24, r28
    4490:	01 96       	adiw	r24, 0x01	; 1
    4492:	3c 01       	movw	r6, r24
    4494:	f6 01       	movw	r30, r12
    4496:	93 81       	ldd	r25, Z+3	; 0x03
    4498:	f7 01       	movw	r30, r14
    449a:	93 fd       	sbrc	r25, 3
    449c:	85 91       	lpm	r24, Z+
    449e:	93 ff       	sbrs	r25, 3
    44a0:	81 91       	ld	r24, Z+
    44a2:	7f 01       	movw	r14, r30
    44a4:	88 23       	and	r24, r24
    44a6:	09 f4       	brne	.+2      	; 0x44aa <vfprintf+0x62>
    44a8:	ad c1       	rjmp	.+858    	; 0x4804 <vfprintf+0x3bc>
    44aa:	85 32       	cpi	r24, 0x25	; 37
    44ac:	39 f4       	brne	.+14     	; 0x44bc <vfprintf+0x74>
    44ae:	93 fd       	sbrc	r25, 3
    44b0:	85 91       	lpm	r24, Z+
    44b2:	93 ff       	sbrs	r25, 3
    44b4:	81 91       	ld	r24, Z+
    44b6:	7f 01       	movw	r14, r30
    44b8:	85 32       	cpi	r24, 0x25	; 37
    44ba:	21 f4       	brne	.+8      	; 0x44c4 <vfprintf+0x7c>
    44bc:	b6 01       	movw	r22, r12
    44be:	90 e0       	ldi	r25, 0x00	; 0
    44c0:	e6 d1       	rcall	.+972    	; 0x488e <fputc>
    44c2:	e8 cf       	rjmp	.-48     	; 0x4494 <vfprintf+0x4c>
    44c4:	91 2c       	mov	r9, r1
    44c6:	21 2c       	mov	r2, r1
    44c8:	31 2c       	mov	r3, r1
    44ca:	ff e1       	ldi	r31, 0x1F	; 31
    44cc:	f3 15       	cp	r31, r3
    44ce:	d8 f0       	brcs	.+54     	; 0x4506 <vfprintf+0xbe>
    44d0:	8b 32       	cpi	r24, 0x2B	; 43
    44d2:	79 f0       	breq	.+30     	; 0x44f2 <vfprintf+0xaa>
    44d4:	38 f4       	brcc	.+14     	; 0x44e4 <vfprintf+0x9c>
    44d6:	80 32       	cpi	r24, 0x20	; 32
    44d8:	79 f0       	breq	.+30     	; 0x44f8 <vfprintf+0xb0>
    44da:	83 32       	cpi	r24, 0x23	; 35
    44dc:	a1 f4       	brne	.+40     	; 0x4506 <vfprintf+0xbe>
    44de:	23 2d       	mov	r18, r3
    44e0:	20 61       	ori	r18, 0x10	; 16
    44e2:	1d c0       	rjmp	.+58     	; 0x451e <vfprintf+0xd6>
    44e4:	8d 32       	cpi	r24, 0x2D	; 45
    44e6:	61 f0       	breq	.+24     	; 0x4500 <vfprintf+0xb8>
    44e8:	80 33       	cpi	r24, 0x30	; 48
    44ea:	69 f4       	brne	.+26     	; 0x4506 <vfprintf+0xbe>
    44ec:	23 2d       	mov	r18, r3
    44ee:	21 60       	ori	r18, 0x01	; 1
    44f0:	16 c0       	rjmp	.+44     	; 0x451e <vfprintf+0xd6>
    44f2:	83 2d       	mov	r24, r3
    44f4:	82 60       	ori	r24, 0x02	; 2
    44f6:	38 2e       	mov	r3, r24
    44f8:	e3 2d       	mov	r30, r3
    44fa:	e4 60       	ori	r30, 0x04	; 4
    44fc:	3e 2e       	mov	r3, r30
    44fe:	2a c0       	rjmp	.+84     	; 0x4554 <vfprintf+0x10c>
    4500:	f3 2d       	mov	r31, r3
    4502:	f8 60       	ori	r31, 0x08	; 8
    4504:	1d c0       	rjmp	.+58     	; 0x4540 <vfprintf+0xf8>
    4506:	37 fc       	sbrc	r3, 7
    4508:	2d c0       	rjmp	.+90     	; 0x4564 <vfprintf+0x11c>
    450a:	20 ed       	ldi	r18, 0xD0	; 208
    450c:	28 0f       	add	r18, r24
    450e:	2a 30       	cpi	r18, 0x0A	; 10
    4510:	40 f0       	brcs	.+16     	; 0x4522 <vfprintf+0xda>
    4512:	8e 32       	cpi	r24, 0x2E	; 46
    4514:	b9 f4       	brne	.+46     	; 0x4544 <vfprintf+0xfc>
    4516:	36 fc       	sbrc	r3, 6
    4518:	75 c1       	rjmp	.+746    	; 0x4804 <vfprintf+0x3bc>
    451a:	23 2d       	mov	r18, r3
    451c:	20 64       	ori	r18, 0x40	; 64
    451e:	32 2e       	mov	r3, r18
    4520:	19 c0       	rjmp	.+50     	; 0x4554 <vfprintf+0x10c>
    4522:	36 fe       	sbrs	r3, 6
    4524:	06 c0       	rjmp	.+12     	; 0x4532 <vfprintf+0xea>
    4526:	8a e0       	ldi	r24, 0x0A	; 10
    4528:	98 9e       	mul	r9, r24
    452a:	20 0d       	add	r18, r0
    452c:	11 24       	eor	r1, r1
    452e:	92 2e       	mov	r9, r18
    4530:	11 c0       	rjmp	.+34     	; 0x4554 <vfprintf+0x10c>
    4532:	ea e0       	ldi	r30, 0x0A	; 10
    4534:	2e 9e       	mul	r2, r30
    4536:	20 0d       	add	r18, r0
    4538:	11 24       	eor	r1, r1
    453a:	22 2e       	mov	r2, r18
    453c:	f3 2d       	mov	r31, r3
    453e:	f0 62       	ori	r31, 0x20	; 32
    4540:	3f 2e       	mov	r3, r31
    4542:	08 c0       	rjmp	.+16     	; 0x4554 <vfprintf+0x10c>
    4544:	8c 36       	cpi	r24, 0x6C	; 108
    4546:	21 f4       	brne	.+8      	; 0x4550 <vfprintf+0x108>
    4548:	83 2d       	mov	r24, r3
    454a:	80 68       	ori	r24, 0x80	; 128
    454c:	38 2e       	mov	r3, r24
    454e:	02 c0       	rjmp	.+4      	; 0x4554 <vfprintf+0x10c>
    4550:	88 36       	cpi	r24, 0x68	; 104
    4552:	41 f4       	brne	.+16     	; 0x4564 <vfprintf+0x11c>
    4554:	f7 01       	movw	r30, r14
    4556:	93 fd       	sbrc	r25, 3
    4558:	85 91       	lpm	r24, Z+
    455a:	93 ff       	sbrs	r25, 3
    455c:	81 91       	ld	r24, Z+
    455e:	7f 01       	movw	r14, r30
    4560:	81 11       	cpse	r24, r1
    4562:	b3 cf       	rjmp	.-154    	; 0x44ca <vfprintf+0x82>
    4564:	98 2f       	mov	r25, r24
    4566:	9f 7d       	andi	r25, 0xDF	; 223
    4568:	95 54       	subi	r25, 0x45	; 69
    456a:	93 30       	cpi	r25, 0x03	; 3
    456c:	28 f4       	brcc	.+10     	; 0x4578 <vfprintf+0x130>
    456e:	0c 5f       	subi	r16, 0xFC	; 252
    4570:	1f 4f       	sbci	r17, 0xFF	; 255
    4572:	9f e3       	ldi	r25, 0x3F	; 63
    4574:	99 83       	std	Y+1, r25	; 0x01
    4576:	0d c0       	rjmp	.+26     	; 0x4592 <vfprintf+0x14a>
    4578:	83 36       	cpi	r24, 0x63	; 99
    457a:	31 f0       	breq	.+12     	; 0x4588 <vfprintf+0x140>
    457c:	83 37       	cpi	r24, 0x73	; 115
    457e:	71 f0       	breq	.+28     	; 0x459c <vfprintf+0x154>
    4580:	83 35       	cpi	r24, 0x53	; 83
    4582:	09 f0       	breq	.+2      	; 0x4586 <vfprintf+0x13e>
    4584:	55 c0       	rjmp	.+170    	; 0x4630 <vfprintf+0x1e8>
    4586:	20 c0       	rjmp	.+64     	; 0x45c8 <vfprintf+0x180>
    4588:	f8 01       	movw	r30, r16
    458a:	80 81       	ld	r24, Z
    458c:	89 83       	std	Y+1, r24	; 0x01
    458e:	0e 5f       	subi	r16, 0xFE	; 254
    4590:	1f 4f       	sbci	r17, 0xFF	; 255
    4592:	88 24       	eor	r8, r8
    4594:	83 94       	inc	r8
    4596:	91 2c       	mov	r9, r1
    4598:	53 01       	movw	r10, r6
    459a:	12 c0       	rjmp	.+36     	; 0x45c0 <vfprintf+0x178>
    459c:	28 01       	movw	r4, r16
    459e:	f2 e0       	ldi	r31, 0x02	; 2
    45a0:	4f 0e       	add	r4, r31
    45a2:	51 1c       	adc	r5, r1
    45a4:	f8 01       	movw	r30, r16
    45a6:	a0 80       	ld	r10, Z
    45a8:	b1 80       	ldd	r11, Z+1	; 0x01
    45aa:	36 fe       	sbrs	r3, 6
    45ac:	03 c0       	rjmp	.+6      	; 0x45b4 <vfprintf+0x16c>
    45ae:	69 2d       	mov	r22, r9
    45b0:	70 e0       	ldi	r23, 0x00	; 0
    45b2:	02 c0       	rjmp	.+4      	; 0x45b8 <vfprintf+0x170>
    45b4:	6f ef       	ldi	r22, 0xFF	; 255
    45b6:	7f ef       	ldi	r23, 0xFF	; 255
    45b8:	c5 01       	movw	r24, r10
    45ba:	4e d1       	rcall	.+668    	; 0x4858 <strnlen>
    45bc:	4c 01       	movw	r8, r24
    45be:	82 01       	movw	r16, r4
    45c0:	f3 2d       	mov	r31, r3
    45c2:	ff 77       	andi	r31, 0x7F	; 127
    45c4:	3f 2e       	mov	r3, r31
    45c6:	15 c0       	rjmp	.+42     	; 0x45f2 <vfprintf+0x1aa>
    45c8:	28 01       	movw	r4, r16
    45ca:	22 e0       	ldi	r18, 0x02	; 2
    45cc:	42 0e       	add	r4, r18
    45ce:	51 1c       	adc	r5, r1
    45d0:	f8 01       	movw	r30, r16
    45d2:	a0 80       	ld	r10, Z
    45d4:	b1 80       	ldd	r11, Z+1	; 0x01
    45d6:	36 fe       	sbrs	r3, 6
    45d8:	03 c0       	rjmp	.+6      	; 0x45e0 <vfprintf+0x198>
    45da:	69 2d       	mov	r22, r9
    45dc:	70 e0       	ldi	r23, 0x00	; 0
    45de:	02 c0       	rjmp	.+4      	; 0x45e4 <vfprintf+0x19c>
    45e0:	6f ef       	ldi	r22, 0xFF	; 255
    45e2:	7f ef       	ldi	r23, 0xFF	; 255
    45e4:	c5 01       	movw	r24, r10
    45e6:	2d d1       	rcall	.+602    	; 0x4842 <strnlen_P>
    45e8:	4c 01       	movw	r8, r24
    45ea:	f3 2d       	mov	r31, r3
    45ec:	f0 68       	ori	r31, 0x80	; 128
    45ee:	3f 2e       	mov	r3, r31
    45f0:	82 01       	movw	r16, r4
    45f2:	33 fc       	sbrc	r3, 3
    45f4:	19 c0       	rjmp	.+50     	; 0x4628 <vfprintf+0x1e0>
    45f6:	82 2d       	mov	r24, r2
    45f8:	90 e0       	ldi	r25, 0x00	; 0
    45fa:	88 16       	cp	r8, r24
    45fc:	99 06       	cpc	r9, r25
    45fe:	a0 f4       	brcc	.+40     	; 0x4628 <vfprintf+0x1e0>
    4600:	b6 01       	movw	r22, r12
    4602:	80 e2       	ldi	r24, 0x20	; 32
    4604:	90 e0       	ldi	r25, 0x00	; 0
    4606:	43 d1       	rcall	.+646    	; 0x488e <fputc>
    4608:	2a 94       	dec	r2
    460a:	f5 cf       	rjmp	.-22     	; 0x45f6 <vfprintf+0x1ae>
    460c:	f5 01       	movw	r30, r10
    460e:	37 fc       	sbrc	r3, 7
    4610:	85 91       	lpm	r24, Z+
    4612:	37 fe       	sbrs	r3, 7
    4614:	81 91       	ld	r24, Z+
    4616:	5f 01       	movw	r10, r30
    4618:	b6 01       	movw	r22, r12
    461a:	90 e0       	ldi	r25, 0x00	; 0
    461c:	38 d1       	rcall	.+624    	; 0x488e <fputc>
    461e:	21 10       	cpse	r2, r1
    4620:	2a 94       	dec	r2
    4622:	21 e0       	ldi	r18, 0x01	; 1
    4624:	82 1a       	sub	r8, r18
    4626:	91 08       	sbc	r9, r1
    4628:	81 14       	cp	r8, r1
    462a:	91 04       	cpc	r9, r1
    462c:	79 f7       	brne	.-34     	; 0x460c <vfprintf+0x1c4>
    462e:	e1 c0       	rjmp	.+450    	; 0x47f2 <vfprintf+0x3aa>
    4630:	84 36       	cpi	r24, 0x64	; 100
    4632:	11 f0       	breq	.+4      	; 0x4638 <vfprintf+0x1f0>
    4634:	89 36       	cpi	r24, 0x69	; 105
    4636:	39 f5       	brne	.+78     	; 0x4686 <vfprintf+0x23e>
    4638:	f8 01       	movw	r30, r16
    463a:	37 fe       	sbrs	r3, 7
    463c:	07 c0       	rjmp	.+14     	; 0x464c <vfprintf+0x204>
    463e:	60 81       	ld	r22, Z
    4640:	71 81       	ldd	r23, Z+1	; 0x01
    4642:	82 81       	ldd	r24, Z+2	; 0x02
    4644:	93 81       	ldd	r25, Z+3	; 0x03
    4646:	0c 5f       	subi	r16, 0xFC	; 252
    4648:	1f 4f       	sbci	r17, 0xFF	; 255
    464a:	08 c0       	rjmp	.+16     	; 0x465c <vfprintf+0x214>
    464c:	60 81       	ld	r22, Z
    464e:	71 81       	ldd	r23, Z+1	; 0x01
    4650:	07 2e       	mov	r0, r23
    4652:	00 0c       	add	r0, r0
    4654:	88 0b       	sbc	r24, r24
    4656:	99 0b       	sbc	r25, r25
    4658:	0e 5f       	subi	r16, 0xFE	; 254
    465a:	1f 4f       	sbci	r17, 0xFF	; 255
    465c:	f3 2d       	mov	r31, r3
    465e:	ff 76       	andi	r31, 0x6F	; 111
    4660:	3f 2e       	mov	r3, r31
    4662:	97 ff       	sbrs	r25, 7
    4664:	09 c0       	rjmp	.+18     	; 0x4678 <vfprintf+0x230>
    4666:	90 95       	com	r25
    4668:	80 95       	com	r24
    466a:	70 95       	com	r23
    466c:	61 95       	neg	r22
    466e:	7f 4f       	sbci	r23, 0xFF	; 255
    4670:	8f 4f       	sbci	r24, 0xFF	; 255
    4672:	9f 4f       	sbci	r25, 0xFF	; 255
    4674:	f0 68       	ori	r31, 0x80	; 128
    4676:	3f 2e       	mov	r3, r31
    4678:	2a e0       	ldi	r18, 0x0A	; 10
    467a:	30 e0       	ldi	r19, 0x00	; 0
    467c:	a3 01       	movw	r20, r6
    467e:	43 d1       	rcall	.+646    	; 0x4906 <__ultoa_invert>
    4680:	88 2e       	mov	r8, r24
    4682:	86 18       	sub	r8, r6
    4684:	44 c0       	rjmp	.+136    	; 0x470e <vfprintf+0x2c6>
    4686:	85 37       	cpi	r24, 0x75	; 117
    4688:	31 f4       	brne	.+12     	; 0x4696 <vfprintf+0x24e>
    468a:	23 2d       	mov	r18, r3
    468c:	2f 7e       	andi	r18, 0xEF	; 239
    468e:	b2 2e       	mov	r11, r18
    4690:	2a e0       	ldi	r18, 0x0A	; 10
    4692:	30 e0       	ldi	r19, 0x00	; 0
    4694:	25 c0       	rjmp	.+74     	; 0x46e0 <vfprintf+0x298>
    4696:	93 2d       	mov	r25, r3
    4698:	99 7f       	andi	r25, 0xF9	; 249
    469a:	b9 2e       	mov	r11, r25
    469c:	8f 36       	cpi	r24, 0x6F	; 111
    469e:	c1 f0       	breq	.+48     	; 0x46d0 <vfprintf+0x288>
    46a0:	18 f4       	brcc	.+6      	; 0x46a8 <vfprintf+0x260>
    46a2:	88 35       	cpi	r24, 0x58	; 88
    46a4:	79 f0       	breq	.+30     	; 0x46c4 <vfprintf+0x27c>
    46a6:	ae c0       	rjmp	.+348    	; 0x4804 <vfprintf+0x3bc>
    46a8:	80 37       	cpi	r24, 0x70	; 112
    46aa:	19 f0       	breq	.+6      	; 0x46b2 <vfprintf+0x26a>
    46ac:	88 37       	cpi	r24, 0x78	; 120
    46ae:	21 f0       	breq	.+8      	; 0x46b8 <vfprintf+0x270>
    46b0:	a9 c0       	rjmp	.+338    	; 0x4804 <vfprintf+0x3bc>
    46b2:	e9 2f       	mov	r30, r25
    46b4:	e0 61       	ori	r30, 0x10	; 16
    46b6:	be 2e       	mov	r11, r30
    46b8:	b4 fe       	sbrs	r11, 4
    46ba:	0d c0       	rjmp	.+26     	; 0x46d6 <vfprintf+0x28e>
    46bc:	fb 2d       	mov	r31, r11
    46be:	f4 60       	ori	r31, 0x04	; 4
    46c0:	bf 2e       	mov	r11, r31
    46c2:	09 c0       	rjmp	.+18     	; 0x46d6 <vfprintf+0x28e>
    46c4:	34 fe       	sbrs	r3, 4
    46c6:	0a c0       	rjmp	.+20     	; 0x46dc <vfprintf+0x294>
    46c8:	29 2f       	mov	r18, r25
    46ca:	26 60       	ori	r18, 0x06	; 6
    46cc:	b2 2e       	mov	r11, r18
    46ce:	06 c0       	rjmp	.+12     	; 0x46dc <vfprintf+0x294>
    46d0:	28 e0       	ldi	r18, 0x08	; 8
    46d2:	30 e0       	ldi	r19, 0x00	; 0
    46d4:	05 c0       	rjmp	.+10     	; 0x46e0 <vfprintf+0x298>
    46d6:	20 e1       	ldi	r18, 0x10	; 16
    46d8:	30 e0       	ldi	r19, 0x00	; 0
    46da:	02 c0       	rjmp	.+4      	; 0x46e0 <vfprintf+0x298>
    46dc:	20 e1       	ldi	r18, 0x10	; 16
    46de:	32 e0       	ldi	r19, 0x02	; 2
    46e0:	f8 01       	movw	r30, r16
    46e2:	b7 fe       	sbrs	r11, 7
    46e4:	07 c0       	rjmp	.+14     	; 0x46f4 <vfprintf+0x2ac>
    46e6:	60 81       	ld	r22, Z
    46e8:	71 81       	ldd	r23, Z+1	; 0x01
    46ea:	82 81       	ldd	r24, Z+2	; 0x02
    46ec:	93 81       	ldd	r25, Z+3	; 0x03
    46ee:	0c 5f       	subi	r16, 0xFC	; 252
    46f0:	1f 4f       	sbci	r17, 0xFF	; 255
    46f2:	06 c0       	rjmp	.+12     	; 0x4700 <vfprintf+0x2b8>
    46f4:	60 81       	ld	r22, Z
    46f6:	71 81       	ldd	r23, Z+1	; 0x01
    46f8:	80 e0       	ldi	r24, 0x00	; 0
    46fa:	90 e0       	ldi	r25, 0x00	; 0
    46fc:	0e 5f       	subi	r16, 0xFE	; 254
    46fe:	1f 4f       	sbci	r17, 0xFF	; 255
    4700:	a3 01       	movw	r20, r6
    4702:	01 d1       	rcall	.+514    	; 0x4906 <__ultoa_invert>
    4704:	88 2e       	mov	r8, r24
    4706:	86 18       	sub	r8, r6
    4708:	fb 2d       	mov	r31, r11
    470a:	ff 77       	andi	r31, 0x7F	; 127
    470c:	3f 2e       	mov	r3, r31
    470e:	36 fe       	sbrs	r3, 6
    4710:	0d c0       	rjmp	.+26     	; 0x472c <vfprintf+0x2e4>
    4712:	23 2d       	mov	r18, r3
    4714:	2e 7f       	andi	r18, 0xFE	; 254
    4716:	a2 2e       	mov	r10, r18
    4718:	89 14       	cp	r8, r9
    471a:	58 f4       	brcc	.+22     	; 0x4732 <vfprintf+0x2ea>
    471c:	34 fe       	sbrs	r3, 4
    471e:	0b c0       	rjmp	.+22     	; 0x4736 <vfprintf+0x2ee>
    4720:	32 fc       	sbrc	r3, 2
    4722:	09 c0       	rjmp	.+18     	; 0x4736 <vfprintf+0x2ee>
    4724:	83 2d       	mov	r24, r3
    4726:	8e 7e       	andi	r24, 0xEE	; 238
    4728:	a8 2e       	mov	r10, r24
    472a:	05 c0       	rjmp	.+10     	; 0x4736 <vfprintf+0x2ee>
    472c:	b8 2c       	mov	r11, r8
    472e:	a3 2c       	mov	r10, r3
    4730:	03 c0       	rjmp	.+6      	; 0x4738 <vfprintf+0x2f0>
    4732:	b8 2c       	mov	r11, r8
    4734:	01 c0       	rjmp	.+2      	; 0x4738 <vfprintf+0x2f0>
    4736:	b9 2c       	mov	r11, r9
    4738:	a4 fe       	sbrs	r10, 4
    473a:	0f c0       	rjmp	.+30     	; 0x475a <vfprintf+0x312>
    473c:	fe 01       	movw	r30, r28
    473e:	e8 0d       	add	r30, r8
    4740:	f1 1d       	adc	r31, r1
    4742:	80 81       	ld	r24, Z
    4744:	80 33       	cpi	r24, 0x30	; 48
    4746:	21 f4       	brne	.+8      	; 0x4750 <vfprintf+0x308>
    4748:	9a 2d       	mov	r25, r10
    474a:	99 7e       	andi	r25, 0xE9	; 233
    474c:	a9 2e       	mov	r10, r25
    474e:	09 c0       	rjmp	.+18     	; 0x4762 <vfprintf+0x31a>
    4750:	a2 fe       	sbrs	r10, 2
    4752:	06 c0       	rjmp	.+12     	; 0x4760 <vfprintf+0x318>
    4754:	b3 94       	inc	r11
    4756:	b3 94       	inc	r11
    4758:	04 c0       	rjmp	.+8      	; 0x4762 <vfprintf+0x31a>
    475a:	8a 2d       	mov	r24, r10
    475c:	86 78       	andi	r24, 0x86	; 134
    475e:	09 f0       	breq	.+2      	; 0x4762 <vfprintf+0x31a>
    4760:	b3 94       	inc	r11
    4762:	a3 fc       	sbrc	r10, 3
    4764:	10 c0       	rjmp	.+32     	; 0x4786 <vfprintf+0x33e>
    4766:	a0 fe       	sbrs	r10, 0
    4768:	06 c0       	rjmp	.+12     	; 0x4776 <vfprintf+0x32e>
    476a:	b2 14       	cp	r11, r2
    476c:	80 f4       	brcc	.+32     	; 0x478e <vfprintf+0x346>
    476e:	28 0c       	add	r2, r8
    4770:	92 2c       	mov	r9, r2
    4772:	9b 18       	sub	r9, r11
    4774:	0d c0       	rjmp	.+26     	; 0x4790 <vfprintf+0x348>
    4776:	b2 14       	cp	r11, r2
    4778:	58 f4       	brcc	.+22     	; 0x4790 <vfprintf+0x348>
    477a:	b6 01       	movw	r22, r12
    477c:	80 e2       	ldi	r24, 0x20	; 32
    477e:	90 e0       	ldi	r25, 0x00	; 0
    4780:	86 d0       	rcall	.+268    	; 0x488e <fputc>
    4782:	b3 94       	inc	r11
    4784:	f8 cf       	rjmp	.-16     	; 0x4776 <vfprintf+0x32e>
    4786:	b2 14       	cp	r11, r2
    4788:	18 f4       	brcc	.+6      	; 0x4790 <vfprintf+0x348>
    478a:	2b 18       	sub	r2, r11
    478c:	02 c0       	rjmp	.+4      	; 0x4792 <vfprintf+0x34a>
    478e:	98 2c       	mov	r9, r8
    4790:	21 2c       	mov	r2, r1
    4792:	a4 fe       	sbrs	r10, 4
    4794:	0f c0       	rjmp	.+30     	; 0x47b4 <vfprintf+0x36c>
    4796:	b6 01       	movw	r22, r12
    4798:	80 e3       	ldi	r24, 0x30	; 48
    479a:	90 e0       	ldi	r25, 0x00	; 0
    479c:	78 d0       	rcall	.+240    	; 0x488e <fputc>
    479e:	a2 fe       	sbrs	r10, 2
    47a0:	16 c0       	rjmp	.+44     	; 0x47ce <vfprintf+0x386>
    47a2:	a1 fc       	sbrc	r10, 1
    47a4:	03 c0       	rjmp	.+6      	; 0x47ac <vfprintf+0x364>
    47a6:	88 e7       	ldi	r24, 0x78	; 120
    47a8:	90 e0       	ldi	r25, 0x00	; 0
    47aa:	02 c0       	rjmp	.+4      	; 0x47b0 <vfprintf+0x368>
    47ac:	88 e5       	ldi	r24, 0x58	; 88
    47ae:	90 e0       	ldi	r25, 0x00	; 0
    47b0:	b6 01       	movw	r22, r12
    47b2:	0c c0       	rjmp	.+24     	; 0x47cc <vfprintf+0x384>
    47b4:	8a 2d       	mov	r24, r10
    47b6:	86 78       	andi	r24, 0x86	; 134
    47b8:	51 f0       	breq	.+20     	; 0x47ce <vfprintf+0x386>
    47ba:	a1 fe       	sbrs	r10, 1
    47bc:	02 c0       	rjmp	.+4      	; 0x47c2 <vfprintf+0x37a>
    47be:	8b e2       	ldi	r24, 0x2B	; 43
    47c0:	01 c0       	rjmp	.+2      	; 0x47c4 <vfprintf+0x37c>
    47c2:	80 e2       	ldi	r24, 0x20	; 32
    47c4:	a7 fc       	sbrc	r10, 7
    47c6:	8d e2       	ldi	r24, 0x2D	; 45
    47c8:	b6 01       	movw	r22, r12
    47ca:	90 e0       	ldi	r25, 0x00	; 0
    47cc:	60 d0       	rcall	.+192    	; 0x488e <fputc>
    47ce:	89 14       	cp	r8, r9
    47d0:	30 f4       	brcc	.+12     	; 0x47de <vfprintf+0x396>
    47d2:	b6 01       	movw	r22, r12
    47d4:	80 e3       	ldi	r24, 0x30	; 48
    47d6:	90 e0       	ldi	r25, 0x00	; 0
    47d8:	5a d0       	rcall	.+180    	; 0x488e <fputc>
    47da:	9a 94       	dec	r9
    47dc:	f8 cf       	rjmp	.-16     	; 0x47ce <vfprintf+0x386>
    47de:	8a 94       	dec	r8
    47e0:	f3 01       	movw	r30, r6
    47e2:	e8 0d       	add	r30, r8
    47e4:	f1 1d       	adc	r31, r1
    47e6:	80 81       	ld	r24, Z
    47e8:	b6 01       	movw	r22, r12
    47ea:	90 e0       	ldi	r25, 0x00	; 0
    47ec:	50 d0       	rcall	.+160    	; 0x488e <fputc>
    47ee:	81 10       	cpse	r8, r1
    47f0:	f6 cf       	rjmp	.-20     	; 0x47de <vfprintf+0x396>
    47f2:	22 20       	and	r2, r2
    47f4:	09 f4       	brne	.+2      	; 0x47f8 <vfprintf+0x3b0>
    47f6:	4e ce       	rjmp	.-868    	; 0x4494 <vfprintf+0x4c>
    47f8:	b6 01       	movw	r22, r12
    47fa:	80 e2       	ldi	r24, 0x20	; 32
    47fc:	90 e0       	ldi	r25, 0x00	; 0
    47fe:	47 d0       	rcall	.+142    	; 0x488e <fputc>
    4800:	2a 94       	dec	r2
    4802:	f7 cf       	rjmp	.-18     	; 0x47f2 <vfprintf+0x3aa>
    4804:	f6 01       	movw	r30, r12
    4806:	86 81       	ldd	r24, Z+6	; 0x06
    4808:	97 81       	ldd	r25, Z+7	; 0x07
    480a:	02 c0       	rjmp	.+4      	; 0x4810 <vfprintf+0x3c8>
    480c:	8f ef       	ldi	r24, 0xFF	; 255
    480e:	9f ef       	ldi	r25, 0xFF	; 255
    4810:	2b 96       	adiw	r28, 0x0b	; 11
    4812:	0f b6       	in	r0, 0x3f	; 63
    4814:	f8 94       	cli
    4816:	de bf       	out	0x3e, r29	; 62
    4818:	0f be       	out	0x3f, r0	; 63
    481a:	cd bf       	out	0x3d, r28	; 61
    481c:	df 91       	pop	r29
    481e:	cf 91       	pop	r28
    4820:	1f 91       	pop	r17
    4822:	0f 91       	pop	r16
    4824:	ff 90       	pop	r15
    4826:	ef 90       	pop	r14
    4828:	df 90       	pop	r13
    482a:	cf 90       	pop	r12
    482c:	bf 90       	pop	r11
    482e:	af 90       	pop	r10
    4830:	9f 90       	pop	r9
    4832:	8f 90       	pop	r8
    4834:	7f 90       	pop	r7
    4836:	6f 90       	pop	r6
    4838:	5f 90       	pop	r5
    483a:	4f 90       	pop	r4
    483c:	3f 90       	pop	r3
    483e:	2f 90       	pop	r2
    4840:	08 95       	ret

00004842 <strnlen_P>:
    4842:	fc 01       	movw	r30, r24
    4844:	05 90       	lpm	r0, Z+
    4846:	61 50       	subi	r22, 0x01	; 1
    4848:	70 40       	sbci	r23, 0x00	; 0
    484a:	01 10       	cpse	r0, r1
    484c:	d8 f7       	brcc	.-10     	; 0x4844 <strnlen_P+0x2>
    484e:	80 95       	com	r24
    4850:	90 95       	com	r25
    4852:	8e 0f       	add	r24, r30
    4854:	9f 1f       	adc	r25, r31
    4856:	08 95       	ret

00004858 <strnlen>:
    4858:	fc 01       	movw	r30, r24
    485a:	61 50       	subi	r22, 0x01	; 1
    485c:	70 40       	sbci	r23, 0x00	; 0
    485e:	01 90       	ld	r0, Z+
    4860:	01 10       	cpse	r0, r1
    4862:	d8 f7       	brcc	.-10     	; 0x485a <strnlen+0x2>
    4864:	80 95       	com	r24
    4866:	90 95       	com	r25
    4868:	8e 0f       	add	r24, r30
    486a:	9f 1f       	adc	r25, r31
    486c:	08 95       	ret

0000486e <strrev>:
    486e:	dc 01       	movw	r26, r24
    4870:	fc 01       	movw	r30, r24
    4872:	67 2f       	mov	r22, r23
    4874:	71 91       	ld	r23, Z+
    4876:	77 23       	and	r23, r23
    4878:	e1 f7       	brne	.-8      	; 0x4872 <strrev+0x4>
    487a:	32 97       	sbiw	r30, 0x02	; 2
    487c:	04 c0       	rjmp	.+8      	; 0x4886 <strrev+0x18>
    487e:	7c 91       	ld	r23, X
    4880:	6d 93       	st	X+, r22
    4882:	70 83       	st	Z, r23
    4884:	62 91       	ld	r22, -Z
    4886:	ae 17       	cp	r26, r30
    4888:	bf 07       	cpc	r27, r31
    488a:	c8 f3       	brcs	.-14     	; 0x487e <strrev+0x10>
    488c:	08 95       	ret

0000488e <fputc>:
    488e:	0f 93       	push	r16
    4890:	1f 93       	push	r17
    4892:	cf 93       	push	r28
    4894:	df 93       	push	r29
    4896:	fb 01       	movw	r30, r22
    4898:	23 81       	ldd	r18, Z+3	; 0x03
    489a:	21 fd       	sbrc	r18, 1
    489c:	03 c0       	rjmp	.+6      	; 0x48a4 <fputc+0x16>
    489e:	8f ef       	ldi	r24, 0xFF	; 255
    48a0:	9f ef       	ldi	r25, 0xFF	; 255
    48a2:	2c c0       	rjmp	.+88     	; 0x48fc <fputc+0x6e>
    48a4:	22 ff       	sbrs	r18, 2
    48a6:	16 c0       	rjmp	.+44     	; 0x48d4 <fputc+0x46>
    48a8:	46 81       	ldd	r20, Z+6	; 0x06
    48aa:	57 81       	ldd	r21, Z+7	; 0x07
    48ac:	24 81       	ldd	r18, Z+4	; 0x04
    48ae:	35 81       	ldd	r19, Z+5	; 0x05
    48b0:	42 17       	cp	r20, r18
    48b2:	53 07       	cpc	r21, r19
    48b4:	44 f4       	brge	.+16     	; 0x48c6 <fputc+0x38>
    48b6:	a0 81       	ld	r26, Z
    48b8:	b1 81       	ldd	r27, Z+1	; 0x01
    48ba:	9d 01       	movw	r18, r26
    48bc:	2f 5f       	subi	r18, 0xFF	; 255
    48be:	3f 4f       	sbci	r19, 0xFF	; 255
    48c0:	31 83       	std	Z+1, r19	; 0x01
    48c2:	20 83       	st	Z, r18
    48c4:	8c 93       	st	X, r24
    48c6:	26 81       	ldd	r18, Z+6	; 0x06
    48c8:	37 81       	ldd	r19, Z+7	; 0x07
    48ca:	2f 5f       	subi	r18, 0xFF	; 255
    48cc:	3f 4f       	sbci	r19, 0xFF	; 255
    48ce:	37 83       	std	Z+7, r19	; 0x07
    48d0:	26 83       	std	Z+6, r18	; 0x06
    48d2:	14 c0       	rjmp	.+40     	; 0x48fc <fputc+0x6e>
    48d4:	8b 01       	movw	r16, r22
    48d6:	ec 01       	movw	r28, r24
    48d8:	fb 01       	movw	r30, r22
    48da:	00 84       	ldd	r0, Z+8	; 0x08
    48dc:	f1 85       	ldd	r31, Z+9	; 0x09
    48de:	e0 2d       	mov	r30, r0
    48e0:	19 95       	eicall
    48e2:	89 2b       	or	r24, r25
    48e4:	e1 f6       	brne	.-72     	; 0x489e <fputc+0x10>
    48e6:	d8 01       	movw	r26, r16
    48e8:	16 96       	adiw	r26, 0x06	; 6
    48ea:	8d 91       	ld	r24, X+
    48ec:	9c 91       	ld	r25, X
    48ee:	17 97       	sbiw	r26, 0x07	; 7
    48f0:	01 96       	adiw	r24, 0x01	; 1
    48f2:	17 96       	adiw	r26, 0x07	; 7
    48f4:	9c 93       	st	X, r25
    48f6:	8e 93       	st	-X, r24
    48f8:	16 97       	sbiw	r26, 0x06	; 6
    48fa:	ce 01       	movw	r24, r28
    48fc:	df 91       	pop	r29
    48fe:	cf 91       	pop	r28
    4900:	1f 91       	pop	r17
    4902:	0f 91       	pop	r16
    4904:	08 95       	ret

00004906 <__ultoa_invert>:
    4906:	fa 01       	movw	r30, r20
    4908:	aa 27       	eor	r26, r26
    490a:	28 30       	cpi	r18, 0x08	; 8
    490c:	51 f1       	breq	.+84     	; 0x4962 <__ultoa_invert+0x5c>
    490e:	20 31       	cpi	r18, 0x10	; 16
    4910:	81 f1       	breq	.+96     	; 0x4972 <__ultoa_invert+0x6c>
    4912:	e8 94       	clt
    4914:	6f 93       	push	r22
    4916:	6e 7f       	andi	r22, 0xFE	; 254
    4918:	6e 5f       	subi	r22, 0xFE	; 254
    491a:	7f 4f       	sbci	r23, 0xFF	; 255
    491c:	8f 4f       	sbci	r24, 0xFF	; 255
    491e:	9f 4f       	sbci	r25, 0xFF	; 255
    4920:	af 4f       	sbci	r26, 0xFF	; 255
    4922:	b1 e0       	ldi	r27, 0x01	; 1
    4924:	3e d0       	rcall	.+124    	; 0x49a2 <__ultoa_invert+0x9c>
    4926:	b4 e0       	ldi	r27, 0x04	; 4
    4928:	3c d0       	rcall	.+120    	; 0x49a2 <__ultoa_invert+0x9c>
    492a:	67 0f       	add	r22, r23
    492c:	78 1f       	adc	r23, r24
    492e:	89 1f       	adc	r24, r25
    4930:	9a 1f       	adc	r25, r26
    4932:	a1 1d       	adc	r26, r1
    4934:	68 0f       	add	r22, r24
    4936:	79 1f       	adc	r23, r25
    4938:	8a 1f       	adc	r24, r26
    493a:	91 1d       	adc	r25, r1
    493c:	a1 1d       	adc	r26, r1
    493e:	6a 0f       	add	r22, r26
    4940:	71 1d       	adc	r23, r1
    4942:	81 1d       	adc	r24, r1
    4944:	91 1d       	adc	r25, r1
    4946:	a1 1d       	adc	r26, r1
    4948:	20 d0       	rcall	.+64     	; 0x498a <__ultoa_invert+0x84>
    494a:	09 f4       	brne	.+2      	; 0x494e <__ultoa_invert+0x48>
    494c:	68 94       	set
    494e:	3f 91       	pop	r19
    4950:	2a e0       	ldi	r18, 0x0A	; 10
    4952:	26 9f       	mul	r18, r22
    4954:	11 24       	eor	r1, r1
    4956:	30 19       	sub	r19, r0
    4958:	30 5d       	subi	r19, 0xD0	; 208
    495a:	31 93       	st	Z+, r19
    495c:	de f6       	brtc	.-74     	; 0x4914 <__ultoa_invert+0xe>
    495e:	cf 01       	movw	r24, r30
    4960:	08 95       	ret
    4962:	46 2f       	mov	r20, r22
    4964:	47 70       	andi	r20, 0x07	; 7
    4966:	40 5d       	subi	r20, 0xD0	; 208
    4968:	41 93       	st	Z+, r20
    496a:	b3 e0       	ldi	r27, 0x03	; 3
    496c:	0f d0       	rcall	.+30     	; 0x498c <__ultoa_invert+0x86>
    496e:	c9 f7       	brne	.-14     	; 0x4962 <__ultoa_invert+0x5c>
    4970:	f6 cf       	rjmp	.-20     	; 0x495e <__ultoa_invert+0x58>
    4972:	46 2f       	mov	r20, r22
    4974:	4f 70       	andi	r20, 0x0F	; 15
    4976:	40 5d       	subi	r20, 0xD0	; 208
    4978:	4a 33       	cpi	r20, 0x3A	; 58
    497a:	18 f0       	brcs	.+6      	; 0x4982 <__ultoa_invert+0x7c>
    497c:	49 5d       	subi	r20, 0xD9	; 217
    497e:	31 fd       	sbrc	r19, 1
    4980:	40 52       	subi	r20, 0x20	; 32
    4982:	41 93       	st	Z+, r20
    4984:	02 d0       	rcall	.+4      	; 0x498a <__ultoa_invert+0x84>
    4986:	a9 f7       	brne	.-22     	; 0x4972 <__ultoa_invert+0x6c>
    4988:	ea cf       	rjmp	.-44     	; 0x495e <__ultoa_invert+0x58>
    498a:	b4 e0       	ldi	r27, 0x04	; 4
    498c:	a6 95       	lsr	r26
    498e:	97 95       	ror	r25
    4990:	87 95       	ror	r24
    4992:	77 95       	ror	r23
    4994:	67 95       	ror	r22
    4996:	ba 95       	dec	r27
    4998:	c9 f7       	brne	.-14     	; 0x498c <__ultoa_invert+0x86>
    499a:	00 97       	sbiw	r24, 0x00	; 0
    499c:	61 05       	cpc	r22, r1
    499e:	71 05       	cpc	r23, r1
    49a0:	08 95       	ret
    49a2:	9b 01       	movw	r18, r22
    49a4:	ac 01       	movw	r20, r24
    49a6:	0a 2e       	mov	r0, r26
    49a8:	06 94       	lsr	r0
    49aa:	57 95       	ror	r21
    49ac:	47 95       	ror	r20
    49ae:	37 95       	ror	r19
    49b0:	27 95       	ror	r18
    49b2:	ba 95       	dec	r27
    49b4:	c9 f7       	brne	.-14     	; 0x49a8 <__ultoa_invert+0xa2>
    49b6:	62 0f       	add	r22, r18
    49b8:	73 1f       	adc	r23, r19
    49ba:	84 1f       	adc	r24, r20
    49bc:	95 1f       	adc	r25, r21
    49be:	a0 1d       	adc	r26, r0
    49c0:	08 95       	ret

000049c2 <_exit>:
    49c2:	f8 94       	cli

000049c4 <__stop_program>:
    49c4:	ff cf       	rjmp	.-2      	; 0x49c4 <__stop_program>
